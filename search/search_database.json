var tipuesearch = {"pages":[{"title":" HORSES3D ","text":"HORSES3D HORSES3D High-Order (DG) Spectral Element Solver MIT License Copyright (c) 2021 NUMATH https://numath.dmae.upm.es Synopsis HORSES3D is a multiphysics environment where the compressible Navier-Stokes equations, the incompressible Navier–Stokes equations, the Cahn–Hilliard equation and entropy–stable variants are solved. Arbitrary high–order, p–anisotropic discretisations are used, including static and dynamic p–adaptation methods (feature-based and truncation error-based). Explicit and implicit time-steppers for steady and time-marching solutions are available, including efficient multigrid and preconditioners. Numerical and analytical Jacobian computations with a coloring algorithm have been implemented. Multiphase flows are solved using a diffuse interface model: Navier–Stokes/Cahn–Hilliard. Turbulent models implemented include RANS: Spalart-Allmaras and LES: Smagorinsky, Wale, Vreman; including wall models. Immersed boundary methods can be used, to avoid creating body fitted meshes. Acoustic propagation can be computed using Ffowcs-Williams and Hawkings models. HORSES3D supports curvilinear, hexahedral, conforming meshes in GMSH, HDF5 and SpecMesh/HOHQMesh format. A hybrid CPU-based parallelisation strategy (shared and distributed memory) with OpenMP and MPI is followed. External libraries The following external routines/libraries can be used with HORSES3D , but are not necessary: METIS, MPI, HDF5, MKL, PETSc. Compilers and third-party software HORSES3D is an object-oriented Fortran 2008 solver, that can be compiled using gcc and the Intel compiler, in Unix-based operating systems. We recommend using recent versions of such compilers (2019 or newer). Make is necessary (e.g., Gnu's version, which is included in most linux distributions). Supported meshes are in GMSH, HDF5 (HOPR) and SpecMesh/HOHQMesh format. Post processing can be performed in tecplot or paraview. Compiling & Running Go to the Solver folder and configure the project shell\ncd Solver\n./configure Build the solvers using make (see manual in the /doc folder) shell\nmake clean\nmake all [options] with the desired options (defaults are bold): PLATFORM=MACOSX/ LINUX MODE=DEBUG/ RELEASE COMPILER=ifort/ gfortran COMM=PARALLEL/ SEQUENTIAL ENABLE_THREADS=NO/ YES WITH_PETSC=YES/ NO WITH_METIS=YES/ NO WITH_HDF5=YES/ NO WITH_MKL=YES/ NO For example: shell\nmake all COMPILER=ifort COMM=PARALLEL Run the solver for the parameter file file.control (see manual in the /doc folder and examples in /test ) shell\n./horses3d.ns file.control Test cases for various physics are provided in the folder /test Additional libraries PETSc: shell\nexport PETSC_DIR=path_to_petsc METIS: shell\nexport METIS_DIR=path_to_metis HDF5: shell\nexport HDF5_DIR=path_to_hdf5 Documentation Read the complete documentation here . Developer Info HORSES3D developers","tags":"home","url":"index.html"},{"title":"SpatialMeanNode_t – HORSES3D ","text":"type, public :: SpatialMeanNode_t Components Type Visibility Attributes Name Initial integer, public :: ID integer, public :: nVariables integer, public :: interval integer, public :: bufferSize integer, public :: bufferLine integer, public :: intervalCount integer, public :: nActive integer, public :: dirAxis integer, public :: nUniqueAll integer, public :: iVarU integer, public :: iVarV integer, public :: iVarW integer, public, allocatable :: activeLoc (:,:) integer, public, allocatable :: nMultiply (:) integer, public, allocatable :: nMultiplyAll (:) logical, public :: meanData = .false. real(kind=RP), public :: pmin (3) real(kind=RP), public :: pmax (3) real(kind=RP), public :: error = 0.000001 real(kind=RP), public, allocatable :: geom (:) real(kind=RP), public, allocatable :: meanU (:) real(kind=RP), public, allocatable :: meanV (:) real(kind=RP), public, allocatable :: meanW (:) real(kind=RP), public, allocatable :: values (:,:,:) character(len=STR_LEN_MONITORS), public, allocatable :: fileName (:) character(len=STR_LEN_MONITORS), public :: spatialMeanName character(len=STR_LEN_MONITORS), public, allocatable :: variable (:) Type-Bound Procedures procedure, public :: Initialization => SpatialMeanNode_Initialization private  subroutine SpatialMeanNode_Initialization(self, mesh, ID, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => SpatialMeanNode_Update private  subroutine SpatialMeanNode_Update(self, mesh, bufferPosition, t) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition real(kind=RP) :: t procedure, public :: WriteToFile => SpatialMeanNode_WriteToFile private  subroutine SpatialMeanNode_WriteToFile(self, no_of_lines) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ) :: self integer :: no_of_lines procedure, public :: LookForUniqueCoordinate => SpatialMeanNode_LookForUniqueCoordinate private  subroutine SpatialMeanNode_LookForUniqueCoordinate(self, mesh) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ) :: self class(HexMesh) :: mesh procedure, public :: destruct => SpatialMeanNode_Destruct private elemental subroutine SpatialMeanNode_Destruct(self) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ), intent(inout) :: self procedure, public :: copy => SpatialMeanNode_Assign private elemental subroutine SpatialMeanNode_Assign(to, from) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ), intent(inout) :: to type( SpatialMeanNode_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine SpatialMeanNode_Assign(to, from) Arguments Type Intent Optional Attributes Name class( SpatialMeanNode_t ), intent(inout) :: to type( SpatialMeanNode_t ), intent(in) :: from Source Code type SpatialMeanNode_t integer :: ID integer :: nVariables integer :: interval integer :: bufferSize integer :: bufferLine integer :: intervalCount integer :: nActive integer :: dirAxis integer :: nUniqueAll integer :: iVarU , iVarV , iVarW integer , allocatable :: activeLoc (:,:) integer , allocatable :: nMultiply (:) integer , allocatable :: nMultiplyAll (:) logical :: meanData = . false . real ( kind = RP ) :: pmin ( 3 ), pmax ( 3 ) real ( kind = RP ) :: error = 0.000001 ! tolerance of coordinate real ( kind = RP ), allocatable :: geom (:) ! size nUnique real ( kind = RP ), allocatable :: meanU (:), meanV (:), meanW (:) real ( kind = RP ), allocatable :: values (:,:,:) ! (nUnique, bufferSize, nVariables) character ( len = STR_LEN_MONITORS ), allocatable :: fileName (:) character ( len = STR_LEN_MONITORS ) :: spatialMeanName character ( len = STR_LEN_MONITORS ), allocatable :: variable (:) contains procedure :: Initialization => SpatialMeanNode_Initialization procedure :: Update => SpatialMeanNode_Update procedure :: WriteToFile => SpatialMeanNode_WriteToFile procedure :: LookForUniqueCoordinate => SpatialMeanNode_LookForUniqueCoordinate procedure :: destruct => SpatialMeanNode_Destruct procedure :: copy => SpatialMeanNode_Assign generic :: assignment ( = ) => copy end type SpatialMeanNode_t","tags":"","url":"type/spatialmeannode_t.html"},{"title":"Monitor_t – HORSES3D ","text":"type, public :: Monitor_t Components Type Visibility Attributes Name Initial character(len=LINE_LENGTH), public :: solution_file integer, public :: no_of_probes integer, public :: no_of_surfaceMonitors integer, public :: no_of_volumeMonitors integer, public :: no_of_loadBalancingMonitors integer, public :: bufferLine integer, public, allocatable :: iter (:) integer, public :: dt_restriction logical, public :: write_dt_restriction real(kind=RP), public, allocatable :: t (:) real(kind=RP), public, allocatable :: SolverSimuTime (:) real(kind=RP), public, allocatable :: TotalSimuTime (:) type( Residuals_t ), public :: residuals class( VolumeMonitor_t ), public, allocatable :: volumeMonitors (:) class( LoadBalancingMonitor_t ), public, allocatable :: loadBalancingMonitors (:) class( Probe_t ), public, allocatable :: probes (:) class( SurfaceMonitor_t ), public, allocatable :: surfaceMonitors (:) type( StatisticsMonitor_t ), public :: stats Type-Bound Procedures procedure, public :: Construct => Monitors_Construct private  subroutine Monitors_Construct(Monitors, mesh, controlVariables) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: Monitors class(HexMesh), intent(in) :: mesh class(FTValueDictionary), intent(in) :: controlVariables procedure, public :: WriteLabel => Monitor_WriteLabel private  subroutine Monitor_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: self procedure, public :: WriteUnderlines => Monitor_WriteUnderlines private  subroutine Monitor_WriteUnderlines(self) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: self procedure, public :: WriteValues => Monitor_WriteValues private  subroutine Monitor_WriteValues(self) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: self procedure, public :: UpdateValues => Monitor_UpdateValues private  subroutine Monitor_UpdateValues(self, mesh, t, iter, maxResiduals, Autosave, dt) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: self class(HexMesh) :: mesh real(kind=RP) :: t integer :: iter real(kind=RP) :: maxResiduals (NCONS) logical :: Autosave real(kind=RP) :: dt procedure, public :: WriteToFile => Monitor_WriteToFile private  subroutine Monitor_WriteToFile(self, mesh, force) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: self class(HexMesh) :: mesh logical, optional :: force procedure, public :: destruct => Monitor_Destruct private  subroutine Monitor_Destruct(self) Arguments Type Intent Optional Attributes Name class( Monitor_t ) :: self procedure, public :: copy => Monitor_Assign private impure elemental subroutine Monitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Monitor_t ), intent(inout) :: to type( Monitor_t ), intent(in) :: from generic, public :: assignment(=) => copy private impure elemental subroutine Monitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Monitor_t ), intent(inout) :: to type( Monitor_t ), intent(in) :: from Source Code type Monitor_t character ( len = LINE_LENGTH ) :: solution_file integer :: no_of_probes integer :: no_of_surfaceMonitors integer :: no_of_volumeMonitors integer :: no_of_loadBalancingMonitors integer :: bufferLine integer , allocatable :: iter (:) integer :: dt_restriction logical :: write_dt_restriction real ( kind = RP ) , allocatable :: t (:) real ( kind = RP ) , allocatable :: SolverSimuTime (:) real ( kind = RP ) , allocatable :: TotalSimuTime (:) type ( Residuals_t ) :: residuals class ( VolumeMonitor_t ) , allocatable :: volumeMonitors (:) class ( LoadBalancingMonitor_t ), allocatable :: loadBalancingMonitors (:) #ifdef FLOW class ( Probe_t ) , allocatable :: probes (:) #endif #if defined(NAVIERSTOKES) || defined(INCNS) class ( SurfaceMonitor_t ) , allocatable :: surfaceMonitors (:) type ( StatisticsMonitor_t ) :: stats #endif contains procedure :: Construct => Monitors_Construct procedure :: WriteLabel => Monitor_WriteLabel procedure :: WriteUnderlines => Monitor_WriteUnderlines procedure :: WriteValues => Monitor_WriteValues procedure :: UpdateValues => Monitor_UpdateValues procedure :: WriteToFile => Monitor_WriteToFile procedure :: destruct => Monitor_Destruct procedure :: copy => Monitor_Assign generic :: assignment ( = ) => copy end type Monitor_t","tags":"","url":"type/monitor_t.html"},{"title":"Sampling_t – HORSES3D ","text":"type, public :: Sampling_t Components Type Visibility Attributes Name Initial character(len=LINE_LENGTH), public :: solution_file integer, public :: no_of_surfaceSamplings = 0 integer, public :: no_of_planeSamplings = 0 integer, public :: no_of_spatialMeanNodes = 0 integer, public :: dt_restriction logical, public :: write_dt_restriction class( SurfaceSampling_t ), public, allocatable :: surfaceSamplings (:) class( PlaneSampling_t ), public, allocatable :: planeSamplings (:) class( SpatialMeanNode_t ), public, allocatable :: spatialMeanNodes (:) Type-Bound Procedures procedure, public :: Construct => Samplings_Construct private  subroutine Samplings_Construct(Samplings, mesh, controlVariables) Arguments Type Intent Optional Attributes Name class( Sampling_t ) :: Samplings class(HexMesh), intent(in) :: mesh class(FTValueDictionary), intent(in) :: controlVariables procedure, public :: UpdateInterp => Samplings_UpdateLagrangeInterp private  subroutine Samplings_UpdateLagrangeInterp(self, mesh) Arguments Type Intent Optional Attributes Name class( Sampling_t ) :: self class(HexMesh) :: mesh procedure, public :: UpdateValues => Sampling_UpdateValues private  subroutine Sampling_UpdateValues(self, mesh, t) Arguments Type Intent Optional Attributes Name class( Sampling_t ) :: self class(HexMesh) :: mesh real(kind=RP) :: t procedure, public :: WriteToFile => Sampling_WriteToFile private  subroutine Sampling_WriteToFile(self, mesh, force) Arguments Type Intent Optional Attributes Name class( Sampling_t ) :: self class(HexMesh) :: mesh logical, optional :: force procedure, public :: destruct => Sampling_Destruct private  subroutine Sampling_Destruct(self) Arguments Type Intent Optional Attributes Name class( Sampling_t ) :: self procedure, public :: copy => Sampling_Assign private impure elemental subroutine Sampling_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Sampling_t ), intent(inout) :: to type( Sampling_t ), intent(in) :: from generic, public :: assignment(=) => copy private impure elemental subroutine Sampling_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Sampling_t ), intent(inout) :: to type( Sampling_t ), intent(in) :: from Source Code type Sampling_t character ( len = LINE_LENGTH ) :: solution_file integer :: no_of_surfaceSamplings = 0 integer :: no_of_planeSamplings = 0 integer :: no_of_spatialMeanNodes = 0 integer :: dt_restriction logical :: write_dt_restriction class ( SurfaceSampling_t ), allocatable :: surfaceSamplings (:) class ( PlaneSampling_t ), allocatable :: planeSamplings (:) class ( SpatialMeanNode_t ), allocatable :: spatialMeanNodes (:) contains procedure :: Construct => Samplings_Construct procedure :: UpdateInterp => Samplings_UpdateLagrangeInterp procedure :: UpdateValues => Sampling_UpdateValues procedure :: WriteToFile => Sampling_WriteToFile procedure :: destruct => Sampling_Destruct procedure :: copy => Sampling_Assign generic :: assignment ( = ) => copy end type Sampling_t","tags":"","url":"type/sampling_t.html"},{"title":"ObserverSourcePairClass – HORSES3D ","text":"type, public :: ObserverSourcePairClass Components Type Visibility Attributes Name Initial real(kind=RP), public, dimension(:,:,:), allocatable :: rVect real(kind=RP), public, dimension(:,:), allocatable :: r real(kind=RP), public, dimension(:,:), allocatable :: re real(kind=RP), public, dimension(:,:,:), allocatable :: reUnitVect real(kind=RP), public, dimension(:,:), allocatable :: reStar real(kind=RP), public, dimension(:,:,:), allocatable :: reStarUnitVect real(kind=RP), public :: tDelay integer, public :: faceIDinMesh integer, public :: elementSide real(kind=RP), public :: normalCorrection real(kind=RP), public, dimension(:,:), allocatable :: Pacc real(kind=RP), public, dimension(:), allocatable :: tInterp Type-Bound Procedures procedure, public :: construct => ObserverSourcePairConstruct public  subroutine ObserverSourcePairConstruct (self, x, f, fID, FirstCall, elementSide) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self real(kind=RP), intent(in), dimension(NDIM) :: x type(face), intent(in) :: f integer, intent(in) :: fID logical, intent(in) :: FirstCall integer, intent(in) :: elementSide procedure, public :: destruct => ObserverSourcePairDestruct public elemental subroutine ObserverSourcePairDestruct (self) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ), intent(inout) :: self procedure, public :: allocPacc => ObserverSourcePairAllocSolution public  subroutine ObserverSourcePairAllocSolution (self, buffer_size) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: buffer_size procedure, public :: interpolateSolF => ObserverSourcePairInterpolateSolFirst public  subroutine ObserverSourcePairInterpolateSolFirst (self, N, M, tobserver, tsource, nd) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: N integer, intent(in) :: M real(kind=RP), intent(in), dimension(N) :: tobserver real(kind=RP), intent(in), dimension(:) :: tsource integer, intent(out) :: nd procedure, public :: newUpdate => ObserverSourcePairNewUpdate public  subroutine ObserverSourcePairNewUpdate (self, N, NDiscard, M, tsource, sameDelay) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: N integer, intent(in) :: NDiscard integer, intent(in) :: M real(kind=RP), intent(in), dimension(:) :: tsource logical, intent(in) :: sameDelay procedure, public :: interpolateSolS => ObserverSourcePairInterpolateSolSecond public  subroutine ObserverSourcePairInterpolateSolSecond (self, tobserver, tsource) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self real(kind=RP), intent(in) :: tobserver real(kind=RP), intent(in) :: tsource procedure, public :: updateOneStep => ObserverSourcePairUpdateOneStep public  subroutine ObserverSourcePairUpdateOneStep (self) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self procedure, public :: FWHSurfaceIntegral public  function FWHSurfaceIntegral (self, f, isSolid) result(Pacc) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self class(Face), intent(in) :: f logical, intent(in) :: isSolid Return Value real(kind=RP), dimension(3) Source Code type ObserverSourcePairClass real ( kind = RP ), dimension (:,:,:), allocatable :: rVect real ( kind = RP ), dimension (:,:), allocatable :: r real ( kind = RP ), dimension (:,:), allocatable :: re real ( kind = RP ), dimension (:,:,:), allocatable :: reUnitVect real ( kind = RP ), dimension (:,:), allocatable :: reStar real ( kind = RP ), dimension (:,:,:), allocatable :: reStarUnitVect real ( kind = RP ) :: tDelay integer :: faceIDinMesh ! ID of the source (face) at the Mesh array (linked list) integer :: elementSide real ( kind = RP ) :: normalCorrection real ( kind = RP ), dimension (:,:), allocatable :: Pacc ! temporal solution of acoustic pressure for each pair real ( kind = RP ), dimension (:), allocatable :: tInterp ! time array for interpolation contains procedure :: construct => ObserverSourcePairConstruct procedure :: destruct => ObserverSourcePairDestruct procedure :: allocPacc => ObserverSourcePairAllocSolution procedure :: interpolateSolF => ObserverSourcePairInterpolateSolFirst procedure :: newUpdate => ObserverSourcePairNewUpdate procedure :: interpolateSolS => ObserverSourcePairInterpolateSolSecond procedure :: updateOneStep => ObserverSourcePairUpdateOneStep procedure :: FWHSurfaceIntegral end type ObserverSourcePairClass","tags":"","url":"type/observersourcepairclass.html"},{"title":"ObserverClass – HORSES3D ","text":"type, public :: ObserverClass Components Type Visibility Attributes Name Initial integer, public :: ID real(kind=RP), public, dimension(NDIM) :: x integer, public :: numberOfFaces class( ObserverSourcePairClass ), public, dimension(:), allocatable :: sourcePair real(kind=RP), public, dimension(:,:), allocatable :: Pac real(kind=RP), public :: tDelay real(kind=RP), public :: tDelayMax logical, public :: active character(len=STR_LEN_OBSERVER), public :: observerName character(len=STR_LEN_OBSERVER), public :: fileName Type-Bound Procedures procedure, public :: construct => ObserverConstruct public  subroutine ObserverConstruct (self, sourceZone, mesh, ID, solution_file, FirstCall, interpolate, totalNumberOfFaces, elementSide) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(Zone_t), intent(in) :: sourceZone class(HexMesh), intent(in) :: mesh integer, intent(in) :: ID character(len=*), intent(in) :: solution_file logical, intent(in) :: FirstCall logical, intent(in) :: interpolate integer, intent(in) :: totalNumberOfFaces integer, intent(in), dimension(:) :: elementSide procedure, public :: destruct => ObserverDestruct public  subroutine ObserverDestruct (self) Arguments Type Intent Optional Attributes Name class( ObserverClass ), intent(inout) :: self procedure, public :: update => ObserverUpdate public  subroutine ObserverUpdate (self, mesh, isSolid, bufferPosition, interpolate) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(HexMesh), intent(in) :: mesh logical, intent(in) :: isSolid integer, intent(in), optional :: bufferPosition logical, intent(in) :: interpolate procedure, public :: writeToFile => ObserverWriteToFile public  subroutine ObserverWriteToFile (self, iter, tsource, no_of_lines) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, dimension(:) :: iter real(kind=RP), dimension(:) :: tsource integer :: no_of_lines procedure, public :: updateTdelay => ObserverUpdateTdelay public  subroutine ObserverUpdateTdelay (self, totalNumberOfFaces) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, intent(in) :: totalNumberOfFaces procedure, public :: interpolateSol => ObserverInterpolateSol public  subroutine ObserverInterpolateSol (self, tsource, no_of_lines) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self real(kind=RP), intent(in), dimension(:) :: tsource integer, intent(in) :: no_of_lines procedure, public :: sumIntegrals => ObserverSumIntegrals public  subroutine ObserverSumIntegrals (self, nDiscard, N, startIndex, no_of_lines) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, intent(in), dimension(self % numberOfFaces) :: nDiscard integer, intent(in) :: N integer, intent(in) :: startIndex integer, intent(in) :: no_of_lines procedure, public :: updateOneStep => ObserverUpdateOneStep public  subroutine ObserverUpdateOneStep (self, mesh, bufferPosition, isSolid, tsource) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(HexMesh), intent(in) :: mesh integer, intent(in) :: bufferPosition logical, intent(in) :: isSolid real(kind=RP), intent(in) :: tsource Source Code type ObserverClass integer :: ID real ( kind = RP ), dimension ( NDIM ) :: x ! position of the observer at global coordinates integer :: numberOfFaces class ( ObserverSourcePairClass ), dimension (:), allocatable :: sourcePair real ( kind = RP ), dimension (:,:), allocatable :: Pac ! acoustic pressure, two components and the total (sum) real ( kind = RP ) :: tDelay real ( kind = RP ) :: tDelayMax logical :: active character ( len = STR_LEN_OBSERVER ) :: observerName character ( len = STR_LEN_OBSERVER ) :: fileName contains procedure :: construct => ObserverConstruct procedure :: destruct => ObserverDestruct procedure :: update => ObserverUpdate procedure :: writeToFile => ObserverWriteToFile procedure :: updateTdelay => ObserverUpdateTdelay procedure :: interpolateSol => ObserverInterpolateSol procedure :: sumIntegrals => ObserverSumIntegrals procedure :: updateOneStep => ObserverUpdateOneStep end type ObserverClass","tags":"","url":"type/observerclass.html"},{"title":"Probe_t – HORSES3D ","text":"type, public :: Probe_t Components Type Visibility Attributes Name Initial logical, public :: active integer, public :: rank integer, public :: ID integer, public :: eID real(kind=RP), public :: x (NDIM) real(kind=RP), public :: xi (NDIM) real(kind=RP), public, allocatable :: values (:) real(kind=RP), public, allocatable :: lxi (:) real(kind=RP), public, allocatable :: leta (:) real(kind=RP), public, allocatable :: lzeta (:) character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => Probe_Initialization private  subroutine Probe_Initialization(self, mesh, ID, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( Probe_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => Probe_Update private  subroutine Probe_Update(self, mesh, bufferPosition) Arguments Type Intent Optional Attributes Name class( Probe_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition procedure, public :: WriteLabel => Probe_WriteLabel private  subroutine Probe_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( Probe_t ) :: self procedure, public :: WriteValues => Probe_WriteValue private  subroutine Probe_WriteValue(self, bufferLine) Arguments Type Intent Optional Attributes Name class( Probe_t ) :: self integer :: bufferLine procedure, public :: WriteToFile => Probe_WriteToFile private  subroutine Probe_WriteToFile(self, iter, t, no_of_lines) Arguments Type Intent Optional Attributes Name class( Probe_t ) :: self integer :: iter (:) real(kind=RP) :: t (:) integer :: no_of_lines procedure, public :: LookInOtherPartitions => Probe_LookInOtherPartitions private  subroutine Probe_LookInOtherPartitions(self) Arguments Type Intent Optional Attributes Name class( Probe_t ) :: self procedure, public :: destruct => Probe_Destruct private elemental subroutine Probe_Destruct(self) Arguments Type Intent Optional Attributes Name class( Probe_t ), intent(inout) :: self procedure, public :: copy => Probe_Assign private elemental subroutine Probe_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Probe_t ), intent(inout) :: to type( Probe_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine Probe_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Probe_t ), intent(inout) :: to type( Probe_t ), intent(in) :: from Source Code type Probe_t logical :: active integer :: rank integer :: ID integer :: eID real ( kind = RP ) :: x ( NDIM ) real ( kind = RP ) :: xi ( NDIM ) real ( kind = RP ), allocatable :: values (:) real ( kind = RP ), allocatable :: lxi (:) , leta (:), lzeta (:) character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => Probe_Initialization procedure :: Update => Probe_Update procedure :: WriteLabel => Probe_WriteLabel procedure :: WriteValues => Probe_WriteValue procedure :: WriteToFile => Probe_WriteToFile procedure :: LookInOtherPartitions => Probe_LookInOtherPartitions procedure :: destruct => Probe_Destruct procedure :: copy => Probe_Assign generic :: assignment ( = ) => copy end type Probe_t","tags":"","url":"type/probe_t.html"},{"title":"SurfaceSampling_t – HORSES3D ","text":"type, public :: SurfaceSampling_t Components Type Visibility Attributes Name Initial logical, public :: active = .false. logical, public :: isDimensionless integer, public :: ID integer, public :: nVariables integer, public :: marker integer, public :: rank integer, public :: interval integer, public :: bufferSize integer, public :: bufferLine integer, public :: intervalCount integer, public, allocatable :: nData (:) real(kind=RP), public, allocatable :: values (:,:,:) character(len=STR_LEN_MONITORS), public :: SamplingName character(len=STR_LEN_MONITORS), public, allocatable :: fileName (:) character(len=STR_LEN_MONITORS), public, allocatable :: variable (:) Type-Bound Procedures procedure, public :: Initialization => SurfaceSampling_Initialization private  subroutine SurfaceSampling_Initialization(self, mesh, ID, solution_file, FirstCall) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( SurfaceSampling_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => SurfaceSampling_Update private  subroutine SurfaceSampling_Update(self, mesh, bufferPosition, t) Arguments Type Intent Optional Attributes Name class( SurfaceSampling_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition real(kind=RP) :: t procedure, public :: WriteToFile => SurfaceSampling_WriteToFile private  subroutine SurfaceSampling_WriteToFile(self, no_of_lines) Arguments Type Intent Optional Attributes Name class( SurfaceSampling_t ) :: self integer :: no_of_lines procedure, public :: destruct => SurfaceSampling_Destruct private elemental subroutine SurfaceSampling_Destruct(self) Arguments Type Intent Optional Attributes Name class( SurfaceSampling_t ), intent(inout) :: self procedure, public :: copy => SurfaceSampling_Assign private elemental subroutine SurfaceSampling_Assign(to, from) Arguments Type Intent Optional Attributes Name class( SurfaceSampling_t ), intent(inout) :: to type( SurfaceSampling_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine SurfaceSampling_Assign(to, from) Arguments Type Intent Optional Attributes Name class( SurfaceSampling_t ), intent(inout) :: to type( SurfaceSampling_t ), intent(in) :: from Source Code type SurfaceSampling_t logical :: active = . false . logical :: isDimensionless integer :: ID integer :: nVariables integer :: marker integer :: rank integer :: interval integer :: bufferSize integer :: bufferLine integer :: intervalCount integer , allocatable :: nData (:) real ( kind = RP ), allocatable :: values (:,:,:) character ( len = STR_LEN_MONITORS ) :: SamplingName character ( len = STR_LEN_MONITORS ), allocatable :: fileName (:) character ( len = STR_LEN_MONITORS ), allocatable :: variable (:) contains procedure :: Initialization => SurfaceSampling_Initialization procedure :: Update => SurfaceSampling_Update procedure :: WriteToFile => SurfaceSampling_WriteToFile procedure :: destruct => SurfaceSampling_Destruct procedure :: copy => SurfaceSampling_Assign generic :: assignment ( = ) => copy end type SurfaceSampling_t","tags":"","url":"type/surfacesampling_t.html"},{"title":"SurfaceMonitor_t – HORSES3D ","text":"type, public :: SurfaceMonitor_t Components Type Visibility Attributes Name Initial logical, public :: active logical, public :: isDimensionless logical, public :: IBM = .false. integer, public :: ID real(kind=RP), public :: direction (NDIM) integer, public :: marker real(kind=RP), public, allocatable :: referenceSurface real(kind=RP), public, allocatable :: values (:) real(kind=RP), public :: dynamicPressure character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => SurfaceMonitor_Initialization private  subroutine SurfaceMonitor_Initialization(self, mesh, ID, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => SurfaceMonitor_Update private  subroutine SurfaceMonitor_Update(self, mesh, bufferPosition, iter, autosave, dt) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition integer :: iter logical :: autosave real(kind=RP) :: dt procedure, public :: WriteLabel => SurfaceMonitor_WriteLabel private  subroutine SurfaceMonitor_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ), intent(in) :: self procedure, public :: WriteValues => SurfaceMonitor_WriteValue private  subroutine SurfaceMonitor_WriteValue(self, bufferLine) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ) :: self integer :: bufferLine procedure, public :: WriteToFile => SurfaceMonitor_WriteToFile private  subroutine SurfaceMonitor_WriteToFile(self, iter, t, no_of_lines) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ) :: self integer :: iter (:) real(kind=RP) :: t (:) integer :: no_of_lines procedure, public :: destruct => SurfaceMonitor_Destruct private elemental subroutine SurfaceMonitor_Destruct(self) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ), intent(inout) :: self procedure, public :: copy => SurfaceMonitor_Assign private elemental subroutine SurfaceMonitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ), intent(inout) :: to type( SurfaceMonitor_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine SurfaceMonitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( SurfaceMonitor_t ), intent(inout) :: to type( SurfaceMonitor_t ), intent(in) :: from Source Code type SurfaceMonitor_t logical :: active logical :: isDimensionless , IBM = . false . integer :: ID real ( kind = RP ) :: direction ( NDIM ) integer :: marker real ( kind = RP ), allocatable :: referenceSurface real ( kind = RP ), allocatable :: values (:) real ( kind = RP ) :: dynamicPressure character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => SurfaceMonitor_Initialization procedure :: Update => SurfaceMonitor_Update procedure :: WriteLabel => SurfaceMonitor_WriteLabel procedure :: WriteValues => SurfaceMonitor_WriteValue procedure :: WriteToFile => SurfaceMonitor_WriteToFile procedure :: destruct => SurfaceMonitor_Destruct procedure :: copy => SurfaceMonitor_Assign generic :: assignment ( = ) => copy end type SurfaceMonitor_t","tags":"","url":"type/surfacemonitor_t.html"},{"title":"StatisticsMonitor_t – HORSES3D ","text":"type, public :: StatisticsMonitor_t Components Type Visibility Attributes Name Initial integer, public :: state integer, public :: sampling_interval integer, public :: dump_interval integer, public :: reset_interval integer, public :: starting_iteration real(kind=RP), public :: starting_time integer, public :: no_of_samples logical, public :: saveGradients Type-Bound Procedures procedure, public :: Construct => StatisticsMonitor_Construct private  subroutine StatisticsMonitor_Construct(self, mesh, saveGradients) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self class(HexMesh) :: mesh logical, intent(in) :: saveGradients procedure, public :: Update => StatisticsMonitor_Update private  subroutine StatisticsMonitor_Update(self, mesh, iter, t, solution_file) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self class(HexMesh) :: mesh integer, intent(in) :: iter real(kind=RP), intent(in) :: t character(len=*), intent(in) :: solution_file procedure, public :: UpdateValues => StatisticsMonitor_UpdateValues private  subroutine StatisticsMonitor_UpdateValues(self, mesh) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self class(HexMesh) :: mesh procedure, public :: GetState => StatisticsMonitor_GetState private  subroutine StatisticsMonitor_GetState(self, reset, dump) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self logical, intent(out) :: reset logical, intent(out) :: dump procedure, public :: WriteLabel => StatisticsMonitor_WriteLabel private  subroutine StatisticsMonitor_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self procedure, public :: WriteValue => StatisticsMonitor_WriteValue private  subroutine StatisticsMonitor_WriteValue(self) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self procedure, public :: WriteFile => StatisticsMonitor_WriteFile private  subroutine StatisticsMonitor_WriteFile(self, mesh, iter, t, solution_file) Arguments Type Intent Optional Attributes Name class( StatisticsMonitor_t ) :: self class(HexMesh) :: mesh integer, intent(in) :: iter real(kind=RP), intent(in) :: t character(len=*), intent(in) :: solution_file Source Code type StatisticsMonitor_t integer :: state integer :: sampling_interval integer :: dump_interval integer :: reset_interval integer :: starting_iteration real ( kind = RP ) :: starting_time integer :: no_of_samples logical :: saveGradients contains procedure :: Construct => StatisticsMonitor_Construct procedure :: Update => StatisticsMonitor_Update procedure :: UpdateValues => StatisticsMonitor_UpdateValues procedure :: GetState => StatisticsMonitor_GetState procedure :: WriteLabel => StatisticsMonitor_WriteLabel procedure :: WriteValue => StatisticsMonitor_WriteValue procedure :: WriteFile => StatisticsMonitor_WriteFile end type StatisticsMonitor_t","tags":"","url":"type/statisticsmonitor_t.html"},{"title":"FWHClass – HORSES3D ","text":"type, public :: FWHClass Components Type Visibility Attributes Name Initial character(len=LINE_LENGTH), public :: solution_file integer, public :: numberOfObservers = 0 integer, public :: bufferLine integer, public, dimension(:), allocatable :: iter real(kind=RP), public, dimension(:), allocatable :: t class( ObserverClass ), public, dimension(:), allocatable :: observers integer, public :: totalNumberOfFaces logical, public :: isSolid logical, public :: isActive = .false. logical, public :: firstWrite logical, public :: interpolate Type-Bound Procedures procedure, public :: construct => FWHConstruct public  subroutine FWHConstruct (self, mesh, controlVariables) Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self class(HexMesh), intent(in) :: mesh class(FTValueDictionary), intent(in) :: controlVariables procedure, public :: destruct => FWHDestruct public  subroutine FWHDestruct (self) Arguments Type Intent Optional Attributes Name class( FWHClass ), intent(inout) :: self procedure, public :: updateValues => FWHUpate public  subroutine FWHUpate (self, mesh, t, iter, isFromFile) Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self class(HexMesh) :: mesh real(kind=RP), intent(in) :: t integer, intent(in) :: iter logical, intent(in), optional :: isFromFile procedure, public :: writeToFile => FWHWriteToFile public  subroutine FWHWriteToFile (self, force) Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self logical, optional :: force Source Code type FWHClass character ( len = LINE_LENGTH ) :: solution_file integer :: numberOfObservers = 0 integer :: bufferLine integer , dimension (:), allocatable :: iter real ( kind = RP ), dimension (:), allocatable :: t class ( ObserverClass ), dimension (:), allocatable :: observers integer :: totalNumberOfFaces logical :: isSolid logical :: isActive = . false . logical :: firstWrite logical :: interpolate contains procedure :: construct => FWHConstruct procedure :: destruct => FWHDestruct procedure :: updateValues => FWHUpate procedure :: writeToFile => FWHWriteToFile end type FWHClass","tags":"","url":"type/fwhclass.html"},{"title":"LoadBalancingMonitor_t – HORSES3D ","text":"type, public :: LoadBalancingMonitor_t Components Type Visibility Attributes Name Initial logical, public :: active integer, public :: ID integer, public :: bufferLine integer, public :: num_of_vars real(kind=RP), public, allocatable :: values (:,:) character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => LoadBalancingMonitor_Initialization private  subroutine LoadBalancingMonitor_Initialization(self, mesh, ID, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => LoadBalancingMonitor_Update private  subroutine LoadBalancingMonitor_Update(self, mesh, bufferPosition) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition procedure, public :: WriteLabel => LoadBalancingMonitor_WriteLabel private  subroutine LoadBalancingMonitor_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ) :: self procedure, public :: WriteValues => LoadBalancingMonitor_WriteValue private  subroutine LoadBalancingMonitor_WriteValue(self, bufferLine) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ) :: self integer :: bufferLine procedure, public :: WriteToFile => LoadBalancingMonitor_WriteToFile private  subroutine LoadBalancingMonitor_WriteToFile(self, iter, t, no_of_lines) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ) :: self integer :: iter (:) real(kind=RP) :: t (:) integer :: no_of_lines procedure, public :: getLast => LoadBalancingMonitor_GetLast private  function LoadBalancingMonitor_GetLast(self) result(lastValues) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ), intent(in) :: self Return Value real(kind=RP), (size(self%values,1)) procedure, public :: destruct => LoadBalancingMonitor_Destruct private elemental subroutine LoadBalancingMonitor_Destruct(self) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ), intent(inout) :: self procedure, public :: copy => LoadBalancingMonitor_Assign private elemental subroutine LoadBalancingMonitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ), intent(inout) :: to type( LoadBalancingMonitor_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine LoadBalancingMonitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( LoadBalancingMonitor_t ), intent(inout) :: to type( LoadBalancingMonitor_t ), intent(in) :: from Source Code type LoadBalancingMonitor_t logical :: active integer :: ID integer :: bufferLine integer :: num_of_vars real ( kind = RP ), allocatable :: values (:,:) character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => LoadBalancingMonitor_Initialization procedure :: Update => LoadBalancingMonitor_Update procedure :: WriteLabel => LoadBalancingMonitor_WriteLabel procedure :: WriteValues => LoadBalancingMonitor_WriteValue procedure :: WriteToFile => LoadBalancingMonitor_WriteToFile procedure :: getLast => LoadBalancingMonitor_GetLast procedure :: destruct => LoadBalancingMonitor_Destruct procedure :: copy => LoadBalancingMonitor_Assign generic :: assignment ( = ) => copy end type LoadBalancingMonitor_t","tags":"","url":"type/loadbalancingmonitor_t.html"},{"title":"VolumeMonitor_t – HORSES3D ","text":"type, public :: VolumeMonitor_t Components Type Visibility Attributes Name Initial logical, public :: active integer, public :: ID integer, public :: bufferLine integer, public :: num_of_vars real(kind=RP), public, allocatable :: values (:,:) character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => VolumeMonitor_Initialization private  subroutine VolumeMonitor_Initialization(self, mesh, ID, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => VolumeMonitor_Update private  subroutine VolumeMonitor_Update(self, mesh, bufferPosition) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition procedure, public :: WriteLabel => VolumeMonitor_WriteLabel private  subroutine VolumeMonitor_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ) :: self procedure, public :: WriteValues => VolumeMonitor_WriteValue private  subroutine VolumeMonitor_WriteValue(self, bufferLine) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ) :: self integer :: bufferLine procedure, public :: WriteToFile => VolumeMonitor_WriteToFile private  subroutine VolumeMonitor_WriteToFile(self, iter, t, no_of_lines) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ) :: self integer :: iter (:) real(kind=RP) :: t (:) integer :: no_of_lines procedure, public :: getLast => VolumeMonitor_GetLast private  function VolumeMonitor_GetLast(self) result(lastValues) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ), intent(in) :: self Return Value real(kind=RP), (size(self%values,1)) procedure, public :: destruct => VolumeMonitor_Destruct private elemental subroutine VolumeMonitor_Destruct(self) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ), intent(inout) :: self procedure, public :: copy => VolumeMonitor_Assign private elemental subroutine VolumeMonitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ), intent(inout) :: to type( VolumeMonitor_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine VolumeMonitor_Assign(to, from) Arguments Type Intent Optional Attributes Name class( VolumeMonitor_t ), intent(inout) :: to type( VolumeMonitor_t ), intent(in) :: from Source Code type VolumeMonitor_t logical :: active integer :: ID integer :: bufferLine integer :: num_of_vars real ( kind = RP ), allocatable :: values (:,:) character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => VolumeMonitor_Initialization procedure :: Update => VolumeMonitor_Update procedure :: WriteLabel => VolumeMonitor_WriteLabel procedure :: WriteValues => VolumeMonitor_WriteValue procedure :: WriteToFile => VolumeMonitor_WriteToFile procedure :: getLast => VolumeMonitor_GetLast procedure :: destruct => VolumeMonitor_Destruct procedure :: copy => VolumeMonitor_Assign generic :: assignment ( = ) => copy end type VolumeMonitor_t","tags":"","url":"type/volumemonitor_t.html"},{"title":"PlaneSampling_t – HORSES3D ","text":"type, public :: PlaneSampling_t Components Type Visibility Attributes Name Initial logical, public, allocatable :: active (:) integer, public, allocatable :: rank (:) integer, public :: ID integer, public :: nVariables integer, public :: interval integer, public :: bufferSize integer, public :: bufferLine integer, public :: intervalCount integer, public :: N (2) integer, public :: nNodes integer, public, allocatable :: eID (:) real(kind=RP), public, allocatable :: lxi (:,:) real(kind=RP), public, allocatable :: leta (:,:) real(kind=RP), public, allocatable :: lzeta (:,:) real(kind=RP), public, allocatable :: values (:,:,:) real(kind=RP), public, allocatable :: x (:,:) real(kind=RP), public, allocatable :: xi (:,:) logical, public :: disturbanceData = .false. character(len=STR_LEN_MONITORS), public, allocatable :: fileName (:) character(len=STR_LEN_MONITORS), public :: planeName character(len=STR_LEN_MONITORS), public :: fileInput character(len=STR_LEN_MONITORS), public, allocatable :: variable (:) Type-Bound Procedures procedure, public :: Initialization => Plane_Initialization private  subroutine Plane_Initialization(self, mesh, ID, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ) :: self class(HexMesh) :: mesh integer :: ID character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => Plane_Update private  subroutine Plane_Update(self, mesh, bufferPosition, t) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ) :: self class(HexMesh) :: mesh integer :: bufferPosition real(kind=RP) :: t procedure, public :: UpdateInterp => Plane_UpdateLagrangeInterp private  subroutine Plane_UpdateLagrangeInterp(self, mesh) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ) :: self class(HexMesh) :: mesh procedure, public :: WriteToFile => Plane_WriteToFile private  subroutine Plane_WriteToFile(self, no_of_lines) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ) :: self integer :: no_of_lines procedure, public :: LookInOtherPartitions => Plane_LookInOtherPartitions private  subroutine Plane_LookInOtherPartitions(self, i) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ) :: self integer, intent(in) :: i procedure, public :: destruct => Plane_Destruct private elemental subroutine Plane_Destruct(self) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ), intent(inout) :: self procedure, public :: copy => Plane_Assign private elemental subroutine Plane_Assign(to, from) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ), intent(inout) :: to type( PlaneSampling_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine Plane_Assign(to, from) Arguments Type Intent Optional Attributes Name class( PlaneSampling_t ), intent(inout) :: to type( PlaneSampling_t ), intent(in) :: from Source Code type PlaneSampling_t logical , allocatable :: active (:) integer , allocatable :: rank (:) integer :: ID integer :: nVariables integer :: interval integer :: bufferSize integer :: bufferLine integer :: intervalCount integer :: N ( 2 ) integer :: nNodes integer , allocatable :: eID (:) real ( kind = RP ), allocatable :: lxi (:,:) , leta (:,:), lzeta (:,:) real ( kind = RP ), allocatable :: values (:,:,:) real ( kind = RP ), allocatable :: x (:,:) real ( kind = RP ), allocatable :: xi (:,:) logical :: disturbanceData = . false . character ( len = STR_LEN_MONITORS ), allocatable :: fileName (:) character ( len = STR_LEN_MONITORS ) :: planeName character ( len = STR_LEN_MONITORS ) :: fileInput character ( len = STR_LEN_MONITORS ), allocatable :: variable (:) contains procedure :: Initialization => Plane_Initialization procedure :: Update => Plane_Update procedure :: UpdateInterp => Plane_UpdateLagrangeInterp procedure :: WriteToFile => Plane_WriteToFile procedure :: LookInOtherPartitions => Plane_LookInOtherPartitions procedure :: destruct => Plane_Destruct procedure :: copy => Plane_Assign generic :: assignment ( = ) => copy end type PlaneSampling_t","tags":"","url":"type/planesampling_t.html"},{"title":"Residuals_t – HORSES3D ","text":"type, public :: Residuals_t Components Type Visibility Attributes Name Initial logical, public :: active real(kind=RP), public, allocatable :: values (:,:) real(kind=RP), public, allocatable :: CPUtime (:) character(len=STR_LEN_MONITORS), public :: fileName Type-Bound Procedures procedure, public :: Initialization => Residuals_Initialization private  subroutine Residuals_Initialization(self, solution_file, FirstCall) Arguments Type Intent Optional Attributes Name class( Residuals_t ) :: self character(len=*) :: solution_file logical, intent(in) :: FirstCall procedure, public :: Update => Residuals_Update private  subroutine Residuals_Update(self, mesh, maxResiduals, bufferPosition) Arguments Type Intent Optional Attributes Name class( Residuals_t ) :: self class(HexMesh), intent(in) :: mesh real(kind=RP) :: maxResiduals (NCONS) integer :: bufferPosition procedure, public :: WriteLabel => Residuals_WriteLabel private  subroutine Residuals_WriteLabel(self) Arguments Type Intent Optional Attributes Name class( Residuals_t ) :: self procedure, public :: WriteValues => Residuals_WriteValue private  subroutine Residuals_WriteValue(self, bufferLine) Arguments Type Intent Optional Attributes Name class( Residuals_t ) :: self integer :: bufferLine procedure, public :: WriteToFile => Residuals_WriteToFile private  subroutine Residuals_WriteToFile(self, iter, t, TotalSimuTime, SolverSimuTime, no_of_lines) Arguments Type Intent Optional Attributes Name class( Residuals_t ) :: self integer :: iter (:) real(kind=RP) :: t (:) real(kind=RP) :: TotalSimuTime (:) real(kind=RP) :: SolverSimuTime (:) integer :: no_of_lines procedure, public :: destruct => Residuals_Destruct private pure subroutine Residuals_Destruct(self) Arguments Type Intent Optional Attributes Name class( Residuals_t ), intent(inout) :: self procedure, public :: copy => Residuals_Assign private elemental subroutine Residuals_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Residuals_t ), intent(inout) :: to type( Residuals_t ), intent(in) :: from generic, public :: assignment(=) => copy private elemental subroutine Residuals_Assign(to, from) Arguments Type Intent Optional Attributes Name class( Residuals_t ), intent(inout) :: to type( Residuals_t ), intent(in) :: from Source Code type Residuals_t logical :: active real ( kind = RP ), allocatable :: values (:,:) real ( kind = RP ), allocatable :: CPUtime (:) character ( len = STR_LEN_MONITORS ) :: fileName contains procedure :: Initialization => Residuals_Initialization procedure :: Update => Residuals_Update procedure :: WriteLabel => Residuals_WriteLabel procedure :: WriteValues => Residuals_WriteValue procedure :: WriteToFile => Residuals_WriteToFile procedure :: destruct => Residuals_Destruct procedure :: copy => Residuals_Assign generic :: assignment ( = ) => copy end type Residuals_t","tags":"","url":"type/residuals_t.html"},{"title":"VectorSurfaceSampling – HORSES3D","text":"public  subroutine VectorSurfaceSampling(mesh, zoneID, integralType, monitorName, data_out) Uses MonitorDefinitions mpi Arguments Type Intent Optional Attributes Name class(HexMesh), intent(inout), target :: mesh integer, intent(in) :: zoneID integer, intent(in) :: integralType character(len=STR_LEN_MONITORS) :: monitorName real(kind=RP), intent(out), allocatable :: data_out (:) Source Code subroutine VectorSurfaceSampling ( mesh , zoneID , integralType , monitorName , data_out ) use MonitorDefinitions #ifdef _HAS_MPI_ use mpi #endif implicit none class ( HexMesh ), intent ( inout ), target :: mesh integer , intent ( in ) :: zoneID integer , intent ( in ) :: integralType real ( kind = RP ), allocatable , intent ( out ) :: data_out (:) ! !        --------------- !        Local variables !        --------------- ! integer :: zonefID , fID , eID , fIDs ( 6 ), ierr , Nx , Ny , fsID class ( Element ), pointer :: elements (:) real ( kind = RP ) , allocatable :: data_proc (:) logical :: file_exists character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: monitorName ! !        Get the number of Order and the sampling interval !        ------------------------------------------------- if ( mesh % zones ( zoneID ) % no_of_faces . gt . 0 ) then Nx = mesh % faces ( mesh % zones ( zoneID ) % faces ( 1 ))% Nf ( 1 ) + 1 Ny = mesh % faces ( mesh % zones ( zoneID ) % faces ( 1 ))% Nf ( 2 ) + 1 else Nx = 0 Ny = 0 end if ALLOCATE ( data_out ( Nx * Ny * mesh % zones ( zoneID ) % no_of_faces ), data_proc ( Nx * Ny )) ! !        ************************* !        Perform the interpolation !        ************************* ! #if defined(NAVIERSTOKES) && (!(INCNS)) elements => mesh % elements !$omp parallel private(fID, eID, fIDs,data_proc) shared(elements,mesh,NodalStorage,zoneID,integralType,& !$omp&                                        computeGradients,data_out,Nx) !$omp single do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces fID = mesh % zones ( zoneID ) % faces ( zonefID ) eID = mesh % faces ( fID ) % elementIDs ( 1 ) fIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) if ( computeGradients ) then call elements ( eID ) % ProlongGradientsToFaces ( NGRAD , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) end if !$omp end task end do !$omp end single ! !        Loop the zone to get faces and elements !        --------------------------------------- !$omp do  private(fID,data_proc) schedule(runtime) do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( zoneID ) % faces ( zonefID ) ! !           Compute the integral !           -------------------- CALL VectorSurfaceSampling_Face ( mesh % faces ( fID ), integralType , fID , data_proc ) data_out (( zonefID - 1 ) * Nx * Ny + 1 : zonefID * Nx * Ny ) = data_proc end do !$omp end do !$omp end parallel #endif end subroutine VectorSurfaceSampling","tags":"","url":"proc/vectorsurfacesampling.html"},{"title":"FWHSurfaceIntegral – HORSES3D","text":"public  function FWHSurfaceIntegral(self, f, isSolid) result(Pacc) Uses VariableConversion FWHDefinitions fluiddata Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self class(Face), intent(in) :: f logical, intent(in) :: isSolid Return Value real(kind=RP), dimension(3) Source Code Function FWHSurfaceIntegral ( self , f , isSolid ) result ( Pacc ) use FWHDefinitions , only : rho0 , P0 , c0 , U0 , M0 use VariableConversion , only : Pressure , PressureDot use fluiddata , only : dimensionless implicit none class ( ObserverSourcePairClass ) :: self class ( Face ), intent ( in ) :: f logical , intent ( in ) :: isSolid real ( kind = RP ), dimension ( 3 ) :: Pacc ! acoustic pressure values ! logical, intent(in)                                 :: isSolid, interpolate ! integer, intent(in), optional                       :: bufferPosition ! local variables integer :: i , j ! face indexes real ( kind = RP ), dimension ( NDIM ) :: Qi , QiDot , n real ( kind = RP ), dimension ( NDIM , NDIM ) :: Lij , LijDot type ( NodalStorage_t ), pointer :: spAxi , spAeta real ( kind = RP ) :: Pt , Pl real ( kind = RP ) :: LR , MR , UmMr , LdotR , LM ! integer                                             :: storePosition ! Initialization Pt = 0.0_RP Pl = 0.0_RP spAxi => NodalStorage ( f % Nf ( 1 )) spAeta => NodalStorage ( f % Nf ( 2 )) associate ( Q => f % storage ( self % elementSide ) % Q ) associate ( Qdot => f % storage ( self % elementSide ) % Qdot ) !           ********************************** !           Computes the surface integral !              I = \\int vec{f}·vec{n} * vec{g}·vec{r} dS !           ********************************** ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) n = f % geom % normal (:, i , j ) * self % normalCorrection call calculateFWHVariables ( Q (:, i , j ), Qdot (:, i , j ), isSolid , Qi , QiDot , Lij , LijDot ) LR = dot_product ( matmul ( Lij , n (:)), self % reUnitVect (:, i , j )) MR = dot_product ( M0 (:), self % reUnitVect (:, i , j )) UmMr = 1 - MR LdotR = dot_product ( matmul ( LijDot , n (:)), self % reUnitVect (:, i , j )) LM = dot_product ( matmul ( Lij , n (:)), M0 (:)) ! loading term integrals Pl = Pl + dot_product ( matmul ( LijDot , n (:)), self % reUnitVect (:, i , j )) / ( self % reStar ( i , j ) * c0 ) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) Pl = Pl + dot_product ( matmul ( Lij , n (:)), self % reStarUnitVect (:, i , j )) / ( self % reStar ( i , j ) ** 2 ) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) ! Pl = Pl + LdotR / ( c0 * self % re(i,j) * (UmMr**2) ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! Pl = Pl + (LR - LM) / ( (self % re(i,j) * UmMr)**2 ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! Pl = Pl + (LR * (MR - (dimensionless % Mach**2))) / ( (self % re(i,j)**2) * (UmMr**3) ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! thickness term integrals, only for permeable surfaces if (. not . isSolid ) then Pt = Pt + ( 1 - dot_product ( M0 (:), self % reUnitVect (:, i , j ))) * dot_product ( QiDot (:), n (:)) / ( self % reStar ( i , j )) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) Pt = Pt - dot_product ( U0 (:), self % reStarUnitVect (:, i , j )) * dot_product ( Qi (:), n (:)) / ( self % reStar ( i , j ) ** 2 ) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) ! Pt = Pt + dot_product(QiDot(:),n(:)) / (self%reStar(i,j) * (UmMr**2)) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! Pt = Pt + (dot_product(Qi(:), n(:)) * c0 * (MR - (dimensionless % Mach**2))) / ( (self % re(i,j)**2) * (UmMr**3) ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) end if end do ; end do end associate end associate Pt = Pt / ( 4.0_RP * PI ) Pl = Pl / ( 4.0_RP * PI ) ! get total acoustic pressure as the sum of the two components (the quadrapol terms are being ignored) Pacc = ( / Pt , Pl , Pt + Pl / ) End Function FWHSurfaceIntegral","tags":"","url":"proc/fwhsurfaceintegral.html"},{"title":"linearInterpolation – HORSES3D","text":"public  function linearInterpolation(x, x1, y1, x2, y2, N) result(y) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: x real(kind=RP), intent(in) :: x1 real(kind=RP), intent(in), dimension(N) :: y1 real(kind=RP), intent(in) :: x2 real(kind=RP), intent(in), dimension(N) :: y2 integer, intent(in) :: N Return Value real(kind=RP), dimension(N) Source Code Function linearInterpolation ( x , x1 , y1 , x2 , y2 , N ) result ( y ) integer , intent ( in ) :: N real ( kind = RP ), intent ( in ) :: x1 , x2 , x real ( kind = RP ), dimension ( N ), intent ( in ) :: y1 , y2 real ( kind = RP ), dimension ( N ) :: y y = y1 + ( y2 - y1 ) / ( x2 - x1 ) * ( x - x1 ) End Function linearInterpolation","tags":"","url":"proc/linearinterpolation.html"},{"title":"ObserverConstruct – HORSES3D","text":"public  subroutine ObserverConstruct(self, sourceZone, mesh, ID, solution_file, FirstCall, interpolate, totalNumberOfFaces, elementSide) Uses FileReadingUtilities ParamfileRegions Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(Zone_t), intent(in) :: sourceZone class(HexMesh), intent(in) :: mesh integer, intent(in) :: ID character(len=*), intent(in) :: solution_file logical, intent(in) :: FirstCall logical, intent(in) :: interpolate integer, intent(in) :: totalNumberOfFaces integer, intent(in), dimension(:) :: elementSide Source Code Subroutine ObserverConstruct ( self , sourceZone , mesh , ID , solution_file , FirstCall , interpolate , totalNumberOfFaces , elementSide ) !        ***************************************************************************** !              This subroutine initializes the observer similar to a monitor. The following !           data is obtained from the case file: !              -> Name: The observer name (10 characters maximum) !              -> x: The observer position !        ***************************************************************************** use ParamfileRegions use FileReadingUtilities , only : getRealArrayFromString implicit none class ( ObserverClass ) :: self class ( Zone_t ), intent ( in ) :: sourceZone class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: ID , totalNumberOfFaces character ( len =* ), intent ( in ) :: solution_file logical , intent ( in ) :: FirstCall , interpolate integer , dimension (:), intent ( in ) :: elementSide ! local variables character ( len = STR_LEN_OBSERVER ) :: in_label character ( len = STR_LEN_OBSERVER ) :: fileName character ( len = STR_LEN_OBSERVER ) :: paramFile character ( len = STR_LEN_OBSERVER ) :: coordinates integer :: fID integer :: MeshFaceID , zoneFaceID ! integer                          :: elementSide ! !      Get observer ID !      -------------- self % ID = ID ! !      Search for the parameters in the case file !      ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define acoustic observer \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ), \"name\" , self % observerName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ), \"position\" , coordinates , in_label , \"# end\" ) !      Get the coordinates !      ------------------- self % x = getRealArrayFromString ( coordinates ) !     Enable the observer !     ------------------ self % active = . true . allocate ( self % Pac ( OB_BUFFER_SIZE , 3 ) ) !     Get source information !     ------------------ self % numberOfFaces = sourceZone % no_of_faces !     Construct each pair observer-source !     ------------------ allocate ( self % sourcePair ( self % numberOfFaces ) ) !     Loop the zone to get faces do zoneFaceID = 1 , self % numberOfFaces !         Face global ID MeshFaceID = sourceZone % faces ( zoneFaceID ) call self % sourcePair ( zoneFaceID ) % construct ( self % x , mesh % faces ( MeshFaceID ), MeshFaceID , FirstCall , elementSide ( zoneFaceID )) end do !     Allocate variables for interpolation !     ------------------------------------------------- if ( interpolate ) then do zoneFaceID = 1 , self % numberOfFaces call self % sourcePair ( zoneFaceID ) % allocPacc ( OB_BUFFER_SIZE ) end do end if !     Set the average time delay of the observer !     ------------------------------------------------- call self % updateTdelay ( totalNumberOfFaces ) !     Prepare the file in which the observer is exported !     ------------------------------------------------- write ( self % fileName , '(A,A,A,A)' ) trim ( solution_file ) , \".\" , trim ( self % observerName ) , \".observer\" ! !     Create file !     ----------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) !        Write the file headers !        ---------------------- write ( fID , '(A20,A  )' ) \"Observer name:      \" , trim ( self % observerName ) write ( fID , '(A20,ES24.10)' ) \"x coordinate: \" , self % x ( 1 ) write ( fID , '(A20,ES24.10)' ) \"y coordinate: \" , self % x ( 2 ) write ( fID , '(A20,ES24.10)' ) \"z coordinate: \" , self % x ( 3 ) write ( fID , * ) write ( fID , '(A10,5(2X,A24))' ) \"Iteration\" , \"Time\" , \"Observer_Time\" , \"P'T\" , \"P'L\" , \"P'\" close ( fID ) end if End Subroutine ObserverConstruct","tags":"","url":"proc/observerconstruct.html"},{"title":"ObserverUpdate – HORSES3D","text":"public  subroutine ObserverUpdate(self, mesh, isSolid, bufferPosition, interpolate) Uses VariableConversion Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(HexMesh), intent(in) :: mesh logical, intent(in) :: isSolid integer, intent(in), optional :: bufferPosition logical, intent(in) :: interpolate Source Code Subroutine ObserverUpdate ( self , mesh , isSolid , BufferPosition , interpolate ) !     ******************************************************************* !        This subroutine updates the observer acoustic pressure computing it from !        the mesh storage. It is stored in the \"bufferPosition\" position of the !        buffer. !     ******************************************************************* ! use VariableConversion , only : Pressure , PressureDot implicit none class ( ObserverClass ) :: self class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ), optional :: bufferPosition logical , intent ( in ) :: isSolid , interpolate ! local variables real ( kind = RP ) :: Pt , Pl ! pressure of each pair real ( kind = RP ), dimension ( 3 ) :: localPacc , Pacc ! temporal variable to store the sum of the pressure real ( kind = RP ), dimension ( 3 ) :: mInterp ! slope of interpolation real ( kind = RP ) :: valx , valy , valz integer :: zoneFaceID , meshFaceID , ierr integer :: storePosition !     Initialization !     -------------- if ( present ( bufferPosition )) self % Pac ( bufferPosition ,:) = 0.0_RP Pacc = 0.0_RP valx = 0.0_RP valy = 0.0_RP valz = 0.0_RP !     Loop the pairs (equivalent to loop the zone) and get the values !     --------------------------------------- interp_cond : if ( interpolate ) then !        For this case only save the values of the solution of each pair, at the corresponding position !        --------------------------------------- !$omp parallel private(meshFaceID,storePosition,localPacc) shared(mesh,isSolid,interpolate,Pacc,NodalStorage,& !$omp&                                                     self,bufferPosition) !$omp do private(meshFaceID,storePosition,localPacc) schedule(runtime) do zoneFaceID = 1 , self % numberOfFaces !            Compute the integral !            -------------------- meshFaceID = self % sourcePair ( zoneFaceID ) % faceIDinMesh localPacc = self % sourcePair ( zoneFaceID ) % FWHSurfaceIntegral ( mesh % faces ( meshFaceID ), isSolid ) !save solution at bufferPosition or last position if ( present ( bufferPosition )) then storePosition = bufferPosition else storePosition = size ( self % sourcePair ( zoneFaceID ) % Pacc , dim = 1 ) end if self % sourcePair ( zoneFaceID ) % Pacc ( storePosition ,:) = localPacc end do !$omp end do !$omp end parallel else interp_cond !        For this case get the whole solution of the observer, adding all the pairs without saving !        --------------------------------------- !$omp parallel private(meshFaceID, localPacc) shared(mesh,isSolid,interpolate,Pacc,NodalStorage,& !$omp&                                        self,valx,valy,valz) !$omp do private(meshFaceID,localPacc) reduction(+:valx,valy,valz) schedule(runtime) do zoneFaceID = 1 , self % numberOfFaces !            Compute the integral !            -------------------- meshFaceID = self % sourcePair ( zoneFaceID ) % faceIDinMesh localPacc = self % sourcePair ( zoneFaceID ) % FWHSurfaceIntegral ( mesh % faces ( meshFaceID ), isSolid ) ! sum without interpolate: suppose little change of each tDelay valx = valx + localPacc ( 1 ) valy = valy + localPacc ( 2 ) valz = valz + localPacc ( 3 ) end do !$omp end do !$omp end parallel Pacc = ( / valx , valy , valz / ) #ifdef _HAS_MPI_ localPacc = Pacc call mpi_allreduce ( localPacc , Pacc , 3 , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif self % Pac ( bufferPosition ,:) = Pacc end if interp_cond End Subroutine ObserverUpdate","tags":"","url":"proc/observerupdate.html"},{"title":"ObserverUpdateTdelay – HORSES3D","text":"public  subroutine ObserverUpdateTdelay(self, totalNumberOfFaces) Uses MPI_Process_Info Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, intent(in) :: totalNumberOfFaces Source Code Subroutine ObserverUpdateTdelay ( self , totalNumberOfFaces ) !     ******************************************************************* !        This subroutine updates the observer time delay. For static surfaces it !        doesn't need to be updated at every iteration. !        Minimum time is used, for interpolation procedures !     ******************************************************************* ! use MPI_Process_Info implicit none class ( ObserverClass ) :: self integer , intent ( in ) :: totalNumberOfFaces ! local variables integer :: i , ierr real ( kind = RP ) :: t , tmax real ( kind = RP ), dimension (:), allocatable :: alltDelay real ( kind = RP ), dimension ( self % numberOfFaces ) :: tDelayArray integer , dimension ( MPI_Process % nProcs ) :: no_of_faces_p , displs do i = 1 , self % numberOfFaces tDelayArray ( i ) = self % sourcePair ( i ) % tDelay end do if ( ( MPI_Process % doMPIAction ) ) then #ifdef _HAS_MPI_ call mpi_gather ( self % numberOfFaces , 1 , MPI_INT , no_of_faces_p , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierr ) if ( MPI_Process % isRoot ) then displs = 0 do i = 2 , MPI_Process % nProcs displs ( i ) = displs ( i - 1 ) + no_of_faces_p ( i - 1 ) end do end if allocate ( alltDelay ( totalNumberOfFaces )) call mpi_gatherv ( tDelayArray , self % numberOfFaces , MPI_DOUBLE , & alltDelay , no_of_faces_p , displs , MPI_DOUBLE , 0 , MPI_COMM_WORLD , ierr ) if ( MPI_Process % isRoot ) then t = minval ( alltDelay ) tmax = maxval ( alltDelay ) end if call mpi_Bcast ( t , 1 , MPI_DOUBLE , 0 , MPI_COMM_WORLD , ierr ) call mpi_Bcast ( tmax , 1 , MPI_DOUBLE , 0 , MPI_COMM_WORLD , ierr ) #endif else t = minval ( tDelayArray ) tmax = maxval ( tDelayArray ) end if self % tDelay = t self % tDelayMax = tmax End Subroutine ObserverUpdateTdelay","tags":"","url":"proc/observerupdatetdelay.html"},{"title":"ObserverWriteToFile – HORSES3D","text":"public  subroutine ObserverWriteToFile(self, iter, tsource, no_of_lines) Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, dimension(:) :: iter real(kind=RP), dimension(:) :: tsource integer :: no_of_lines Source Code Subroutine ObserverWriteToFile ( self , iter , tsource , no_of_lines ) ! !     ************************************************************* !           This subroutine writes the buffer to the file. !     ************************************************************* ! implicit none class ( ObserverClass ) :: self integer , dimension (:) :: iter real ( kind = RP ), dimension (:) :: tsource integer :: no_of_lines ! !     --------------- !     Local variables !     --------------- ! integer :: i integer :: fID if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) do i = 1 , no_of_lines write ( fID , '(I10,5(2X,ES24.16))' ) iter ( i ) , tsource ( i ), tsource ( i ) + self % tDelay , self % Pac ( i ,:) end do close ( fID ) end if if ( no_of_lines . ne . 0 ) self % Pac ( 1 ,:) = self % Pac ( no_of_lines ,:) End Subroutine ObserverWriteToFile","tags":"","url":"proc/observerwritetofile.html"},{"title":"ObserverUpdateOneStep – HORSES3D","text":"public  subroutine ObserverUpdateOneStep(self, mesh, bufferPosition, isSolid, tsource) Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(HexMesh), intent(in) :: mesh integer, intent(in) :: bufferPosition logical, intent(in) :: isSolid real(kind=RP), intent(in) :: tsource Source Code Subroutine ObserverUpdateOneStep ( self , mesh , BufferPosition , isSolid , tsource ) implicit none class ( ObserverClass ) :: self class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: bufferPosition logical , intent ( in ) :: isSolid real ( kind = RP ), intent ( in ) :: tsource ! local variables real ( kind = RP ) :: tobserver integer :: i integer , dimension ( self % numberOfFaces ) :: nDiscard ! store the solution of each pair at the last position, by not giving the bufferPosition call self % update ( mesh , isSolid , interpolate = . TRUE .) ! interpolate the solution of each pair at first position ! and save the time of each pair at its last position tobserver = tsource + self % tDelay !$omp parallel shared(self) !$omp do schedule(runtime) do i = 1 , self % numberOfFaces if ( self % sourcePair ( i ) % tDelay . eq . self % tDelay ) cycle call self % sourcePair ( i ) % interpolateSolS ( tobserver , tsource ) end do !$omp end do !$omp end parallel ! sum all the pair solution and save it at bufferPosition of the observer sol nDiscard = 0 call self % sumIntegrals ( nDiscard , 1 , bufferPosition , bufferPosition ) ! update the solution of each pair and its times for next iteration !$omp parallel shared(self) !$omp do schedule(runtime) do i = 1 , self % numberOfFaces call self % sourcePair ( i ) % updateOneStep () end do !$omp end do !$omp end parallel End Subroutine ObserverUpdateOneStep","tags":"","url":"proc/observerupdateonestep.html"},{"title":"ObserverInterpolateSol – HORSES3D","text":"public  subroutine ObserverInterpolateSol(self, tsource, no_of_lines) Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self real(kind=RP), intent(in), dimension(:) :: tsource integer, intent(in) :: no_of_lines Source Code Subroutine ObserverInterpolateSol ( self , tsource , no_of_lines ) implicit none class ( ObserverClass ) :: self real ( kind = RP ), dimension (:), intent ( in ) :: tsource integer , intent ( in ) :: no_of_lines !local variables real ( kind = RP ), dimension (:), allocatable :: tobserver integer :: i , n , k , m integer , dimension ( self % numberOfFaces ) :: nDiscard logical :: sameDelay allocate ( tobserver ( no_of_lines )) tobserver = tsource ( 1 : no_of_lines ) + self % tdelay ! get max tobserver that can be interpolated do k = 1 , no_of_lines if ( tobserver ( k ) . ge . ( self % tDelayMax + tsource ( 1 )) ) exit end do n = no_of_lines - k + 1 ! k is the min tobserver index safedeallocate ( tobserver ) allocate ( tobserver ( n )) tobserver ( 1 : n ) = tsource ( k : no_of_lines ) + self % tdelay !$omp parallel shared(self, nDiscard, n, no_of_lines, tobserver, tsource,k) !$omp do schedule(runtime) do i = 1 , self % numberOfFaces ! call interp of each pair that are not the minimum ! if (almostequal(self % sourcepair(i) % tdelay, self % tdelay)) then if ( self % sourcepair ( i ) % tdelay . eq . self % tdelay ) then nDiscard ( i ) = k - 1 else call self % sourcePair ( i ) % interpolateSolF ( n , no_of_lines , tobserver , tsource ( 1 : no_of_lines ), nDiscard ( i )) end if end do !$omp end do !$omp end parallel ! set to 0 the first part of the solution, which cannot be interpolated ! in this case Pacc is written from 1:no_of_lines, which have a value of 0 at first positions, not need to change obs write proc self % pac ( 1 : k - 1 ,:) = 0.0_RP ! sum all values from k to no_of_lines call self % sumIntegrals ( nDiscard , n , k , no_of_lines ) ! update all the solution of the pair to save the future ones do i = 1 , self % numberOfFaces ! sameDelay = almostequal(self % sourcepair(i) % tdelay, self % tdelay) sameDelay = self % sourcepair ( i ) % tdelay . eq . self % tdelay call self % sourcePair ( i ) % newUpdate ( n , nDiscard ( i ), no_of_lines , tsource ( 1 : no_of_lines ), sameDelay ) end do End Subroutine ObserverInterpolateSol","tags":"","url":"proc/observerinterpolatesol.html"},{"title":"ObserverSumIntegrals – HORSES3D","text":"public  subroutine ObserverSumIntegrals(self, nDiscard, N, startIndex, no_of_lines) Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, intent(in), dimension(self % numberOfFaces) :: nDiscard integer, intent(in) :: N integer, intent(in) :: startIndex integer, intent(in) :: no_of_lines Source Code Subroutine ObserverSumIntegrals ( self , nDiscard , N , startIndex , no_of_lines ) implicit none class ( observerclass ) :: self integer , intent ( in ) :: no_of_lines , startIndex , N integer , dimension ( self % numberOfFaces ), intent ( in ) :: nDiscard ! local variables real ( kind = RP ), dimension (:,:), allocatable :: localPacc , Pacc ! temporal variable to store the sum of the pressure real ( kind = RP ), dimension (:), allocatable :: valx , valy , valz integer :: i , ierr !     Initialization !     -------------- ! 1:N must be equal to startIndex:no_of_lines allocate ( Pacc ( N , 3 ), localPacc ( N , 3 ), valx ( N ), valy ( N ), valz ( N )) Pacc = 0.0_RP valx = 0.0_RP valy = 0.0_RP valz = 0.0_RP !$omp parallel private(localPacc) shared(Pacc,nDiscard,N,self,valx,valy,valz) !$omp do private(localPacc) reduction(+:valx,valy,valz) schedule(runtime) do i = 1 , self % numberOfFaces !        Get the array of interpolated values of each pair localPacc ( 1 : N ,:) = self % sourcePair ( i ) % Pacc ( nDiscard ( i ) + 1 : nDiscard ( i ) + N ,:) ! sum interpolated valx = valx + localPacc (:, 1 ) valy = valy + localPacc (:, 2 ) valz = valz + localPacc (:, 3 ) end do !$omp end do !$omp end parallel Pacc (:, 1 ) = valx (:) Pacc (:, 2 ) = valy (:) Pacc (:, 3 ) = valz (:) #ifdef _HAS_MPI_ localPacc = Pacc call mpi_allreduce ( localPacc , Pacc , 3 * N , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif self % Pac ( startIndex : no_of_lines ,:) = Pacc ( 1 : N ,:) End Subroutine ObserverSumIntegrals","tags":"","url":"proc/observersumintegrals.html"},{"title":"ObserverDestruct – HORSES3D","text":"public  subroutine ObserverDestruct(self) Type Bound ObserverClass Arguments Type Intent Optional Attributes Name class( ObserverClass ), intent(inout) :: self Source Code Subroutine ObserverDestruct ( self ) implicit none class ( ObserverClass ), intent ( inout ) :: self ! local variables integer :: i safedeallocate ( self % Pac ) do i = 1 , self % numberOfFaces call self % sourcePair ( i ) % destruct end do safedeallocate ( self % sourcePair ) End Subroutine ObserverDestruct","tags":"","url":"proc/observerdestruct.html"},{"title":"ObserverSourcePairConstruct – HORSES3D","text":"public  subroutine ObserverSourcePairConstruct(self, x, f, fID, FirstCall, elementSide) Uses FWHDefinitions Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self real(kind=RP), intent(in), dimension(NDIM) :: x type(face), intent(in) :: f integer, intent(in) :: fID logical, intent(in) :: FirstCall integer, intent(in) :: elementSide Source Code Subroutine ObserverSourcePairConstruct ( self , x , f , fID , FirstCall , elementSide ) ! use fluiddata use FWHDefinitions , only : rho0 , P0 , c0 , U0 , M0 , fwGamma2 implicit none class ( ObserverSourcePairClass ) :: self real ( kind = RP ), dimension ( NDIM ), intent ( in ) :: x ! observer position type ( face ), intent ( in ) :: f ! source integer , intent ( in ) :: fID , elementSide logical , intent ( in ) :: FirstCall ! local variables integer :: Nx , Ny integer :: i , j real ( kind = RP ) :: fwGammaInv self % faceIDinMesh = fID Nx = f % Nf ( 1 ) Ny = f % Nf ( 2 ) self % elementSide = elementSide select case ( elementSide ) case ( 1 ) self % normalCorrection = 1.0_RP case ( 2 ) self % normalCorrection = - 1.0_RP end select allocate ( self % r ( 0 : Nx , 0 : Ny ), self % re ( 0 : Nx , 0 : Ny ), self % reStar ( 0 : Nx , 0 : Ny ) ) allocate ( self % rVect ( NDIM , 0 : Nx , 0 : Ny ), self % reUnitVect ( NDIM , 0 : Nx , 0 : Ny ) , self % reStarUnitVect ( NDIM , 0 : Nx , 0 : Ny ) ) fwGammaInv = 1.0_RP / sqrt ( fwGamma2 ) ! source position, for each node of the face associate ( y => f % geom % x ) do j = 0 , Ny ; do i = 0 , Nx ! store geometrical acoustic relations for each node self % rVect (:, i , j ) = x (:) - y (:, i , j ) self % r ( i , j ) = norm2 ( self % rVect (:, i , j )) self % reStar ( i , j ) = fwGammaInv * sqrt ( self % r ( i , j ) ** 2 + fwGamma2 * ( dot_product ( M0 , self % rVect (:, i , j )) ) ** 2 ) self % reStarUnitVect (:, i , j ) = ( self % rVect (:, i , j ) + fwGamma2 * dot_product ( M0 , self % rVect (:, i , j )) * M0 (:) ) / & ( fwGamma2 * self % reStar ( i , j )) self % re ( i , j ) = fwGamma2 * ( self % reStar ( i , j ) - dot_product ( M0 , self % rVect (:, i , j )) ) self % reUnitVect (:, i , j ) = fwGamma2 * ( self % reStarUnitVect (:, i , j ) - M0 (:) ) self % tDelay = ( sum ( self % re )) / real ( size ( self % re ), RP ) / c0 end do ; end do end associate End Subroutine ObserverSourcePairConstruct","tags":"","url":"proc/observersourcepairconstruct.html"},{"title":"ObserverSourcePairDestruct – HORSES3D","text":"public elemental subroutine ObserverSourcePairDestruct(self) Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ), intent(inout) :: self Source Code elemental Subroutine ObserverSourcePairDestruct ( self ) Class ( ObserverSourcePairClass ), intent ( inout ) :: self safedeallocate ( self % rVect ) safedeallocate ( self % r ) safedeallocate ( self % re ) safedeallocate ( self % reUnitVect ) safedeallocate ( self % reStar ) safedeallocate ( self % reStarUnitVect ) End Subroutine ObserverSourcePairDestruct","tags":"","url":"proc/observersourcepairdestruct.html"},{"title":"ObserverSourcePairAllocSolution – HORSES3D","text":"public  subroutine ObserverSourcePairAllocSolution(self, buffer_size) Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: buffer_size Source Code Subroutine ObserverSourcePairAllocSolution ( self , buffer_size ) class ( ObserverSourcePairClass ) :: self integer , intent ( in ) :: buffer_size allocate ( self % Pacc ( buffer_size , 3 )) End Subroutine ObserverSourcePairAllocSolution","tags":"","url":"proc/observersourcepairallocsolution.html"},{"title":"ObserverSourcePairInterpolateSolFirst – HORSES3D","text":"public  subroutine ObserverSourcePairInterpolateSolFirst(self, N, M, tobserver, tsource, nd) Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: N integer, intent(in) :: M real(kind=RP), intent(in), dimension(N) :: tobserver real(kind=RP), intent(in), dimension(:) :: tsource integer, intent(out) :: nd Source Code Subroutine ObserverSourcePairInterpolateSolFirst ( self , N , M , tobserver , tsource , nd ) implicit none class ( ObserverSourcePairClass ) :: self integer , intent ( in ) :: N , M real ( kind = RP ), dimension ( N ), intent ( in ) :: tobserver real ( kind = RP ), dimension (:), intent ( in ) :: tsource integer , intent ( out ) :: nd ! local variables real ( kind = RP ), dimension ( N , 3 ) :: PaccInterp ! solution of the pair interpolated real ( kind = RP ), dimension ( M ) :: tPair ! time array of the panel integer :: i , j , ii ! get the times of the pair for interpolation tPair = tsource + self % tDelay j = 1 nd = 0 do i = 2 , M if ( j . gt . N ) exit ii = i - 1 if ( tPair ( i ) . lt . tobserver ( 1 )) then nd = nd + 1 cycle end if PaccInterp ( j ,:) = linearInterpolation ( tobserver ( j ), tPair ( ii ), self % Pacc ( ii ,:), tPair ( i ), self % Pacc ( i ,:), 3 ) j = j + 1 end do !update solution of the pair with the interpolated one self % Pacc ( nd + 1 : nd + N ,:) = PaccInterp End Subroutine ObserverSourcePairInterpolateSolFirst","tags":"","url":"proc/observersourcepairinterpolatesolfirst.html"},{"title":"ObserverSourcePairNewUpdate – HORSES3D","text":"public  subroutine ObserverSourcePairNewUpdate(self, N, NDiscard, M, tsource, sameDelay) Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: N integer, intent(in) :: NDiscard integer, intent(in) :: M real(kind=RP), intent(in), dimension(:) :: tsource logical, intent(in) :: sameDelay Source Code Subroutine ObserverSourcePairNewUpdate ( self , N , NDiscard , M , tsource , sameDelay ) implicit none class ( ObserverSourcePairClass ) :: self integer , intent ( in ) :: N , NDiscard , M ! real(kind=RP), dimension(N), intent(in)             :: tobserver real ( kind = RP ), dimension (:), intent ( in ) :: tsource logical , intent ( in ) :: sameDelay !local variables real ( kind = RP ), dimension ( M ) :: tPair ! time array of the panel real ( kind = RP ), dimension (:,:), allocatable :: PaccFuture ! solution of the pair of future (have not been interpolainterpolated) values integer :: Nfuture tPair = tsource + self % tDelay if ( sameDelay ) then !size = 1 for last value + 1(empty for next iter) Nfuture = 2 else !size = M - interpolated values +1 + 1(empty for next iter) Nfuture = M - N - NDiscard + 1 end if ! save old results and kept last position empty allocate ( PaccFuture ( Nfuture - 1 , 3 )) PaccFuture (:,:) = self % Pacc ( M - Nfuture + 2 : M ,:) safedeallocate ( self % Pacc ) allocate ( self % Pacc ( 1 : Nfuture , 3 )) self % Pacc ( 1 : Nfuture - 1 ,:) = PaccFuture (:,:) if (. not . sameDelay ) then allocate ( self % tInterp ( 1 : Nfuture )) ! save old results and kept last position empty self % tInterp ( 1 : Nfuture - 1 ) = tPair ( NDiscard + N + 1 : M ) end if End Subroutine ObserverSourcePairNewUpdate","tags":"","url":"proc/observersourcepairnewupdate.html"},{"title":"ObserverSourcePairUpdateOneStep – HORSES3D","text":"public  subroutine ObserverSourcePairUpdateOneStep(self) Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self Source Code Subroutine ObserverSourcePairUpdateOneStep ( self ) implicit none class ( ObserverSourcePairClass ) :: self !local variables integer :: M M = size ( self % Pacc , dim = 1 ) if ( allocated ( self % tInterp )) self % tInterp ( 1 : M - 1 ) = self % tInterp ( 2 : M ) self % Pacc ( 1 : M - 1 ,:) = self % Pacc ( 2 : M ,:) End Subroutine ObserverSourcePairUpdateOneStep","tags":"","url":"proc/observersourcepairupdateonestep.html"},{"title":"ObserverSourcePairInterpolateSolSecond – HORSES3D","text":"public  subroutine ObserverSourcePairInterpolateSolSecond(self, tobserver, tsource) Type Bound ObserverSourcePairClass Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self real(kind=RP), intent(in) :: tobserver real(kind=RP), intent(in) :: tsource Source Code Subroutine ObserverSourcePairInterpolateSolSecond ( self , tobserver , tsource ) implicit none class ( ObserverSourcePairClass ) :: self real ( kind = RP ), intent ( in ) :: tobserver real ( kind = RP ), intent ( in ) :: tsource ! local variables real ( kind = RP ), dimension ( 2 ) :: tPair ! time array of the panel real ( kind = RP ), dimension ( 3 ) :: PaccInterp ! solution of the pair interpolated ! save last time self % tInterp ( size ( self % tInterp )) = tsource + self % tDelay ! use 2 first values to interpolate tPair = self % tInterp ( 1 : 2 ) PaccInterp (:) = linearInterpolation ( tobserver , tPair ( 1 ), self % Pacc ( 1 ,:), tPair ( 2 ), self % Pacc ( 2 ,:), 3 ) !update the first value of the solution of the pair with the interpolated one self % Pacc ( 1 ,:) = PaccInterp (:) End Subroutine ObserverSourcePairInterpolateSolSecond","tags":"","url":"proc/observersourcepairinterpolatesolsecond.html"},{"title":"SourceProlongSolution – HORSES3D","text":"public  subroutine SourceProlongSolution(source_zone, mesh, eSides) Uses ElementClass $omp&                                        t) Arguments Type Intent Optional Attributes Name class(Zone_t), intent(in) :: source_zone class(HexMesh), intent(inout), target :: mesh integer, intent(in), dimension(:) :: eSides Source Code Subroutine SourceProlongSolution ( source_zone , mesh , eSides ) !     ******************************************************************* !        This subroutine prolong the solution from the mesh storage to the faces (source). !         TODO: use openmp (commented) !         TODO: use mpi (see surface integral) !     ******************************************************************* ! use ElementClass implicit none class ( Zone_t ), intent ( in ) :: source_zone class ( HexMesh ), intent ( inout ), target :: mesh integer , dimension (:), intent ( in ) :: eSides ! local variables integer :: zoneFaceID , meshFaceID , eID integer , dimension ( 6 ) :: meshFaceIDs class ( Element ), pointer :: elements (:) !     ************************* !     Perform the interpolation !     ************************* ! elements => mesh % elements !$omp parallel private(meshFaceID,eID,meshFaceIDs) shared(elements,mesh,NodalStorage) !!$omp&                                        t) !$omp single !        Loop the zone to get faces and elements !        --------------------------------------- do zoneFaceID = 1 , source_zone % no_of_faces meshFaceID = source_zone % faces ( zoneFaceID ) eID = mesh % faces ( meshFaceID ) % elementIDs ( eSides ( zoneFaceID )) meshFaceIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS ,& mesh % faces ( meshFaceIDs ( 1 )),& mesh % faces ( meshFaceIDs ( 2 )),& mesh % faces ( meshFaceIDs ( 3 )),& mesh % faces ( meshFaceIDs ( 4 )),& mesh % faces ( meshFaceIDs ( 5 )),& mesh % faces ( meshFaceIDs ( 6 )),& computeQdot = . TRUE .) ! if ( computeGradients ) then !    call elements(eID) % ProlongGradientsToFaces(NGRAD, mesh % faces(meshFaceIDs(1)),& !                                     mesh % faces(meshFaceIDs(2)),& !                                     mesh % faces(meshFaceIDs(3)),& !                                     mesh % faces(meshFaceIDs(4)),& !                                     mesh % faces(meshFaceIDs(5)),& !                                     mesh % faces(meshFaceIDs(6)) ) ! end if !$omp end task end do !$omp end single !$omp end parallel End Subroutine SourceProlongSolution","tags":"","url":"proc/sourceprolongsolution.html"},{"title":"calculateFWHVariables – HORSES3D","text":"public  subroutine calculateFWHVariables(Q, Qdot, isSolid, Qi, Qidot, Lij, LijDot) Uses Utilities VariableConversion FWHDefinitions Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), dimension(NCONS) :: Q real(kind=RP), intent(in), dimension(NCONS) :: Qdot logical, intent(in) :: isSolid real(kind=RP), intent(out), dimension(NDIM) :: Qi real(kind=RP), intent(out), dimension(NDIM) :: Qidot real(kind=RP), intent(out), dimension(NDIM,NDIM) :: Lij real(kind=RP), intent(out), dimension(NDIM,NDIM) :: LijDot Source Code Subroutine calculateFWHVariables ( Q , Qdot , isSolid , Qi , QiDot , Lij , LijDot ) use VariableConversion , only : Pressure , PressureDot use FWHDefinitions , only : rho0 , P0 , c0 , U0 , M0 use Utilities , only : AlmostEqual implicit none real ( kind = RP ), dimension ( NCONS ), intent ( in ) :: Q ! horses variables array real ( kind = RP ), dimension ( NCONS ), intent ( in ) :: Qdot ! horses time derivatives array logical , intent ( in ) :: isSolid real ( kind = RP ), dimension ( NDIM ), intent ( out ) :: Qi ! fwh Qi array, related with the acoustic pressure thickness real ( kind = RP ), dimension ( NDIM ), intent ( out ) :: Qidot real ( kind = RP ), dimension ( NDIM , NDIM ), intent ( out ) :: Lij ! fwh Lij tensor: related with the acoustic pressure loading real ( kind = RP ), dimension ( NDIM , NDIM ), intent ( out ) :: LijDot !local variables real ( kind = RP ) :: P , pDot real ( kind = RP ), dimension ( NDIM , NDIM ) :: Pij ! fwh perturbation stress tensor ! real(kind=RP), dimension(NDIM:NDIM)                 :: tau integer :: i , j , ii , jj P = Pressure ( Q ) pDot = PressureDot ( Q , Qdot ) Pij = 0.0_RP LijDot = 0.0_RP do i = 1 , NDIM Pij ( i , i ) = P - P0 !pressure derivative of LijDot LijDot ( i , i ) = pDot end do !TODO use the stress tensor and the time derivative for Lij and LijDot respectively ! call getStressTensor(Q, U_x, U_y, U_z, tau) ! Pij = Pij - tau ! LijDot = LijDot - tauDot ! set values for solid (impermeable) surface Qi (:) = - rho0 * U0 (:) Qidot = 0.0_RP Lij = Pij ! Lij = 0.0_RP !calculate terms for permeable surface if (. not . isSolid ) then Qi (:) = Qi (:) + Q ( 2 : 4 ) ! convert to complete velocity instead of perturbation velocity QiDot (:) = QiDot (:) + Qdot ( 2 : 4 ) do j = 1 , NDIM jj = j + 1 do i = 1 , NDIM ! one index is added since rhoV1 = Q(2), rhoV2 = Q(3) ... ii = i + 1 Lij ( i , j ) = Lij ( i , j ) + ( Q ( ii ) - Q ( 1 ) * U0 ( i )) * ( Q ( jj ) / Q ( 1 )) LijDot ( i , j ) = LijDot ( i , j ) + ( Qdot ( ii ) - Q ( ii ) / Q ( 1 ) * Qdot ( 1 ) ) / Q ( 1 ) * Q ( jj ) + & ( Q ( ii ) / Q ( 1 ) - U0 ( i )) * Qdot ( jj ) end do end do end if End Subroutine calculateFWHVariables","tags":"","url":"proc/calculatefwhvariables.html"},{"title":"getNoOfObservers – HORSES3D","text":"public  function getNoOfObservers() result(no_of_observers) Uses ParamfileRegions Arguments None Return Value integer Source Code Function getNoOfObservers () result ( no_of_observers ) use ParamfileRegions implicit none integer :: no_of_observers ! !     --------------- !     Local variables !     --------------- ! character ( len = LINE_LENGTH ) :: case_name , line integer :: fID integer :: io ! !     Initialize !     ---------- no_of_observers = 0 ! !     Get case file name !     ------------------ call get_command_argument ( 1 , case_name ) ! !     Open case file !     -------------- open ( newunit = fID , file = case_name , status = \"old\" , action = \"read\" ) ! !     Read the whole file to find the observers !     ------------------------------------ readloop : do read ( fID , '(A)' , iostat = io ) line if ( io . lt . 0 ) then ! !           End of file !           ----------- line = \"\" exit readloop elseif ( io . gt . 0 ) then ! !           Error !           ----- errorMessage ( STD_OUT ) error stop \"Stopped.\" else ! !           Succeeded !           --------- line = getSquashedLine ( line ) if ( index ( line , '#defineacousticobserver' ) . gt . 0 ) then no_of_observers = no_of_observers + 1 end if end if end do readloop ! !     Close case file !     --------------- close ( fID ) End Function getNoOfObservers","tags":"","url":"proc/getnoofobservers.html"},{"title":"FWHConstruct – HORSES3D","text":"public  subroutine FWHConstruct(self, mesh, controlVariables) Uses Headers Utilities FTValueDictionaryClass mpi mainKeywordsModule FileReadingUtilities FWHDefinitions Type Bound FWHClass Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self class(HexMesh), intent(in) :: mesh class(FTValueDictionary), intent(in) :: controlVariables Source Code Subroutine FWHConstruct ( self , mesh , controlVariables ) use FTValueDictionaryClass use mainKeywordsModule use FileReadingUtilities , only : getCharArrayFromString use FWHDefinitions , only : getMeanStreamValues use Headers use Utilities , only : toLower #ifdef _HAS_MPI_ use mpi #endif implicit none class ( FWHClass ) :: self class ( HexMesh ), intent ( in ) :: mesh class ( FTValueDictionary ), intent ( in ) :: controlVariables !       --------------- !       Local variables !       --------------- ! integer :: fID , io integer :: i character ( len = STR_LEN_OBSERVER ) :: line character ( len = STR_LEN_OBSERVER ) :: solution_file integer :: no_of_zones , no_of_face_i , ierr , no_of_faces logical , save :: FirstCall = . TRUE . !        look if the acoustic analogy calculations are set to be computed !        -------------------------------- !TODO read acoustic analogy type and return if is not defined, check for FWH if is defined and not FWH stop and send error if (. not . controlVariables % containsKey ( \"acoustic analogy\" )) then self % isActive = . FALSE . ! print *, \"FWH not activated\" return end if !       check the that sourceZone is FWH !       ---------------------------------- if ( surfacesMesh % surfaceTypes ( FWH_POSITION ) . ne . SURFACE_TYPE_FWH ) then self % isActive = . FALSE . print * , \"FWH surface not found, the FWH routines will not deactivated\" return end if !       Setup the buffer !       ---------------- if ( controlVariables % containsKey ( \"observers flush interval\" ) ) then OB_BUFFER_SIZE = controlVariables % integerValueForKey ( \"observers flush interval\" ) end if self % isActive = . TRUE . allocate ( self % t ( OB_BUFFER_SIZE ), self % iter ( OB_BUFFER_SIZE ) ) !       Get the general configuration of control file !       First get the surface as a zone !       ------------------------------- self % isSolid = . not . controlVariables % logicalValueForKey ( \"acoustic analogy permeable\" ) !       Get the solution file name !       -------------------------- solution_file = controlVariables % stringValueForKey ( solutionFileNameKey , requestedLength = STR_LEN_OBSERVER ) ! !       Remove the *.hsol termination !       ----------------------------- solution_file = trim ( getFileName ( solution_file )) self % solution_file = trim ( solution_file ) !       Search in case file for observers !       --------------------------------------------------------------------- if ( mesh % child ) then ! Return doing nothing if this is a child mesh self % numberOfObservers = 0 else self % numberOfObservers = getNoOfObservers () end if !       Set interpolate attribute as TRUE by default ! todo: read from constrol variables self % interpolate = . TRUE . ! self % interpolate = .FALSE. !       Initialize observers !       -------------------- call getMeanStreamValues () no_of_faces = surfacesMesh % totalFaces ( SURFACE_TYPE_FWH ) allocate ( self % observers ( self % numberOfObservers ) ) do i = 1 , self % numberOfObservers call self % observers ( i ) % construct ( surfacesMesh % zones ( SURFACE_TYPE_FWH ) , mesh , i , self % solution_file , FirstCall , & self % interpolate , no_of_faces , surfacesMesh % elementSide (:, 1 )) end do self % bufferLine = 0 self % firstWrite = . FALSE . FirstCall = . FALSE . !        Describe the zones !        ------------------ if ( . not . MPI_Process % isRoot ) return call Subsection_Header ( \"Fictitious FWH zone\" ) write ( STD_OUT , '(30X,A,A28,I0)' ) \"->\" , \"Number of faces: \" , no_of_faces write ( STD_OUT , '(30X,A,A28,I0)' ) \"->\" , \"Number of observers: \" , self % numberOfObservers write ( STD_OUT , '(30X,A,A28,I0)' ) \"->\" , \"Number of integrals: \" , self % numberOfObservers * no_of_faces write ( STD_OUT , '(30X,A,A28,L1)' ) \"->\" , \"Save zone solution: \" , controlVariables % containsKey ( \"acoustic save timestep\" ) End Subroutine FWHConstruct","tags":"","url":"proc/fwhconstruct.html"},{"title":"FWHUpate – HORSES3D","text":"public  subroutine FWHUpate(self, mesh, t, iter, isFromFile) Type Bound FWHClass Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self class(HexMesh) :: mesh real(kind=RP), intent(in) :: t integer, intent(in) :: iter logical, intent(in), optional :: isFromFile Source Code Subroutine FWHUpate ( self , mesh , t , iter , isFromFile ) implicit none class ( FWHClass ) :: self class ( HexMesh ) :: mesh real ( kind = RP ), intent ( in ) :: t integer , intent ( in ) :: iter logical , intent ( in ), optional :: isFromFile !       --------------- !       Local variables !       --------------- ! integer :: i logical :: prolong !       Check if is activated !       ------------------------ if (. not . self % isActive ) return !       Check if prolong is necessary !       ------------------------ if ( present ( isFromFile )) then prolong = . not . isFromFile else prolong = . TRUE . end if ! !       Move to next buffer line !       ------------------------ self % bufferLine = self % bufferLine + 1 ! !       Save time and iteration !       ----------------------- self % t ( self % bufferLine ) = t self % iter ( self % bufferLine ) = iter ! !       Save Solution to elements faces of fwh surface !       ----------------------- if ( prolong ) call SourceProlongSolution ( surfacesMesh % zones ( SURFACE_TYPE_FWH ), mesh , surfacesMesh % elementSide (:, 1 )) !       see if its regular or interpolated !       ----------------------- if (. not . self % firstWrite ) then do i = 1 , self % numberOfObservers call self % observers ( i ) % update ( mesh , self % isSolid , self % bufferLine , self % interpolate ) end do else do i = 1 , self % numberOfObservers call self % observers ( i ) % updateOneStep ( mesh , self % bufferLine , self % isSolid , t ) end do end if End Subroutine FWHUpate","tags":"","url":"proc/fwhupate.html"},{"title":"FWHWriteToFile – HORSES3D","text":"public  subroutine FWHWriteToFile(self, force) Uses MPI_Process_Info Type Bound FWHClass Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self logical, optional :: force Source Code Subroutine FWHWriteToFile ( self , force ) ! !        ****************************************************************** !              This routine has a double behaviour: !           force = .true.  -> Writes to file and resets buffers !           force = .false. -> Just writes to file if the buffer is full !        ****************************************************************** ! use MPI_Process_Info implicit none class ( FWHClass ) :: self logical , optional :: force !       --------------- !       Local variables !       --------------- integer :: i logical :: forceVal !       Check if is activated !       ------------------------ if (. not . self % isActive ) return if ( present ( force ) ) then forceVal = force else forceVal = . false . end if if ( forceVal ) then ! !           In this case the observers are exported to their files and the buffer is reset !           ------------------------------------------------------------------------------ if (. not . self % firstWrite . and . self % interpolate ) then do i = 1 , self % numberOfObservers call self % observers ( i ) % interpolateSol ( self % t , self % bufferLine ) end do self % firstWrite = . TRUE . end if do i = 1 , self % numberOfObservers call self % observers ( i ) % writeToFile ( self % iter , self % t , self % bufferLine ) end do !               Reset buffer !               ------------ self % bufferLine = 0 else !               The observers are exported just if the buffer is full !               ---------------------------------------------------- if ( self % bufferLine . eq . OB_BUFFER_SIZE ) then if (. not . self % firstWrite . and . self % interpolate ) then do i = 1 , self % numberOfObservers call self % observers ( i ) % interpolateSol ( self % t , self % bufferLine ) end do self % firstWrite = . TRUE . end if do i = 1 , self % numberOfObservers call self % observers ( i ) % writeToFile ( self % iter , self % t , self % bufferLine ) end do !               Reset buffer !               ------------ self % bufferLine = 0 end if end if End Subroutine FWHWriteToFile","tags":"","url":"proc/fwhwritetofile.html"},{"title":"FWHDestruct – HORSES3D","text":"public  subroutine FWHDestruct(self) Type Bound FWHClass Arguments Type Intent Optional Attributes Name class( FWHClass ), intent(inout) :: self Source Code Subroutine FWHDestruct ( self ) implicit none class ( FWHClass ), intent ( inout ) :: self !       --------------- !       Local variables !       --------------- integer :: i !       Check if is activated !       ------------------------ if (. not . self % isActive ) return safedeallocate ( self % iter ) safedeallocate ( self % t ) ! safedeallocate(self % sourceZone) do i = 1 , self % numberOfObservers call self % observers ( i ) % destruct end do safedeallocate ( self % observers ) End Subroutine FWHDestruct","tags":"","url":"proc/fwhdestruct.html"},{"title":"ScalarSurfaceIntegral – HORSES3D","text":"public  function ScalarSurfaceIntegral(mesh, zoneID, integralType, iter) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(inout), target :: mesh integer, intent(in) :: zoneID integer, intent(in) :: integralType integer, intent(in) :: iter Return Value real(kind=RP) Source Code function ScalarSurfaceIntegral ( mesh , zoneID , integralType , iter ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes scalar integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           Implemented integrals are: !              * Surface: computes the zone surface. !              * Mass flow: computes the mass flow across the zone. !              * Flow: computes the volumetric flow across the zone. !        ----------------------------------------------------------- ! implicit none class ( HexMesh ), intent ( inout ), target :: mesh integer , intent ( in ) :: zoneID integer , intent ( in ) :: integralType , iter real ( kind = RP ) :: val , localval ! !        --------------- !        Local variables !        --------------- ! integer :: zonefID , fID , eID , fIDs ( 6 ), ierr class ( Element ), pointer :: elements (:) ! !        Initialization !        -------------- val = 0.0_RP ! !        Loop the zone to get faces and elements !        --------------------------------------- elements => mesh % elements !$omp parallel private(fID, eID, fIDs) shared(elements,mesh,NodalStorage,zoneID,integralType,val,& !$omp&                                          computeGradients) !$omp single do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces fID = mesh % zones ( zoneID ) % faces ( zonefID ) eID = mesh % faces ( fID ) % elementIDs ( 1 ) fIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) if ( computeGradients ) then call elements ( eID ) % ProlongGradientsToFaces ( NGRAD , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) end if !$omp end task end do !$omp end single ! !        Loop the zone to get faces and elements !        --------------------------------------- !$omp do private(fID) reduction(+:val) schedule(runtime) do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( zoneID ) % faces ( zonefID ) ! !           Compute the integral !           -------------------- val = val + ScalarSurfaceIntegral_Face ( mesh % faces ( fID ), integralType ) end do !$omp end do !$omp end parallel #ifdef _HAS_MPI_ localval = val call mpi_allreduce ( localval , val , 1 , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function ScalarSurfaceIntegral","tags":"","url":"proc/scalarsurfaceintegral.html"},{"title":"VectorSurfaceIntegral – HORSES3D","text":"public  function VectorSurfaceIntegral(mesh, zoneID, integralType, iter) result(val) Uses mpi Arguments Type Intent Optional Attributes Name class(HexMesh), intent(inout), target :: mesh integer, intent(in) :: zoneID integer, intent(in) :: integralType integer, intent(in) :: iter Return Value real(kind=RP), (NDIM) Source Code function VectorSurfaceIntegral ( mesh , zoneID , integralType , iter ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes scalar integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           Implemented integrals are: !              * Surface: computes the zone surface. !              * Mass flow: computes the mass flow across the zone. !              * Flow: computes the volumetric flow across the zone. !        ----------------------------------------------------------- ! #ifdef _HAS_MPI_ use mpi #endif implicit none class ( HexMesh ), intent ( inout ), target :: mesh integer , intent ( in ) :: zoneID integer , intent ( in ) :: integralType , iter real ( kind = RP ) :: val ( NDIM ) real ( kind = RP ) :: localVal ( NDIM ) real ( kind = RP ) :: valx , valy , valz ! !        --------------- !        Local variables !        --------------- ! integer :: zonefID , fID , eID , fIDs ( 6 ), ierr class ( Element ), pointer :: elements (:) ! !        Initialization !        -------------- val = 0.0_RP valx = 0.0_RP valy = 0.0_RP valz = 0.0_RP ! !        ************************* !        Perform the interpolation !        ************************* ! elements => mesh % elements !$omp parallel private(fID, eID, fIDs, localVal) shared(elements,mesh,NodalStorage,zoneID,integralType,val,& !$omp&                                        valx,valy,valz,computeGradients) !$omp single do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces fID = mesh % zones ( zoneID ) % faces ( zonefID ) eID = mesh % faces ( fID ) % elementIDs ( 1 ) fIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) if ( computeGradients ) then call elements ( eID ) % ProlongGradientsToFaces ( NGRAD , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) end if !$omp end task end do !$omp end single ! !        Loop the zone to get faces and elements !        --------------------------------------- !$omp do private(fID,localVal) reduction(+:valx,valy,valz) schedule(runtime) do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( zoneID ) % faces ( zonefID ) ! !           Compute the integral !           -------------------- localVal = VectorSurfaceIntegral_Face ( mesh % faces ( fID ), integralType ) valx = valx + localVal ( 1 ) valy = valy + localVal ( 2 ) valz = valz + localVal ( 3 ) end do !$omp end do !$omp end parallel val = ( / valx , valy , valz / ) #ifdef _HAS_MPI_ localVal = val call mpi_allreduce ( localVal , val , NDIM , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function VectorSurfaceIntegral","tags":"","url":"proc/vectorsurfaceintegral.html"},{"title":"ScalarDataReconstruction – HORSES3D","text":"public  subroutine ScalarDataReconstruction(IBM, elements, STLNum, integralType, iter, autosave, dt) Uses OrientedBoundingBox MPI_Process_Info MappedGeometryClass mpi MPI_IBMUtilities IBMClass TessellationTypes KDClass Arguments Type Intent Optional Attributes Name type(IBM_type), intent(inout) :: IBM type(element), intent(inout) :: elements (:) integer, intent(in) :: STLNum integer, intent(in) :: integralType integer, intent(in) :: iter logical :: autosave real(kind=RP), intent(in) :: dt Source Code subroutine ScalarDataReconstruction ( IBM , elements , STLNum , integralType , iter , autosave , dt ) use TessellationTypes use MappedGeometryClass use IBMClass use OrientedBoundingBox use KDClass use MPI_Process_Info use MPI_IBMUtilities #ifdef _HAS_MPI_ use mpi #endif ! !        ----------------------------------------------------------------------------------------- !           This function computes Scalar integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           The data at the boundary point (BP) is computed through a Inverse Distance Weight !           procedure. !        ----------------------------------------------------------------------------------------- implicit none !-arguments-------------------------------------------------------- type ( IBM_type ), intent ( inout ) :: IBM type ( element ), intent ( inout ) :: elements (:) integer , intent ( in ) :: integralType , STLNum , iter real ( kind = RP ), intent ( in ) :: dt !-local-variables------------------------------------------------- real ( kind = rp ), allocatable :: Qsurf (:,:), U_xsurf (:,:), U_ysurf (:,:), U_zsurf (:,:) integer :: i , j logical :: found , autosave if ( . not . IBM % Integral ( STLNum )% compute ) return allocate ( Qsurf ( NCONS , IBM % NumOfInterPoints ) ) call IBM % BandPoint_state ( elements , STLNum , . true . ) if ( IBM % stlSurfaceIntegrals ( STLNum )% move ) then if ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . ROTATION ) then call IBM % stlSurfaceIntegrals ( STLNum )% getRotationaMatrix ( dt ) call OBB ( STLNum )% STL_rotate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) elseif ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . LINEAR ) then call IBM % stlSurfaceIntegrals ( STLNum )% getDisplacement ( dt ) call OBB ( STLNum )% STL_translate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) end if end if if ( . not . MPI_Process % isRoot ) return !$omp parallel !$omp do schedule(runtime) private(j,found) do i = 1 , IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs do j = 1 , NumOfVertices + 4 call GetSurfaceState ( IBM , IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i ), IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), STLNum ) Qsurf = IBM % BandRegion ( STLNum )% Q (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) end do do j = 1 , NumOfVertices + 4 IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% ScalarValue = IntegratedScalarValue ( Q = Qsurf , & vertex = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), & normal = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% normal , & integralType = integralType , & InterpolationType = IBM % InterpolationType ) end do end do !$omp end do !$omp end parallel if ( IBM % stl ( STLNum )% move ) then IBM % Integral ( STLNum )% ListComputed = . false . else IBM % Integral ( STLNum )% ListComputed = . true . end if if ( autosave ) call GenerateScalarmonitorTECfile ( IBM , STLNum , integralType , iter ) end subroutine ScalarDataReconstruction","tags":"","url":"proc/scalardatareconstruction.html"},{"title":"VectorDataReconstruction – HORSES3D","text":"public  subroutine VectorDataReconstruction(IBM, elements, STLNum, integralType, iter, autosave, dt) Uses OrientedBoundingBox MPI_Process_Info MappedGeometryClass mpi MPI_IBMUtilities IBMClass TessellationTypes omp_lib KDClass Arguments Type Intent Optional Attributes Name type(IBM_type), intent(inout) :: IBM type(element), intent(inout) :: elements (:) integer, intent(in) :: STLNum integer, intent(in) :: integralType integer, intent(in) :: iter logical :: autosave real(kind=RP), intent(in) :: dt Source Code subroutine VectorDataReconstruction ( IBM , elements , STLNum , integralType , iter , autosave , dt ) use TessellationTypes use MappedGeometryClass use IBMClass use OrientedBoundingBox use KDClass use MPI_Process_Info use MPI_IBMUtilities use omp_lib #ifdef _HAS_MPI_ use mpi #endif ! !        ----------------------------------------------------------------------------------------- !           This function computes Vector integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           The data at the boundary point (BP) is computed through a Inverse Distance Weight !           procedure. !        ----------------------------------------------------------------------------------------- implicit none !-arguments--------------------------------------------------------------------------------- type ( IBM_type ), intent ( inout ) :: IBM type ( element ), intent ( inout ) :: elements (:) integer , intent ( in ) :: integralType , STLNum , iter real ( kind = RP ), intent ( in ) :: dt !-local-variables--------------------------------------------------------------------------- real ( kind = rp ), allocatable :: Qsurf (:,:,:), U_xsurf (:,:,:), U_ysurf (:,:,:), U_zsurf (:,:,:) integer :: i , j logical :: found , autosave if ( . not . IBM % Integral ( STLNum )% compute ) return allocate ( Qsurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ), & U_xsurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ), & U_ysurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ), & U_zsurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ) ) call IBM % BandPoint_state ( elements , STLNum , . true . ) if ( . not . MPI_Process % isRoot ) return if ( IBM % stlSurfaceIntegrals ( STLNum )% move ) then if ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . ROTATION ) then call IBM % stlSurfaceIntegrals ( STLNum )% getRotationaMatrix ( dt ) call OBB ( STLNum )% STL_rotate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) elseif ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . LINEAR ) then call IBM % stlSurfaceIntegrals ( STLNum )% getDisplacement ( dt ) call OBB ( STLNum )% STL_translate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) end if end if !$omp parallel !$omp do schedule(runtime) private(j,found,Qsurf,U_xsurf,U_ysurf,U_zsurf) do i = 1 , IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs do j = 1 , NumOfVertices + 4 call GetSurfaceState ( IBM , IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i ), IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), STLNum ) Qsurf (:,:, j ) = IBM % BandRegion ( STLNum )% Q (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) U_xsurf (:,:, j ) = IBM % BandRegion ( STLNum )% U_x (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) U_ysurf (:,:, j ) = IBM % BandRegion ( STLNum )% U_y (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) U_zsurf (:,:, j ) = IBM % BandRegion ( STLNum )% U_z (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) end do do j = 1 , NumOfVertices + 4 IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% VectorValue = IntegratedVectorValue ( Q = Qsurf (:,:, j ), & U_x = U_xsurf (:,:, j ), & U_y = U_ysurf (:,:, j ), & U_z = U_zsurf (:,:, j ), & vertex = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), & normal = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% normal , & y = IBM % IP_Distance , & Wallfunction = IBM % Wallfunction , & integralType = integralType , & InterpolationType = IBM % InterpolationType ) end do end do !$omp end do !$omp end parallel deallocate ( Qsurf , U_xsurf , U_ysurf , U_zsurf ) if ( IBM % stl ( STLNum )% move ) then IBM % Integral ( STLNum )% ListComputed = . false . else IBM % Integral ( STLNum )% ListComputed = . true . end if if ( autosave ) call GenerateVectormonitorTECfile ( IBM , STLNum , integralType , iter ) end subroutine VectorDataReconstruction","tags":"","url":"proc/vectordatareconstruction.html"},{"title":"ScalarVolumeIntegral – HORSES3D","text":"public  function ScalarVolumeIntegral(mesh, integralType) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(in) :: mesh integer, intent(in) :: integralType Return Value real(kind=RP) Source Code function ScalarVolumeIntegral ( mesh , integralType ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes scalar integrals, that is, those !           in the form: !                 val = \\int v dx !        ----------------------------------------------------------- ! implicit none class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: integralType real ( kind = RP ) :: val ! !        --------------- !        Local variables !        --------------- ! real ( kind = RP ) :: localVal integer :: eID , ierr ! !        Initialization !        -------------- val = 0.0_RP ! !        Loop the mesh !        ------------- !$omp parallel do reduction(+:val) private(eID) schedule(guided) do eID = 1 , mesh % no_of_elements ! !           Compute the integral !           -------------------- val = val + ScalarVolumeIntegral_Local ( mesh % elements ( eID ), & integralType ) end do !$omp end parallel do #ifdef _HAS_MPI_ localVal = val call mpi_allreduce ( localVal , val , 1 , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function ScalarVolumeIntegral","tags":"","url":"proc/scalarvolumeintegral.html"},{"title":"VectorVolumeIntegral – HORSES3D","text":"public  function VectorVolumeIntegral(mesh, integralType, num_of_vars) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(in) :: mesh integer, intent(in) :: integralType integer, intent(in) :: num_of_vars Return Value real(kind=RP), (num_of_vars) Source Code function VectorVolumeIntegral ( mesh , integralType , num_of_vars ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes vector integrals, that is, those !           in the form: !                 val = \\int \\vec{v} dx !           Implemented integrals are: !              * VELOCITY !              * MOMENTUM !        ----------------------------------------------------------- ! implicit none class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: integralType integer , intent ( in ) :: num_of_vars real ( kind = RP ) :: val ( num_of_vars ) ! !        --------------- !        Local variables !        --------------- ! logical :: fiveVars integer :: eID , ierr real ( kind = RP ) :: localVal ( num_of_vars ) real ( kind = RP ) :: valAux ( num_of_vars ) real ( kind = RP ) :: val1 , val2 , val3 , val4 , val5 if ( num_of_vars == 5 ) then ! Ugly hack.. But only way to make it work with ifort.... fiveVars = . TRUE . else fiveVars = . FALSE . end if ! !        Initialization !        -------------- val1 = 0.0_RP val2 = 0.0_RP val3 = 0.0_RP val4 = 0.0_RP val5 = 0.0_RP ! !        Loop the mesh !        ------------- !$omp parallel do reduction(+:val1,val2,val3,val4,val5) private(valAux) schedule(guided) do eID = 1 , mesh % no_of_elements ! !           Compute the integral !           -------------------- valAux = VectorVolumeIntegral_Local ( mesh % elements ( eID ), integralType , num_of_vars ) val1 = val1 + valAux ( 1 ) val2 = val2 + valAux ( 2 ) val3 = val3 + valAux ( 3 ) if ( fiveVars ) then val4 = val4 + valAux ( 4 ) val5 = val5 + valAux ( 5 ) end if end do !$omp end parallel do val ( 1 : 3 ) = [ val1 , val2 , val3 ] if ( fiveVars ) val ( 4 : 5 ) = [ val4 , val5 ] #ifdef _HAS_MPI_ localVal = val call mpi_allreduce ( localVal , val , num_of_vars , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function VectorVolumeIntegral","tags":"","url":"proc/vectorvolumeintegral.html"},{"title":"GetSensorRange – HORSES3D","text":"public  subroutine GetSensorRange(mesh, minSensor, maxSensor) !$omp parallel do schedule(static) private(ielem) !$omp end parallel do Arguments Type Intent Optional Attributes Name class(HexMesh), intent(in) :: mesh real(kind=RP), intent(out) :: minSensor real(kind=RP), intent(out) :: maxSensor Source Code subroutine GetSensorRange ( mesh , minSensor , maxSensor ) implicit none class ( HexMesh ), intent ( in ) :: mesh real ( RP ), intent ( out ) :: minSensor real ( RP ), intent ( out ) :: maxSensor ! !        --------------- !        Local variables !        --------------- ! integer :: ielem integer :: ierr minSensor = huge ( 1.0_RP ) / 1 0.0_RP maxSensor = - huge ( 1.0_RP ) / 1 0.0_RP !! !$omp parallel do schedule(static) private(ielem) ! do ielem = 1, mesh % no_of_elements !    minSensor = min(minSensor, mesh % elements(ielem) % storage % sensor) !    maxSensor = max(maxSensor, mesh % elements(ielem) % storage % sensor) ! end do !! !$omp end parallel do !$omp parallel shared(maxSensor, minSensor, mesh) default(private) !$omp do reduction(max:maxSensor) schedule(runtime) DO ielem = 1 , mesh % no_of_elements maxSensor = max ( maxSensor , mesh % elements ( ielem ) % storage % sensor ) END DO !$omp end do !$omp do reduction(min:minSensor) schedule(runtime) DO ielem = 1 , mesh % no_of_elements minSensor = min ( minSensor , mesh % elements ( ielem ) % storage % sensor ) END DO !$omp end do !$omp end parallel #ifdef _HAS_MPI_ call MPI_MinMax ( minSensor , maxSensor ) #endif end subroutine GetSensorRange","tags":"","url":"proc/getsensorrange.html"},{"title":"getMeanStreamValues – HORSES3D","text":"public  subroutine getMeanStreamValues() Uses fluiddata Arguments None Source Code Subroutine getMeanStreamValues () use fluiddata ! local variables real ( kind = RP ) :: theta , phi , U0Magnitud theta = refvalues % AOAtheta * ( pi / 18 0.0_RP ) phi = refvalues % AOAphi * ( pi / 18 0.0_RP ) ! set 1 by default ! TODO use values of boundary conditions (inflow if exists or outflow, or set this defaults if not exists) U0Magnitud = 1.0_RP rho0 = 1.0_RP U0 ( 1 ) = U0Magnitud * cos ( theta ) * cos ( phi ) U0 ( 2 ) = U0Magnitud * sin ( theta ) * cos ( phi ) U0 ( 3 ) = U0Magnitud * sin ( phi ) M0 = U0 * dimensionless % Mach c0 = U0Magnitud / dimensionless % Mach fwGamma2 = 1.0_RP / ( 1.0_RP - dimensionless % Mach ** 2 ) ! default initial condition and outflow BC for energy without external pressure ! TODO include external pressure P0 = 1.0_RP / ( dimensionless % gammaM2 ) ! rhoe0 = P0 / thermodynamics%gammaMinus1 + 0.5_RP*rho0*(U0Magnitud**2) End Subroutine getMeanStreamValues","tags":"","url":"proc/getmeanstreamvalues.html"},{"title":"SpatialMeanNode – HORSES3D","text":"Uses MPI_Process_Info FileReadingUtilities mpi SMConstants PhysicsStorage MonitorDefinitions FluidData HexMeshClass VariableConversion Derived Types type, public :: SpatialMeanNode_t Components Type Visibility Attributes Name Initial integer, public :: ID integer, public :: nVariables integer, public :: interval integer, public :: bufferSize integer, public :: bufferLine integer, public :: intervalCount integer, public :: nActive integer, public :: dirAxis integer, public :: nUniqueAll integer, public :: iVarU integer, public :: iVarV integer, public :: iVarW integer, public, allocatable :: activeLoc (:,:) integer, public, allocatable :: nMultiply (:) integer, public, allocatable :: nMultiplyAll (:) logical, public :: meanData = .false. real(kind=RP), public :: pmin (3) real(kind=RP), public :: pmax (3) real(kind=RP), public :: error = 0.000001 real(kind=RP), public, allocatable :: geom (:) real(kind=RP), public, allocatable :: meanU (:) real(kind=RP), public, allocatable :: meanV (:) real(kind=RP), public, allocatable :: meanW (:) real(kind=RP), public, allocatable :: values (:,:,:) character(len=STR_LEN_MONITORS), public, allocatable :: fileName (:) character(len=STR_LEN_MONITORS), public :: spatialMeanName character(len=STR_LEN_MONITORS), public, allocatable :: variable (:) Type-Bound Procedures procedure, public :: Initialization => SpatialMeanNode_Initialization procedure, public :: Update => SpatialMeanNode_Update procedure, public :: WriteToFile => SpatialMeanNode_WriteToFile procedure, public :: LookForUniqueCoordinate => SpatialMeanNode_LookForUniqueCoordinate procedure, public :: destruct => SpatialMeanNode_Destruct procedure, public :: copy => SpatialMeanNode_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/spatialmeannode.html"},{"title":"SamplingOperator – HORSES3D","text":"Uses Physics mpi SMConstants PhysicsStorage ElementClass FluidData HexMeshClass VariableConversion NodalStorageClass FaceClass Variables Type Visibility Attributes Name Initial integer, public, parameter :: SHEAR_STRESS_TANGENT = 1 integer, public, parameter :: SHEAR_STRESS_X = 2 integer, public, parameter :: SHEAR_STRESS_Y = 3 integer, public, parameter :: SHEAR_STRESS_Z = 4 integer, public, parameter :: PRESSURE_SURF = 5 integer, public, parameter :: Q1 = 6 integer, public, parameter :: Q2 = 7 integer, public, parameter :: Q3 = 8 integer, public, parameter :: Q4 = 9 integer, public, parameter :: Q5 = 10 Subroutines public  subroutine VectorSurfaceSampling (mesh, zoneID, integralType, monitorName, data_out) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(inout), target :: mesh integer, intent(in) :: zoneID integer, intent(in) :: integralType character(len=STR_LEN_MONITORS) :: monitorName real(kind=RP), intent(out), allocatable :: data_out (:)","tags":"","url":"module/samplingoperator.html"},{"title":"MonitorsClass – HORSES3D","text":"Uses StatisticsMonitor VolumeMonitorClass LoadBalancingMonitorClass SMConstants MonitorDefinitions SurfaceMonitorClass HexMeshClass ProbeClass FileReadingUtilities NodalStorageClass ResidualsMonitorClass Derived Types type, public :: Monitor_t Components Type Visibility Attributes Name Initial character(len=LINE_LENGTH), public :: solution_file integer, public :: no_of_probes integer, public :: no_of_surfaceMonitors integer, public :: no_of_volumeMonitors integer, public :: no_of_loadBalancingMonitors integer, public :: bufferLine integer, public, allocatable :: iter (:) integer, public :: dt_restriction logical, public :: write_dt_restriction real(kind=RP), public, allocatable :: t (:) real(kind=RP), public, allocatable :: SolverSimuTime (:) real(kind=RP), public, allocatable :: TotalSimuTime (:) type( Residuals_t ), public :: residuals class( VolumeMonitor_t ), public, allocatable :: volumeMonitors (:) class( LoadBalancingMonitor_t ), public, allocatable :: loadBalancingMonitors (:) class( Probe_t ), public, allocatable :: probes (:) class( SurfaceMonitor_t ), public, allocatable :: surfaceMonitors (:) type( StatisticsMonitor_t ), public :: stats Type-Bound Procedures procedure, public :: Construct => Monitors_Construct procedure, public :: WriteLabel => Monitor_WriteLabel procedure, public :: WriteUnderlines => Monitor_WriteUnderlines procedure, public :: WriteValues => Monitor_WriteValues procedure, public :: UpdateValues => Monitor_UpdateValues procedure, public :: WriteToFile => Monitor_WriteToFile procedure, public :: destruct => Monitor_Destruct procedure, public :: copy => Monitor_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/monitorsclass.html"},{"title":"Samplings – HORSES3D","text":"Uses SpatialMeanNode SurfaceSampling SMConstants MonitorDefinitions HexMeshClass FileReadingUtilities PlaneSampling NodalStorageClass Derived Types type, public :: Sampling_t Components Type Visibility Attributes Name Initial character(len=LINE_LENGTH), public :: solution_file integer, public :: no_of_surfaceSamplings = 0 integer, public :: no_of_planeSamplings = 0 integer, public :: no_of_spatialMeanNodes = 0 integer, public :: dt_restriction logical, public :: write_dt_restriction class( SurfaceSampling_t ), public, allocatable :: surfaceSamplings (:) class( PlaneSampling_t ), public, allocatable :: planeSamplings (:) class( SpatialMeanNode_t ), public, allocatable :: spatialMeanNodes (:) Type-Bound Procedures procedure, public :: Construct => Samplings_Construct procedure, public :: UpdateInterp => Samplings_UpdateLagrangeInterp procedure, public :: UpdateValues => Sampling_UpdateValues procedure, public :: WriteToFile => Sampling_WriteToFile procedure, public :: destruct => Sampling_Destruct procedure, public :: copy => Sampling_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/samplings.html"},{"title":"MonitorDefinitions – HORSES3D","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: BUFFER_SIZE_DEFAULT = 100 integer, public :: BUFFER_SIZE = BUFFER_SIZE_DEFAULT integer, public, parameter :: STR_LEN_MONITORS = 128 integer, public, parameter :: MONITOR_LENGTH = 10 integer, public, parameter :: VOLUME_UNDEFINED = 0 integer, public, parameter :: VOLUME_INTEGRAL = 1","tags":"","url":"module/monitordefinitions.html"},{"title":"FWHObseverClass – HORSES3D","text":"Uses MPI_Process_Info Physics mpi SMConstants PhysicsStorage ZoneClass HexMeshClass FWHDefinitions NodalStorageClass FaceClass Derived Types type, public :: ObserverSourcePairClass Components Type Visibility Attributes Name Initial real(kind=RP), public, dimension(:,:,:), allocatable :: rVect real(kind=RP), public, dimension(:,:), allocatable :: r real(kind=RP), public, dimension(:,:), allocatable :: re real(kind=RP), public, dimension(:,:,:), allocatable :: reUnitVect real(kind=RP), public, dimension(:,:), allocatable :: reStar real(kind=RP), public, dimension(:,:,:), allocatable :: reStarUnitVect real(kind=RP), public :: tDelay integer, public :: faceIDinMesh integer, public :: elementSide real(kind=RP), public :: normalCorrection real(kind=RP), public, dimension(:,:), allocatable :: Pacc real(kind=RP), public, dimension(:), allocatable :: tInterp Type-Bound Procedures procedure, public :: construct => ObserverSourcePairConstruct procedure, public :: destruct => ObserverSourcePairDestruct procedure, public :: allocPacc => ObserverSourcePairAllocSolution procedure, public :: interpolateSolF => ObserverSourcePairInterpolateSolFirst procedure, public :: newUpdate => ObserverSourcePairNewUpdate procedure, public :: interpolateSolS => ObserverSourcePairInterpolateSolSecond procedure, public :: updateOneStep => ObserverSourcePairUpdateOneStep procedure, public :: FWHSurfaceIntegral type, public :: ObserverClass Components Type Visibility Attributes Name Initial integer, public :: ID real(kind=RP), public, dimension(NDIM) :: x integer, public :: numberOfFaces class( ObserverSourcePairClass ), public, dimension(:), allocatable :: sourcePair real(kind=RP), public, dimension(:,:), allocatable :: Pac real(kind=RP), public :: tDelay real(kind=RP), public :: tDelayMax logical, public :: active character(len=STR_LEN_OBSERVER), public :: observerName character(len=STR_LEN_OBSERVER), public :: fileName Type-Bound Procedures procedure, public :: construct => ObserverConstruct procedure, public :: destruct => ObserverDestruct procedure, public :: update => ObserverUpdate procedure, public :: writeToFile => ObserverWriteToFile procedure, public :: updateTdelay => ObserverUpdateTdelay procedure, public :: interpolateSol => ObserverInterpolateSol procedure, public :: sumIntegrals => ObserverSumIntegrals procedure, public :: updateOneStep => ObserverUpdateOneStep Functions public  function FWHSurfaceIntegral (self, f, isSolid) result(Pacc) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self class(Face), intent(in) :: f logical, intent(in) :: isSolid Return Value real(kind=RP), dimension(3) public  function linearInterpolation (x, x1, y1, x2, y2, N) result(y) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: x real(kind=RP), intent(in) :: x1 real(kind=RP), intent(in), dimension(N) :: y1 real(kind=RP), intent(in) :: x2 real(kind=RP), intent(in), dimension(N) :: y2 integer, intent(in) :: N Return Value real(kind=RP), dimension(N) Subroutines public  subroutine ObserverConstruct (self, sourceZone, mesh, ID, solution_file, FirstCall, interpolate, totalNumberOfFaces, elementSide) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(Zone_t), intent(in) :: sourceZone class(HexMesh), intent(in) :: mesh integer, intent(in) :: ID character(len=*), intent(in) :: solution_file logical, intent(in) :: FirstCall logical, intent(in) :: interpolate integer, intent(in) :: totalNumberOfFaces integer, intent(in), dimension(:) :: elementSide public  subroutine ObserverUpdate (self, mesh, isSolid, bufferPosition, interpolate) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(HexMesh), intent(in) :: mesh logical, intent(in) :: isSolid integer, intent(in), optional :: bufferPosition logical, intent(in) :: interpolate public  subroutine ObserverUpdateTdelay (self, totalNumberOfFaces) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, intent(in) :: totalNumberOfFaces public  subroutine ObserverWriteToFile (self, iter, tsource, no_of_lines) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, dimension(:) :: iter real(kind=RP), dimension(:) :: tsource integer :: no_of_lines public  subroutine ObserverUpdateOneStep (self, mesh, bufferPosition, isSolid, tsource) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self class(HexMesh), intent(in) :: mesh integer, intent(in) :: bufferPosition logical, intent(in) :: isSolid real(kind=RP), intent(in) :: tsource public  subroutine ObserverInterpolateSol (self, tsource, no_of_lines) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self real(kind=RP), intent(in), dimension(:) :: tsource integer, intent(in) :: no_of_lines public  subroutine ObserverSumIntegrals (self, nDiscard, N, startIndex, no_of_lines) Arguments Type Intent Optional Attributes Name class( ObserverClass ) :: self integer, intent(in), dimension(self % numberOfFaces) :: nDiscard integer, intent(in) :: N integer, intent(in) :: startIndex integer, intent(in) :: no_of_lines public  subroutine ObserverDestruct (self) Arguments Type Intent Optional Attributes Name class( ObserverClass ), intent(inout) :: self public  subroutine ObserverSourcePairConstruct (self, x, f, fID, FirstCall, elementSide) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self real(kind=RP), intent(in), dimension(NDIM) :: x type(face), intent(in) :: f integer, intent(in) :: fID logical, intent(in) :: FirstCall integer, intent(in) :: elementSide public elemental subroutine ObserverSourcePairDestruct (self) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ), intent(inout) :: self public  subroutine ObserverSourcePairAllocSolution (self, buffer_size) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: buffer_size public  subroutine ObserverSourcePairInterpolateSolFirst (self, N, M, tobserver, tsource, nd) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: N integer, intent(in) :: M real(kind=RP), intent(in), dimension(N) :: tobserver real(kind=RP), intent(in), dimension(:) :: tsource integer, intent(out) :: nd public  subroutine ObserverSourcePairNewUpdate (self, N, NDiscard, M, tsource, sameDelay) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self integer, intent(in) :: N integer, intent(in) :: NDiscard integer, intent(in) :: M real(kind=RP), intent(in), dimension(:) :: tsource logical, intent(in) :: sameDelay public  subroutine ObserverSourcePairUpdateOneStep (self) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self public  subroutine ObserverSourcePairInterpolateSolSecond (self, tobserver, tsource) Arguments Type Intent Optional Attributes Name class( ObserverSourcePairClass ) :: self real(kind=RP), intent(in) :: tobserver real(kind=RP), intent(in) :: tsource public  subroutine SourceProlongSolution (source_zone, mesh, eSides) $omp&                                        t) Arguments Type Intent Optional Attributes Name class(Zone_t), intent(in) :: source_zone class(HexMesh), intent(inout), target :: mesh integer, intent(in), dimension(:) :: eSides public  subroutine calculateFWHVariables (Q, Qdot, isSolid, Qi, Qidot, Lij, LijDot) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in), dimension(NCONS) :: Q real(kind=RP), intent(in), dimension(NCONS) :: Qdot logical, intent(in) :: isSolid real(kind=RP), intent(out), dimension(NDIM) :: Qi real(kind=RP), intent(out), dimension(NDIM) :: Qidot real(kind=RP), intent(out), dimension(NDIM,NDIM) :: Lij real(kind=RP), intent(out), dimension(NDIM,NDIM) :: LijDot","tags":"","url":"module/fwhobseverclass.html"},{"title":"ProbeClass – HORSES3D","text":"Uses MPI_Process_Info FileReadingUtilities mpi SMConstants PhysicsStorage MonitorDefinitions FluidData HexMeshClass VariableConversion NodalStorageClass Derived Types type, public :: Probe_t Components Type Visibility Attributes Name Initial logical, public :: active integer, public :: rank integer, public :: ID integer, public :: eID real(kind=RP), public :: x (NDIM) real(kind=RP), public :: xi (NDIM) real(kind=RP), public, allocatable :: values (:) real(kind=RP), public, allocatable :: lxi (:) real(kind=RP), public, allocatable :: leta (:) real(kind=RP), public, allocatable :: lzeta (:) character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => Probe_Initialization procedure, public :: Update => Probe_Update procedure, public :: WriteLabel => Probe_WriteLabel procedure, public :: WriteValues => Probe_WriteValue procedure, public :: WriteToFile => Probe_WriteToFile procedure, public :: LookInOtherPartitions => Probe_LookInOtherPartitions procedure, public :: destruct => Probe_Destruct procedure, public :: copy => Probe_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/probeclass.html"},{"title":"SurfaceSampling – HORSES3D","text":"Uses MPI_Process_Info mpi SMConstants PhysicsStorage MonitorDefinitions FluidData HexMeshClass FileReadingUtilities Derived Types type, public :: SurfaceSampling_t Components Type Visibility Attributes Name Initial logical, public :: active = .false. logical, public :: isDimensionless integer, public :: ID integer, public :: nVariables integer, public :: marker integer, public :: rank integer, public :: interval integer, public :: bufferSize integer, public :: bufferLine integer, public :: intervalCount integer, public, allocatable :: nData (:) real(kind=RP), public, allocatable :: values (:,:,:) character(len=STR_LEN_MONITORS), public :: SamplingName character(len=STR_LEN_MONITORS), public, allocatable :: fileName (:) character(len=STR_LEN_MONITORS), public, allocatable :: variable (:) Type-Bound Procedures procedure, public :: Initialization => SurfaceSampling_Initialization procedure, public :: Update => SurfaceSampling_Update procedure, public :: WriteToFile => SurfaceSampling_WriteToFile procedure, public :: destruct => SurfaceSampling_Destruct procedure, public :: copy => SurfaceSampling_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/surfacesampling.html"},{"title":"SurfaceMonitorClass – HORSES3D","text":"Uses MPI_Process_Info SMConstants PhysicsStorage MonitorDefinitions FluidData HexMeshClass FileReadingUtilities Derived Types type, public :: SurfaceMonitor_t Components Type Visibility Attributes Name Initial logical, public :: active logical, public :: isDimensionless logical, public :: IBM = .false. integer, public :: ID real(kind=RP), public :: direction (NDIM) integer, public :: marker real(kind=RP), public, allocatable :: referenceSurface real(kind=RP), public, allocatable :: values (:) real(kind=RP), public :: dynamicPressure character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => SurfaceMonitor_Initialization procedure, public :: Update => SurfaceMonitor_Update procedure, public :: WriteLabel => SurfaceMonitor_WriteLabel procedure, public :: WriteValues => SurfaceMonitor_WriteValue procedure, public :: WriteToFile => SurfaceMonitor_WriteToFile procedure, public :: destruct => SurfaceMonitor_Destruct procedure, public :: copy => SurfaceMonitor_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/surfacemonitorclass.html"},{"title":"StatisticsMonitor – HORSES3D","text":"Uses Utilities mpi SMConstants StorageClass HexMeshClass Variables Type Visibility Attributes Name Initial integer, public :: NO_OF_VARIABLES integer, public, parameter :: NO_OF_VARIABLES_Sij = 9 integer, public, parameter :: U = 1 integer, public, parameter :: V = 2 integer, public, parameter :: W = 3 integer, public, parameter :: UU = 4 integer, public, parameter :: VV = 5 integer, public, parameter :: WW = 6 integer, public, parameter :: UV = 7 integer, public, parameter :: UW = 8 integer, public, parameter :: VW = 9 Derived Types type, public :: StatisticsMonitor_t Components Type Visibility Attributes Name Initial integer, public :: state integer, public :: sampling_interval integer, public :: dump_interval integer, public :: reset_interval integer, public :: starting_iteration real(kind=RP), public :: starting_time integer, public :: no_of_samples logical, public :: saveGradients Type-Bound Procedures procedure, public :: Construct => StatisticsMonitor_Construct procedure, public :: Update => StatisticsMonitor_Update procedure, public :: UpdateValues => StatisticsMonitor_UpdateValues procedure, public :: GetState => StatisticsMonitor_GetState procedure, public :: WriteLabel => StatisticsMonitor_WriteLabel procedure, public :: WriteValue => StatisticsMonitor_WriteValue procedure, public :: WriteFile => StatisticsMonitor_WriteFile","tags":"","url":"module/statisticsmonitor.html"},{"title":"FWHGeneralClass – HORSES3D","text":"Uses SurfaceMesh FWHObseverClass SMConstants HexMeshClass FileReadingUtilities FWHDefinitions Derived Types type, public :: FWHClass Components Type Visibility Attributes Name Initial character(len=LINE_LENGTH), public :: solution_file integer, public :: numberOfObservers = 0 integer, public :: bufferLine integer, public, dimension(:), allocatable :: iter real(kind=RP), public, dimension(:), allocatable :: t class( ObserverClass ), public, dimension(:), allocatable :: observers integer, public :: totalNumberOfFaces logical, public :: isSolid logical, public :: isActive = .false. logical, public :: firstWrite logical, public :: interpolate Type-Bound Procedures procedure, public :: construct => FWHConstruct procedure, public :: destruct => FWHDestruct procedure, public :: updateValues => FWHUpate procedure, public :: writeToFile => FWHWriteToFile Functions public  function getNoOfObservers () result(no_of_observers) Arguments None Return Value integer Subroutines public  subroutine FWHConstruct (self, mesh, controlVariables) Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self class(HexMesh), intent(in) :: mesh class(FTValueDictionary), intent(in) :: controlVariables public  subroutine FWHUpate (self, mesh, t, iter, isFromFile) Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self class(HexMesh) :: mesh real(kind=RP), intent(in) :: t integer, intent(in) :: iter logical, intent(in), optional :: isFromFile public  subroutine FWHWriteToFile (self, force) Arguments Type Intent Optional Attributes Name class( FWHClass ) :: self logical, optional :: force public  subroutine FWHDestruct (self) Arguments Type Intent Optional Attributes Name class( FWHClass ), intent(inout) :: self","tags":"","url":"module/fwhgeneralclass.html"},{"title":"SurfaceIntegrals – HORSES3D","text":"Uses Physics mpi SMConstants PhysicsStorage ElementClass HexMeshClass VariableConversion NodalStorageClass FaceClass Variables Type Visibility Attributes Name Initial integer, public, parameter :: SURFACE = 1 integer, public, parameter :: TOTAL_FORCE = 2 integer, public, parameter :: PRESSURE_FORCE = 3 integer, public, parameter :: VISCOUS_FORCE = 4 integer, public, parameter :: MASS_FLOW = 5 integer, public, parameter :: FLOW_RATE = 6 integer, public, parameter :: PRESSURE_DISTRIBUTION = 7 Functions public  function ScalarSurfaceIntegral (mesh, zoneID, integralType, iter) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(inout), target :: mesh integer, intent(in) :: zoneID integer, intent(in) :: integralType integer, intent(in) :: iter Return Value real(kind=RP) public  function VectorSurfaceIntegral (mesh, zoneID, integralType, iter) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(inout), target :: mesh integer, intent(in) :: zoneID integer, intent(in) :: integralType integer, intent(in) :: iter Return Value real(kind=RP), (NDIM) Subroutines public  subroutine ScalarDataReconstruction (IBM, elements, STLNum, integralType, iter, autosave, dt) Arguments Type Intent Optional Attributes Name type(IBM_type), intent(inout) :: IBM type(element), intent(inout) :: elements (:) integer, intent(in) :: STLNum integer, intent(in) :: integralType integer, intent(in) :: iter logical :: autosave real(kind=RP), intent(in) :: dt public  subroutine VectorDataReconstruction (IBM, elements, STLNum, integralType, iter, autosave, dt) Arguments Type Intent Optional Attributes Name type(IBM_type), intent(inout) :: IBM type(element), intent(inout) :: elements (:) integer, intent(in) :: STLNum integer, intent(in) :: integralType integer, intent(in) :: iter logical :: autosave real(kind=RP), intent(in) :: dt","tags":"","url":"module/surfaceintegrals.html"},{"title":"VolumeIntegrals – HORSES3D","text":"Uses MPI_Utilities Physics mpi SMConstants PhysicsStorage ElementClass FluidData HexMeshClass VariableConversion NodalStorageClass Enumerations enum, bind(c) Enumerators enumerator :: VOLUME = 0 enumerator :: KINETIC_ENERGY = 1 enumerator :: KINETIC_ENERGY_RATE = 2 enumerator :: KINETIC_ENERGY_BALANCE = 3 enumerator :: ENSTROPHY = 4 enumerator :: VELOCITY = 5 enumerator :: ENTROPY = 6 enumerator :: ENTROPY_RATE = 7 enumerator :: INTERNAL_ENERGY = 8 enumerator :: MOMENTUM = 9 enumerator :: SOURCE = 10 enumerator :: PSOURCE = 11 enumerator :: ARTIFICIAL_DISSIPATION = 12 enumerator :: ENTROPY_BALANCE = 13 enumerator :: MATH_ENTROPY = 14 enumerator :: MASS = 15 enumerator :: ENTROPY = 16 enumerator :: KINETIC_ENERGY_RATE = 17 enumerator :: ENTROPY_RATE = 18 enumerator :: SOURCE = 19 enumerator :: ENTROPY_RATE = 20 enumerator :: ENTROPY_BALANCE = 21 enumerator :: PHASE2_AREA = 22 enumerator :: PHASE2_XCOG = 23 enumerator :: PHASE2_XVEL = 24 enumerator :: SOURCE = 25 enumerator :: FREE_ENERGY = 26 enumerator :: ACOUSTIC_ENERGY = 27 enumerator :: SOURCE = 28 Functions public  function ScalarVolumeIntegral (mesh, integralType) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(in) :: mesh integer, intent(in) :: integralType Return Value real(kind=RP) public  function VectorVolumeIntegral (mesh, integralType, num_of_vars) result(val) Arguments Type Intent Optional Attributes Name class(HexMesh), intent(in) :: mesh integer, intent(in) :: integralType integer, intent(in) :: num_of_vars Return Value real(kind=RP), (num_of_vars) Subroutines public  subroutine GetSensorRange (mesh, minSensor, maxSensor) !$omp parallel do schedule(static) private(ielem) Read more… Arguments Type Intent Optional Attributes Name class(HexMesh), intent(in) :: mesh real(kind=RP), intent(out) :: minSensor real(kind=RP), intent(out) :: maxSensor","tags":"","url":"module/volumeintegrals.html"},{"title":"LoadBalancingMonitorClass – HORSES3D","text":"Uses MPI_Process_Info mpi SMConstants MonitorDefinitions HexMeshClass Derived Types type, public :: LoadBalancingMonitor_t Components Type Visibility Attributes Name Initial logical, public :: active integer, public :: ID integer, public :: bufferLine integer, public :: num_of_vars real(kind=RP), public, allocatable :: values (:,:) character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => LoadBalancingMonitor_Initialization procedure, public :: Update => LoadBalancingMonitor_Update procedure, public :: WriteLabel => LoadBalancingMonitor_WriteLabel procedure, public :: WriteValues => LoadBalancingMonitor_WriteValue procedure, public :: WriteToFile => LoadBalancingMonitor_WriteToFile procedure, public :: getLast => LoadBalancingMonitor_GetLast procedure, public :: destruct => LoadBalancingMonitor_Destruct procedure, public :: copy => LoadBalancingMonitor_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/loadbalancingmonitorclass.html"},{"title":"VolumeMonitorClass – HORSES3D","text":"Uses MPI_Process_Info SMConstants PhysicsStorage MonitorDefinitions HexMeshClass Derived Types type, public :: VolumeMonitor_t Components Type Visibility Attributes Name Initial logical, public :: active integer, public :: ID integer, public :: bufferLine integer, public :: num_of_vars real(kind=RP), public, allocatable :: values (:,:) character(len=STR_LEN_MONITORS), public :: monitorName character(len=STR_LEN_MONITORS), public :: fileName character(len=STR_LEN_MONITORS), public :: variable Type-Bound Procedures procedure, public :: Initialization => VolumeMonitor_Initialization procedure, public :: Update => VolumeMonitor_Update procedure, public :: WriteLabel => VolumeMonitor_WriteLabel procedure, public :: WriteValues => VolumeMonitor_WriteValue procedure, public :: WriteToFile => VolumeMonitor_WriteToFile procedure, public :: getLast => VolumeMonitor_GetLast procedure, public :: destruct => VolumeMonitor_Destruct procedure, public :: copy => VolumeMonitor_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/volumemonitorclass.html"},{"title":"PlaneSampling – HORSES3D","text":"Uses MPI_Process_Info FileReadingUtilities mpi SMConstants PhysicsStorage MonitorDefinitions FluidData HexMeshClass VariableConversion NodalStorageClass Derived Types type, public :: PlaneSampling_t Components Type Visibility Attributes Name Initial logical, public, allocatable :: active (:) integer, public, allocatable :: rank (:) integer, public :: ID integer, public :: nVariables integer, public :: interval integer, public :: bufferSize integer, public :: bufferLine integer, public :: intervalCount integer, public :: N (2) integer, public :: nNodes integer, public, allocatable :: eID (:) real(kind=RP), public, allocatable :: lxi (:,:) real(kind=RP), public, allocatable :: leta (:,:) real(kind=RP), public, allocatable :: lzeta (:,:) real(kind=RP), public, allocatable :: values (:,:,:) real(kind=RP), public, allocatable :: x (:,:) real(kind=RP), public, allocatable :: xi (:,:) logical, public :: disturbanceData = .false. character(len=STR_LEN_MONITORS), public, allocatable :: fileName (:) character(len=STR_LEN_MONITORS), public :: planeName character(len=STR_LEN_MONITORS), public :: fileInput character(len=STR_LEN_MONITORS), public, allocatable :: variable (:) Type-Bound Procedures procedure, public :: Initialization => Plane_Initialization procedure, public :: Update => Plane_Update procedure, public :: UpdateInterp => Plane_UpdateLagrangeInterp procedure, public :: WriteToFile => Plane_WriteToFile procedure, public :: LookInOtherPartitions => Plane_LookInOtherPartitions procedure, public :: destruct => Plane_Destruct procedure, public :: copy => Plane_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/planesampling.html"},{"title":"FWHDefinitions – HORSES3D","text":"Uses SMConstants Variables Type Visibility Attributes Name Initial real(kind=RP), public :: rho0 real(kind=RP), public :: P0 real(kind=RP), public :: c0 real(kind=RP), public :: fwGamma2 real(kind=RP), public, dimension(NDIM) :: U0 real(kind=RP), public, dimension(NDIM) :: M0 integer, public, parameter :: OB_BUFFER_SIZE_DEFAULT = 200 integer, public :: OB_BUFFER_SIZE = OB_BUFFER_SIZE_DEFAULT integer, public, parameter :: STR_LEN_OBSERVER = 128 integer, public, parameter :: OBS_LENGTH = 10 Subroutines public  subroutine getMeanStreamValues () Arguments None","tags":"","url":"module/fwhdefinitions.html"},{"title":"ResidualsMonitorClass – HORSES3D","text":"Uses MPI_Process_Info SMConstants PhysicsStorage MonitorDefinitions HexMeshClass Derived Types type, public :: Residuals_t Components Type Visibility Attributes Name Initial logical, public :: active real(kind=RP), public, allocatable :: values (:,:) real(kind=RP), public, allocatable :: CPUtime (:) character(len=STR_LEN_MONITORS), public :: fileName Type-Bound Procedures procedure, public :: Initialization => Residuals_Initialization procedure, public :: Update => Residuals_Update procedure, public :: WriteLabel => Residuals_WriteLabel procedure, public :: WriteValues => Residuals_WriteValue procedure, public :: WriteToFile => Residuals_WriteToFile procedure, public :: destruct => Residuals_Destruct procedure, public :: copy => Residuals_Assign generic, public :: assignment(=) => copy","tags":"","url":"module/residualsmonitorclass.html"},{"title":"SpatialMeanNode.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module SpatialMeanNode use SMConstants use HexMeshClass use MonitorDefinitions use PhysicsStorage use VariableConversion use MPI_Process_Info use FluidData use FileReadingUtilities , only : getRealArrayFromString , GetRealValue , getCharArrayFromString , GetIntValue , GetLogicalValue #ifdef _HAS_MPI_ use mpi #endif implicit none private public SpatialMeanNode_t ! !  ********************************* !  SpatialMeanNodes class definition !  ********************************* ! type SpatialMeanNode_t integer :: ID integer :: nVariables integer :: interval integer :: bufferSize integer :: bufferLine integer :: intervalCount integer :: nActive integer :: dirAxis integer :: nUniqueAll integer :: iVarU , iVarV , iVarW integer , allocatable :: activeLoc (:,:) integer , allocatable :: nMultiply (:) integer , allocatable :: nMultiplyAll (:) logical :: meanData = . false . real ( kind = RP ) :: pmin ( 3 ), pmax ( 3 ) real ( kind = RP ) :: error = 0.000001 ! tolerance of coordinate real ( kind = RP ), allocatable :: geom (:) ! size nUnique real ( kind = RP ), allocatable :: meanU (:), meanV (:), meanW (:) real ( kind = RP ), allocatable :: values (:,:,:) ! (nUnique, bufferSize, nVariables) character ( len = STR_LEN_MONITORS ), allocatable :: fileName (:) character ( len = STR_LEN_MONITORS ) :: spatialMeanName character ( len = STR_LEN_MONITORS ), allocatable :: variable (:) contains procedure :: Initialization => SpatialMeanNode_Initialization procedure :: Update => SpatialMeanNode_Update procedure :: WriteToFile => SpatialMeanNode_WriteToFile procedure :: LookForUniqueCoordinate => SpatialMeanNode_LookForUniqueCoordinate procedure :: destruct => SpatialMeanNode_Destruct procedure :: copy => SpatialMeanNode_Assign generic :: assignment ( = ) => copy end type SpatialMeanNode_t contains subroutine SpatialMeanNode_Initialization ( self , mesh , ID , solution_file , FirstCall ) use Headers use ParamfileRegions use MPI_Process_Info use Utilities , only : toLower implicit none class ( SpatialMeanNode_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , fID real ( kind = RP ) :: point ( 2 , 3 ) character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile character ( len = STR_LEN_MONITORS ) :: interval , direction character ( len = STR_LEN_MONITORS ) :: point1_char , point2_char , point3_char character ( len = STR_LEN_MONITORS ) :: variables character ( len = STR_LEN_MONITORS ) :: fileFormat character ( len = STR_LEN_MONITORS ) :: writeInterval character ( len = STR_LEN_MONITORS ) :: meanData #if defined(NAVIERSTOKES) && (!(INCNS)) if ( FirstCall ) then ! !           Get monitor ID, assign zero to bufferLine and intervalCount !           -------------- self % ID = ID self % bufferLine = 0 self % intervalCount = 0 ! !           Search for the parameters in the case file !           ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define spatial mean node \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ), \"name\" , self % spatialMeanName , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"variables\" , variables , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"direction axis\" , direction , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"xrange [xmin,xmax]\" , point1_char , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"yrange [ymin,ymax]\" , point2_char , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"zrange [zmin,zmax]\" , point3_char , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"sampling interval\" , interval , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"write interval\" , writeInterval , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"mean data\" , meanData , in_label , \"#end\" ) ! !           Get the variables, points, N discretization, and interval !           ---------------------------------------------- call getCharArrayFromString ( variables , STR_LEN_MONITORS , self % variable ) self % nVariables = size ( self % variable ) point (:, 1 ) = getRealArrayFromString ( point1_char ) point (:, 2 ) = getRealArrayFromString ( point2_char ) point (:, 3 ) = getRealArrayFromString ( point3_char ) self % pmin ( 1 ) = point ( 1 , 1 ) self % pmin ( 2 ) = point ( 1 , 2 ) self % pmin ( 3 ) = point ( 1 , 3 ) self % pmax ( 1 ) = point ( 2 , 1 ) self % pmax ( 2 ) = point ( 2 , 2 ) self % pmax ( 3 ) = point ( 2 , 3 ) self % dirAxis = GetIntValue ( direction ) self % interval = GetIntValue ( interval ) if ( len ( trim ( meanData )). lt . 3 ) then self % meanData = . false . else self % meanData = GetLogicalValue ( meanData ) end if if ( . not . allocated ( mesh % elements ( 1 ) % storage % stats % data ) ) then self % meanData = . false . end if interval = TRIM ( ADJUSTL ( interval )) ! !           Get the max. number of timestep in the buffer file before being written !           ----------------------------------------------------------------------- IF ( LEN ( TRIM ( writeInterval )) . EQ . 0 ) THEN self % bufferSize = 1 ; ELSE self % bufferSize = GetIntValue ( writeInterval ) ! !               Failsafe to prevent too many data being written at one time !               ----------------------------------------------------------- IF ( self % bufferSize . GT . 10000 ) THEN self % bufferSize = 10000 ; END IF END IF ! !           Look for unique data point in the range !           --------------------------------------- call self % LookForUniqueCoordinate ( mesh ) ! !           Allocate Variables !           ------------------ ALLOCATE ( self % fileName ( self % nVariables )) self % values = 0_RP end if if ( self % meanData ) then allocate ( self % meanU ( self % nUniqueAll ), self % meanV ( self % nUniqueAll ), self % meanW ( self % nUniqueAll )) self % meanU = 0_RP self % meanV = 0_RP self % meanW = 0_RP end if ! !        Check Variables, Create Files, and Write Header Files !        ----------------------------------------------------- do i = 1 , self % nVariables if ( self % meanData ) then ! !           Prepare the file in which the SpatialMeanNode is exported !           --------------------------------------------------------- write ( self % fileName ( i ) , '(A,A,A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( self % spatialMeanName ) , \"_\" , trim ( self % variable ( i )) & , \"_spatialTemporalMean_\" , self % ID , \".node\" ! !           Check the variable !           ------------------ call tolower ( self % variable ( i )) #ifdef NAVIERSTOKES select case ( trim ( self % variable ( i )) ) case ( \"density\" ) case ( \"pressure\" ) case ( \"ptotal\" ) case ( \"velocity\" ) case ( \"viscosity\" ) case ( \"u\" ) self % iVarU = i case ( \"v\" ) self % iVarV = i case ( \"w\" ) self % iVarW = i case ( \"uu\" ) case ( \"vv\" ) case ( \"ww\" ) case ( \"uv\" ) case ( \"uw\" ) case ( \"vw\" ) case ( \"uprime2\" ) case ( \"vprime2\" ) case ( \"wprime2\" ) case ( \"uvprime\" ) case ( \"uwprime\" ) case ( \"vwprime\" ) case ( \"mach\" ) case ( \"k\" ) case ( \"q1\" ) case ( \"q2\" ) case ( \"q3\" ) case ( \"q4\" ) case ( \"q5\" ) case default if ( MPI_Process % isRoot ) then print * , 'SpatialMeanNode from temporal mean data, variable \"' , trim ( self % variable ( i )), '\" not implemented.' print * , \"Options available are:\" print * , \"   * density\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * viscosity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" print * , \"   * uu\" print * , \"   * vv\" print * , \"   * ww\" print * , \"   * uv\" print * , \"   * uw\" print * , \"   * vw\" print * , \"   * uprime2\" print * , \"   * vprime2\" print * , \"   * wprime2\" print * , \"   * uvprime\" print * , \"   * uwprime\" print * , \"   * vwprime\" print * , \"   * Mach\" print * , \"   * K\" print * , \"   * q1\" print * , \"   * q2\" print * , \"   * q3\" print * , \"   * q4\" print * , \"   * q5\" end if end select #endif else ! !           Prepare the file in which the SpatialMeanNode is exported !           --------------------------------------------------------- write ( self % fileName ( i ) , '(A,A,A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( self % spatialMeanName ) , \"_\" , trim ( self % variable ( i )) & , \"_spatialmean_\" , self % ID , \".node\" ! !           Check the variable !           ------------------ call tolower ( self % variable ( i )) select case ( trim ( self % variable ( i )) ) #ifdef NAVIERSTOKES case ( \"density\" ) case ( \"pressure\" ) case ( \"ptotal\" ) case ( \"velocity\" ) case ( \"viscosity\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case ( \"mach\" ) case ( \"k\" ) case ( \"omegax\" ) case ( \"omegay\" ) case ( \"omegaz\" ) case ( \"q1\" ) case ( \"q2\" ) case ( \"q3\" ) case ( \"q4\" ) case ( \"q5\" ) case default if ( MPI_Process % isRoot ) then print * , 'SpatialMeanNode variable \"' , trim ( self % variable ( i )), '\" not implemented.' print * , \"Options available are:\" print * , \"   * density\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * viscosity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" print * , \"   * Mach\" print * , \"   * K\" print * , \"   * q1\" print * , \"   * q2\" print * , \"   * q3\" print * , \"   * q4\" print * , \"   * q5\" end if #endif #ifdef INCNS case default print * , \"SpatialMeanNodes are not implemented for the incompressible NSE\" #endif #ifdef MULTIPHASE case default print * , 'SpatialMeanNodes are not implemented.' #endif end select end if end do if ( . not . MPI_Process % isRoot ) return do i = 1 , self % nVariables #if defined(NAVIERSTOKES) && (!(INCNS)) ! !        Create file !        ----------- if ( FirstCall ) then if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ( i )) , action = \"write\" , access = \"stream\" , status = \"replace\" , position = 'append' ) ! !           Write the file headers !           ---------------------- write ( fID ) self % ID write ( fID ) sum ( self % nMultiplyAll ) write ( fID ) self % nUniqueAll write ( fID ) self % dirAxis write ( fID ) self % interval write ( fID ) refValues % rho write ( fID ) refValues % V write ( fID ) refValues % p write ( fID ) refValues % T write ( fID ) refValues % mu write ( fID ) refValues % AoATheta write ( fID ) refValues % AoAPhi write ( fID ) self % geom close ( fID ) end if end if #endif end do #if defined(NAVIERSTOKES) && (!(INCNS)) ! !           File Format !           ----------------------------------------------- write ( fileFormat , '(A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( self % spatialMeanName ) , \"_'variable'_spatialmean_\" , self % ID , \".node\" ! !        Write Information !        ----------------------------------------------- write ( STD_OUT , '(/)' ) call SubSection_Header ( \"SpatialMean Nodes\" ) write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"SpatialMeanNode ID: \" , self % ID write ( STD_OUT , '(30X,A,A27,A128)' ) \"->\" , \"Variables: \" , variables write ( STD_OUT , '(30X,A,A27,A,F6.4,A,F6.4,A)' ) \"->\" , \"xrange [xmin,xmax] (m): \" , \"[\" , & self % pmin ( 1 ), \", \" , self % pmax ( 1 ), \"]\" write ( STD_OUT , '(30X,A,A27,A,F6.4,A,F6.4,A)' ) \"->\" , \"yrange [ymin,ymax] (m): \" , \"[\" , & self % pmin ( 2 ), \", \" , self % pmax ( 2 ), \"]\" write ( STD_OUT , '(30X,A,A27,A,F6.4,A,F6.4,A)' ) \"->\" , \"zrange [zmin,zmax] (m): \" , \"[\" , & self % pmin ( 3 ), \", \" , self % pmax ( 3 ), \"]\" write ( STD_OUT , '(30X,A,A27,I5)' ) \"->\" , \"Number of unique nodes: \" , self % nUniqueAll write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"Samplings Interval: \" , self % interval write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"Write Interval: \" , self % bufferSize write ( STD_OUT , '(30X,A,A27,L1)' ) \"->\" , \"Meanflow data: \" , self % meanData write ( STD_OUT , '(30X,A,A27,A128)' ) \"->\" , \"Filename: \" , fileFormat #endif #endif end subroutine SpatialMeanNode_Initialization subroutine SpatialMeanNode_Update ( self , mesh , bufferPosition , t ) use Physics use MPI_Process_Info use , intrinsic :: ieee_arithmetic , only : IEEE_Value , IEEE_QUIET_NAN implicit none class ( SpatialMeanNode_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition real ( kind = RP ) :: t ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , l , m , ierr , eID , pID integer , parameter :: NO_OF_VARIABLES_Sij = 9 integer , parameter :: U = 1 integer , parameter :: V = 2 integer , parameter :: W = 3 integer , parameter :: UU = 4 integer , parameter :: VV = 5 integer , parameter :: WW = 6 integer , parameter :: UV = 7 integer , parameter :: UW = 8 integer , parameter :: VW = 9 real ( kind = RP ) :: value , rhoInv , kappa real ( kind = RP ) , allocatable :: buff (:,:) #ifdef NAVIERSTOKES ! !        Update data based on interval !        ----------------------------- if ( self % intervalCount . EQ . 0 ) then self % bufferLine = self % bufferLine + 1 DO m = 1 , self % nVariables self % values (:, bufferPosition , m ) = 0_RP self % values ( 1 , bufferPosition , m ) = t DO l = 1 , self % nActive ! !                   Update the Node !                   ---------------- associate ( e => mesh % elements ( self % activeLoc ( 1 , l )) ) associate ( Q => e % storage % Q , S => e % storage , meanQ => e % storage % stats % data ) eID = self % activeLoc ( 1 , l ) i = self % activeLoc ( 2 , l ) j = self % activeLoc ( 3 , l ) k = self % activeLoc ( 4 , l ) pID = self % activeLoc ( 5 , l ) select case ( trim ( self % variable ( m ))) case ( \"density\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHO , i , j , k ) case ( \"pressure\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Pressure ( Q (:, i , j , k )) case ( \"ptotal\" ) value = POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k )) / POW2 ( Q ( IRHO , i , j , k )) ! Vabs**2 value = value / ( thermodynamics % gamma * ( thermodynamics % gamma - 1.0_RP ) * ( Q ( IRHOE , i , j , k ) / Q ( IRHO , i , j , k ) - 0.5_RP * value ) ) ! Mach &#94;2 value = Pressure ( Q (:, i , j , k )) * ( 1.0_RP + 0.5_RP * ( thermodynamics % gamma - 1.0_RP ) * value ) ** ( thermodynamics % gamma / ( thermodynamics % gamma - 1.0_RP )) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"velocity\" ) value = sqrt ( POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k ))) / Q ( IRHO , i , j , k ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"viscosity\" ) call get_laminar_mu_kappa ( Q (:, i , j , k ), value , kappa ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"omegax\" ) value = ( 1 / Q ( IRHO , i , j , k ) * S % U_y ( IRHOW , i , j , k ) - Q ( IRHOW , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_y ( IRHO , i , j , k )) & - ( 1 / Q ( IRHO , i , j , k ) * S % U_z ( IRHOV , i , j , k ) - Q ( IRHOV , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_z ( IRHO , i , j , k )) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"omegay\" ) value = ( 1 / Q ( IRHO , i , j , k ) * S % U_z ( IRHOU , i , j , k ) - Q ( IRHOU , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_z ( IRHO , i , j , k )) & - ( 1 / Q ( IRHO , i , j , k ) * S % U_x ( IRHOW , i , j , k ) - Q ( IRHOW , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_x ( IRHO , i , j , k )) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"omegaz\" ) value = ( 1 / Q ( IRHO , i , j , k ) * S % U_x ( IRHOV , i , j , k ) - Q ( IRHOV , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_x ( IRHO , i , j , k )) & - ( 1 / Q ( IRHO , i , j , k ) * S % U_y ( IRHOU , i , j , k ) - Q ( IRHOU , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_y ( IRHO , i , j , k )) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"u\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOU , i , j , k ) / Q ( IRHO , i , j , k ) case ( \"v\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOV , i , j , k ) / Q ( IRHO , i , j , k ) case ( \"w\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOW , i , j , k ) / Q ( IRHO , i , j , k ) case ( \"mach\" ) value = POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k )) / POW2 ( Q ( IRHO , i , j , k )) ! Vabs**2 value = sqrt ( value / ( thermodynamics % gamma * ( thermodynamics % gamma - 1.0_RP ) * ( Q ( IRHOE , i , j , k ) / Q ( IRHO , i , j , k ) - 0.5_RP * value ) ) ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"k\" ) value = 0.5_RP * ( POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k ))) / Q ( IRHO , i , j , k ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + value case ( \"q1\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHO , i , j , k ) case ( \"q2\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOU , i , j , k ) case ( \"q3\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOV , i , j , k ) case ( \"q4\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOW , i , j , k ) case ( \"q5\" ) self % values ( pID + 1 , bufferPosition , m ) = self % values ( pID + 1 , bufferPosition , m ) + Q ( IRHOE , i , j , k ) end select end associate end associate END DO !           Combine all result from all proc MPI into root !           ---------------------------------------------- #ifdef _HAS_MPI_ call mpi_barrier ( MPI_COMM_WORLD , ierr ) ALLOCATE ( buff ( self % nUniqueAll , MPI_Process % nProcs )) call mpi_allgather ( self % values ( 2 : self % nUniqueAll + 1 , bufferPosition , m ), self % nUniqueAll , MPI_DOUBLE , buff , self % nUniqueAll , MPI_DOUBLE , MPI_COMM_WORLD , ierr ) self % values ( 2 : self % nUniqueAll + 1 , bufferPosition , m ) = SUM ( buff , DIM = 2 ) DEALLOCATE ( buff ) #endif !           Average with the number of data !           ------------------------------- do i = 1 , self % nUniqueAll self % values ( i + 1 , bufferPosition , m ) = self % values ( i + 1 , bufferPosition , m ) / self % nMultiplyAll ( i ) end do end do if ( self % meanData ) then self % meanU = self % values ( 2 : self % nUniqueAll + 1 , bufferPosition , self % iVarU ) self % meanV = self % values ( 2 : self % nUniqueAll + 1 , bufferPosition , self % iVarV ) self % meanW = self % values ( 2 : self % nUniqueAll + 1 , bufferPosition , self % iVarW ) end if end if self % intervalCount = self % intervalCount + 1 if ( self % intervalCount . EQ . self % interval ) then self % intervalCount = 0 end if #endif end subroutine SpatialMeanNode_Update subroutine SpatialMeanNode_WriteToFile ( self , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( SpatialMeanNode_t ) :: self integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , ierr integer :: fID if ( MPI_Process % isRoot ) then DO j = 1 , self % nVariables open ( newunit = fID , file = trim ( self % fileName ( j ) ) , action = \"write\" , access = \"stream\" , status = \"old\" , position = 'append' ) do i = 1 , no_of_lines write ( fID ) self % values (:, i , j ) end do close ( fID ) END DO end if if ( no_of_lines . ne . 0 ) self % values (:, 1 ,:) = self % values (:, no_of_lines ,:) self % bufferLine = 0 self % values = 0_RP end subroutine SpatialMeanNode_WriteToFile subroutine SpatialMeanNode_LookForUniqueCoordinate ( self , mesh ) use MPI_Process_Info implicit none class ( SpatialMeanNode_t ) :: self class ( HexMesh ) :: mesh ! !        --------------- !        Local variables !        --------------- ! integer :: eID , i , j , k , l , nPotentialUnique , nUnique , nCount integer , allocatable :: uniqueProcs (:), activeLoc (:,:) integer :: ierr real ( kind = RP ), allocatable :: yUnique (:), yFinal (:), yUniqueProc (:,:) real ( kind = RP ) :: error = 0.000001 real ( kind = RP ) :: buff , y logical :: unique , finish ! !        Obtain the direction at which spatial mean is not applied and store the coordinate !        ---------------------------------------------------------------------------------- nPotentialUnique = 0 do eID = 1 , mesh % no_of_elements associate ( e => mesh % elements ( eID )) nPotentialUnique = nPotentialUnique + ( e % Nxyz ( self % dirAxis ) + 1 ) * ( e % Nxyz ( 1 ) + 1 ) !nPotentialUnique Points end associate end do ALLOCATE ( activeLoc ( 1 : 5 , mesh % NDOF ), yUnique ( nPotentialUnique )) nUnique = 0 nCount = 0 do eID = 1 , mesh % no_of_elements if (. not .(( any ( mesh % elements ( eID ) % geom % x ( 1 ,:,:,:). gt .( self % pmin ( 1 ) - error ))) & . and .( any ( mesh % elements ( eID ) % geom % x ( 1 ,:,:,:). lt .( self % pmax ( 1 ) + error ))))) then cycle end if if (. not .(( any ( mesh % elements ( eID ) % geom % x ( 2 ,:,:,:). gt .( self % pmin ( 2 ) - error ))) & . and .( any ( mesh % elements ( eID ) % geom % x ( 2 ,:,:,:). lt .( self % pmax ( 2 ) + error ))))) then cycle end if if (. not .(( any ( mesh % elements ( eID ) % geom % x ( 3 ,:,:,:). gt .( self % pmin ( 3 ) - error ))) & . and .( any ( mesh % elements ( eID ) % geom % x ( 3 ,:,:,:). lt .( self % pmax ( 3 ) + error ))))) then cycle end if associate ( e => mesh % elements ( eID )) do i = 0 , e % Nxyz ( 3 ); do j = 0 , e % Nxyz ( 2 ); do k = 0 , e % Nxyz ( 1 ) if (. not .((( e % geom % x ( 1 , k , j , i )). gt .( self % pmin ( 1 ) - error )) & . and .(( e % geom % x ( 1 , k , j , i )). lt .( self % pmax ( 1 ) + error )))) cycle if (. not .((( e % geom % x ( 2 , k , j , i )). gt .( self % pmin ( 2 ) - error )) & . and .(( e % geom % x ( 2 , k , j , i )). lt .( self % pmax ( 2 ) + error )))) cycle if (. not .((( e % geom % x ( 3 , k , j , i )). gt .( self % pmin ( 3 ) - error )) & . and .(( e % geom % x ( 3 , k , j , i )). lt .( self % pmax ( 3 ) + error )))) cycle ! !                   Store the location of the active node ( within the bounded x,y,z ) !                   ------------------------------------------------------------------ nCount = nCount + 1 activeLoc ( 1 , nCount ) = eID activeLoc ( 2 , nCount ) = k activeLoc ( 3 , nCount ) = j activeLoc ( 4 , nCount ) = i ! !                   Find the unique points !                   ---------------------- y = e % geom % x ( self % dirAxis , k , j , i ) unique = . true . do l = 1 , nUnique if ( abs ( yUnique ( l ) - y ). lt . error ) then unique = . false . exit end if end do if ( unique ) then nUnique = nUnique + 1 yUnique ( nUnique ) = y end if end do ; end do ; end do end associate end do ALLOCATE ( yFinal ( nUnique ), self % activeLoc ( 5 , nCount )) self % nActive = nCount yFinal = yUnique ( 1 : nUnique ) self % activeLoc ( 1 : 4 ,:) = activeLoc ( 1 : 4 , 1 : nCount ) DEALLOCATE ( yUnique , activeLoc ) ! !        MPI Operation to combine operation from different MPI !        ----------------------------------------------------- #ifdef _HAS_MPI_ ALLOCATE ( uniqueProcs ( MPI_Process % nProcs )) ! !           Gather all data from all processes !           ---------------------------------- call mpi_allgather ( nUnique , 1 , MPI_INT , uniqueProcs , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) nPotentialUnique = sum ( uniqueProcs ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) ! !           Send unique coordinate on each proc to every proc with allgather !           ---------------------------------------------------------------- ALLOCATE ( yUnique ( maxval ( uniqueProcs ))) ALLOCATE ( yUniqueProc ( maxval ( uniqueProcs ), MPI_Process % nProcs )) yUnique = 0_RP yUnique ( 1 : nUnique ) = yFinal call mpi_allgather ( yUnique , maxval ( uniqueProcs ), MPI_DOUBLE , yUniqueProc , maxval ( uniqueProcs ), MPI_DOUBLE , MPI_COMM_WORLD , ierr ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) nCount = uniqueProcs ( 1 ) DEALLOCATE ( yUnique ) ALLOCATE ( yUnique ( nPotentialUnique )) yUnique ( 1 : nCount ) = yUniqueProc ( 1 : nCount , 1 ) do i = 2 , MPI_Process % nProcs do j = 1 , uniqueProcs ( i ) unique = . true . if ( any (( yUnique - yUniqueProc ( j , i )). lt . error )) then unique = . false . cycle end if if ( unique ) then nCount = nCount + 1 yUnique ( nCount ) = yUniqueProc ( j , i ) end if end do end do DEALLOCATE ( yFinal , yUniqueProc ) ALLOCATE ( yFinal ( 1 : nCount )) yFinal = yUnique ( 1 : nCount ) DEALLOCATE ( yUnique ) ! !           Sort the coordinate in ascending order !           -------------------------------------- CALL sortDoubleArrayMinMax ( nCount , yFinal , 0 ) self % nUniqueAll = nCount call mpi_barrier ( MPI_COMM_WORLD , ierr ) #else self % nUniqueAll = nUnique #endif ALLOCATE ( self % values ( self % nUniqueAll + 1 , self % bufferSize , self % nVariables ), self % geom ( self % nUniqueAll ), & self % nMultiply ( self % nUniqueAll ), self % nMultiplyAll ( self % nUniqueAll )) self % geom = yFinal ! !           Assign location of all active node w.r.t. unique coordinate location !           -------------------------------------------------------------------- self % nMultiply = 0 do i = 1 , self % nActive eID = self % activeLoc ( 1 , i ) do j = 1 , self % nUniqueAll buff = mesh % elements ( eID ) % geom % x ( self % dirAxis , self % activeLoc ( 2 , i ), self % activeLoc ( 3 , i ), self % activeLoc ( 4 , i )) if ( abs ( buff - self % geom ( j )). lt . error ) then self % nMultiply ( j ) = self % nMultiply ( j ) + 1 ! Local for each proc self % activeLoc ( 5 , i ) = j exit end if end do end do #ifdef _HAS_MPI_ ! !           Gather nMultiply to be combined into nMultiplyAll in root !           --------------------------------------------------------- self % nMultiplyAll = 0 ALLOCATE ( activeLoc ( self % nUniqueAll , MPI_Process % nProcs )) call mpi_allgather ( self % nMultiply , self % nUniqueAll , MPI_INT , activeLoc , self % nUniqueAll , MPI_INT , MPI_COMM_WORLD , ierr ) self % nMultiplyAll = sum ( activeLoc , DIM = 2 ) DEALLOCATE ( activeLoc ) #else self % nMultiplyAll = self % nMultiply #endif end subroutine SpatialMeanNode_LookForUniqueCoordinate ! !//////////////////////////////////////////////////////////////////////// ! ! This Recursive Subroutine sort Double ArraySet at nColumn from its Minimum to Maximum Value ! When call for the first time k must be set to 0 -- WARNING DO NOT USE FOR HUGE ARRAY ! RECURSIVE SUBROUTINE sortDoubleArrayMinMax ( sizeArray , ArraySet , k ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: sizeArray REAL ( kind = RP ) , DIMENSION ( 1 : sizeArray ) , INTENT ( INOUT ) :: ArraySet INTEGER , INTENT ( IN ) :: k ! !        --------------- !        Local variables !        --------------- ! REAL ( kind = RP ) :: BufferSet INTEGER :: i ! !        --------------- !        Perform Sorting Value !        --------------- ! SELECT CASE ( k ) CASE ( 0 ) DO i = 1 , sizeArray - 1 IF ( ArraySet ( i ). GT . ArraySet ( i + 1 )) THEN BufferSet = ArraySet ( i ) ArraySet ( i ) = ArraySet ( i + 1 ) ArraySet ( i + 1 ) = BufferSet IF ( i . GT . 1 ) THEN CALL sortDoubleArrayMinMax ( sizeArray , ArraySet , i ) END IF END IF END DO CASE DEFAULT ! For Recursive IF ( ArraySet ( k - 1 ). GT . ArraySet ( k )) THEN BufferSet = ArraySet ( k - 1 ) ArraySet ( k - 1 ) = ArraySet ( k ) ArraySet ( k ) = BufferSet IF ( k . GT . 2 ) THEN CALL sortDoubleArrayMinMax ( sizeArray , ArraySet , k - 1 ) END IF END IF END SELECT END SUBROUTINE sortDoubleArrayMinMax elemental subroutine SpatialMeanNode_Destruct ( self ) implicit none class ( SpatialMeanNode_t ), intent ( inout ) :: self safedeallocate ( self % activeLoc ) safedeallocate ( self % nMultiply ) safedeallocate ( self % nMultiplyAll ) safedeallocate ( self % geom ) safedeallocate ( self % values ) safedeallocate ( self % meanU ) safedeallocate ( self % meanV ) safedeallocate ( self % meanW ) safedeallocate ( self % fileName ) safedeallocate ( self % variable ) end subroutine SpatialMeanNode_Destruct elemental subroutine SpatialMeanNode_Assign ( to , from ) implicit none class ( SpatialMeanNode_t ), intent ( inout ) :: to type ( SpatialMeanNode_t ) , intent ( in ) :: from to % ID = from % ID to % nVariables = from % nVariables to % interval = from % interval to % bufferSize = from % bufferSize to % bufferLine = from % bufferLine to % intervalCount = from % intervalCount to % nActive = from % nActive to % dirAxis = from % dirAxis to % nUniqueAll = from % nUniqueAll to % pmin = from % pmin to % pmax = from % pmax to % error = from % error safedeallocate ( to % activeLoc ) allocate ( to % activeLoc ( size ( from % activeLoc , 1 ), size ( from % activeLoc , 2 ) ) ) to % activeLoc = from % activeLoc safedeallocate ( to % nMultiply ) allocate ( to % nMultiply ( size ( from % nMultiply ) ) ) to % nMultiply = from % nMultiply safedeallocate ( to % nMultiplyAll ) allocate ( to % nMultiplyAll ( size ( from % nMultiplyAll ) ) ) to % nMultiplyAll = from % nMultiplyAll safedeallocate ( to % geom ) allocate ( to % geom ( size ( from % geom ) ) ) to % geom = from % geom safedeallocate ( to % values ) allocate ( to % values ( size ( from % values , 1 ), size ( from % values , 2 ), size ( from % values , 3 ) ) ) to % values = from % values safedeallocate ( to % fileName ) allocate ( to % fileName ( size ( from % fileName ) ) ) to % fileName = from % fileName to % spatialMeanName = from % spatialMeanName safedeallocate ( to % variable ) allocate ( to % variable ( size ( from % variable ) ) ) to % variable = from % variable end subroutine SpatialMeanNode_Assign end module SpatialMeanNode","tags":"","url":"sourcefile/spatialmeannode.f90.html"},{"title":"SamplingOperator.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module SamplingOperator use SMConstants use PhysicsStorage use Physics use FaceClass use ElementClass use HexMeshClass use FluidData use VariableConversion use NodalStorageClass #ifdef _HAS_MPI_ use mpi #endif implicit none private public SHEAR_STRESS_TANGENT , SHEAR_STRESS_X , SHEAR_STRESS_Y , SHEAR_STRESS_Z , PRESSURE_SURF , Q1 , Q2 , Q3 , Q4 , Q5 public VectorSurfaceSampling integer , parameter :: SHEAR_STRESS_TANGENT = 1 integer , parameter :: SHEAR_STRESS_X = 2 integer , parameter :: SHEAR_STRESS_Y = 3 integer , parameter :: SHEAR_STRESS_Z = 4 integer , parameter :: PRESSURE_SURF = 5 integer , parameter :: Q1 = 6 integer , parameter :: Q2 = 7 integer , parameter :: Q3 = 8 integer , parameter :: Q4 = 9 integer , parameter :: Q5 = 10 integer , parameter :: USER_DEFINED = 99 ! !  ======== contains !  ======== ! !           SUBROUTINE TO GET CONSTRUCT THE DATA !//////////////////////////////////////////////////////////////////////////////////////// ! subroutine VectorSurfaceSampling ( mesh , zoneID , integralType , monitorName , data_out ) use MonitorDefinitions #ifdef _HAS_MPI_ use mpi #endif implicit none class ( HexMesh ), intent ( inout ), target :: mesh integer , intent ( in ) :: zoneID integer , intent ( in ) :: integralType real ( kind = RP ), allocatable , intent ( out ) :: data_out (:) ! !        --------------- !        Local variables !        --------------- ! integer :: zonefID , fID , eID , fIDs ( 6 ), ierr , Nx , Ny , fsID class ( Element ), pointer :: elements (:) real ( kind = RP ) , allocatable :: data_proc (:) logical :: file_exists character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: monitorName ! !        Get the number of Order and the sampling interval !        ------------------------------------------------- if ( mesh % zones ( zoneID ) % no_of_faces . gt . 0 ) then Nx = mesh % faces ( mesh % zones ( zoneID ) % faces ( 1 ))% Nf ( 1 ) + 1 Ny = mesh % faces ( mesh % zones ( zoneID ) % faces ( 1 ))% Nf ( 2 ) + 1 else Nx = 0 Ny = 0 end if ALLOCATE ( data_out ( Nx * Ny * mesh % zones ( zoneID ) % no_of_faces ), data_proc ( Nx * Ny )) ! !        ************************* !        Perform the interpolation !        ************************* ! #if defined(NAVIERSTOKES) && (!(INCNS)) elements => mesh % elements !$omp parallel private(fID, eID, fIDs,data_proc) shared(elements,mesh,NodalStorage,zoneID,integralType,& !$omp&                                        computeGradients,data_out,Nx) !$omp single do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces fID = mesh % zones ( zoneID ) % faces ( zonefID ) eID = mesh % faces ( fID ) % elementIDs ( 1 ) fIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) if ( computeGradients ) then call elements ( eID ) % ProlongGradientsToFaces ( NGRAD , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) end if !$omp end task end do !$omp end single ! !        Loop the zone to get faces and elements !        --------------------------------------- !$omp do  private(fID,data_proc) schedule(runtime) do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( zoneID ) % faces ( zonefID ) ! !           Compute the integral !           -------------------- CALL VectorSurfaceSampling_Face ( mesh % faces ( fID ), integralType , fID , data_proc ) data_out (( zonefID - 1 ) * Nx * Ny + 1 : zonefID * Nx * Ny ) = data_proc end do !$omp end do !$omp end parallel #endif end subroutine VectorSurfaceSampling ! !           SUBROUTINE TO GET CONSTRUCT THE DATA in a FACE !//////////////////////////////////////////////////////////////////////////////////////// ! subroutine VectorSurfaceSampling_Face ( f , integralType , fID , data_out ) implicit none class ( Face ), intent ( in ) :: f integer , intent ( in ) :: integralType , fID real ( kind = RP ) , intent ( out ) :: data_out ( 1 :(( f % Nf ( 1 ) + 1 ) * ( f % Nf ( 2 ) + 1 ))) ! !        --------------- !        Local variables !        --------------- ! integer :: i , j ! Face indices integer :: k real ( kind = RP ) :: p , tau ( NDIM , NDIM ) type ( NodalStorage_t ), pointer :: spAxi , spAeta real ( kind = RP ) :: shear ( NDIM ) real ( kind = RP ) :: shearTangent ! !        Initialization !        -------------- spAxi => NodalStorage ( f % Nf ( 1 )) spAeta => NodalStorage ( f % Nf ( 2 )) ! !        Perform the numerical integration !        --------------------------------- associate ( Q => f % storage ( 1 ) % Q , & U_x => f % storage ( 1 ) % U_x , & U_y => f % storage ( 1 ) % U_y , & U_z => f % storage ( 1 ) % U_z ) select case ( integralType ) #if defined(NAVIERSTOKES) && (!(INCNS)) ! !           ************************************************* !           Computes the shear stress, tangent to the surface !           ************************************************* ! case ( SHEAR_STRESS_TANGENT ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 ! !              Get the stress tensor and the tangent component !              ---------------------------------------------- call getStressTensor ( Q (:, i , j ), U_x (:, i , j ), U_y (:, i , j ), U_z (:, i , j ), tau ) shear =- matmul ( tau , f % geom % normal (:, i , j )) * POW2 ( refValues % V ) * refValues % rho shearTangent = dot_product ( shear , f % geom % t1 (:, i , j )) data_out ( k ) = shearTangent end do ; end do ! !           ********************************************* !           Computes the shear stress, in the x direction !           ********************************************* ! case ( SHEAR_STRESS_X ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 ! !              Get the stress tensor and the tangent component !              ---------------------------------------------- call getStressTensor ( Q (:, i , j ), U_x (:, i , j ), U_y (:, i , j ), U_z (:, i , j ), tau ) shear =- matmul ( tau , f % geom % normal (:, i , j )) * POW2 ( refValues % V ) * refValues % rho data_out ( k ) = shear ( 1 ) end do ; end do ! !           ********************************************* !           Computes the shear stress, in the x direction !           ********************************************* ! case ( SHEAR_STRESS_Y ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 ! !              Get the stress tensor !              --------------------- call getStressTensor ( Q (:, i , j ), U_x (:, i , j ), U_y (:, i , j ), U_z (:, i , j ), tau ) shear =- matmul ( tau , f % geom % normal (:, i , j )) * POW2 ( refValues % V ) * refValues % rho data_out ( k ) = shear ( 2 ) end do ; end do ! !           ********************************************* !           Computes the shear stress, in the x direction !           ********************************************* ! case ( SHEAR_STRESS_Z ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 ! !              Get the stress tensor !              --------------------- call getStressTensor ( Q (:, i , j ), U_x (:, i , j ), U_y (:, i , j ), U_z (:, i , j ), tau ) shear =- matmul ( tau , f % geom % normal (:, i , j )) * POW2 ( refValues % V ) * refValues % rho data_out ( k ) = shear ( 3 ) end do ; end do ! !           ********************************************* !           Computes the shear stress, in the x direction !           ********************************************* ! case ( PRESSURE_SURF ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 ! !              Get the pressure !              --------------------- data_out ( k ) = Pressure ( Q (:, i , j )) * POW2 ( refValues % V ) * refValues % rho end do ; end do case ( Q1 ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 data_out ( k ) = Q ( 1 , i , j ) end do ; end do case ( Q2 ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 data_out ( k ) = Q ( 2 , i , j ) end do ; end do case ( Q3 ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 data_out ( k ) = Q ( 3 , i , j ) end do ; end do case ( Q4 ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 data_out ( k ) = Q ( 4 , i , j ) end do ; end do case ( Q5 ) k = 0 do j = 0 , f % Nf ( 2 ); do i = 0 , f % Nf ( 1 ) k = k + 1 data_out ( k ) = Q ( 5 , i , j ) end do ; end do #endif end select end associate nullify ( spAxi , spAeta ) end subroutine VectorSurfaceSampling_Face end module SamplingOperator","tags":"","url":"sourcefile/samplingoperator.f90.html"},{"title":"Monitors.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module MonitorsClass use SMConstants use NodalStorageClass use HexMeshClass use MonitorDefinitions use ResidualsMonitorClass use VolumeMonitorClass use LoadBalancingMonitorClass use FileReadingUtilities , only : getFileName #ifdef FLOW use ProbeClass #endif #if defined(NAVIERSTOKES) || defined(INCNS) use StatisticsMonitor use SurfaceMonitorClass #endif implicit none ! private public Monitor_t ! !  ***************************** !  Main monitor class definition !  ***************************** ! type Monitor_t character ( len = LINE_LENGTH ) :: solution_file integer :: no_of_probes integer :: no_of_surfaceMonitors integer :: no_of_volumeMonitors integer :: no_of_loadBalancingMonitors integer :: bufferLine integer , allocatable :: iter (:) integer :: dt_restriction logical :: write_dt_restriction real ( kind = RP ) , allocatable :: t (:) real ( kind = RP ) , allocatable :: SolverSimuTime (:) real ( kind = RP ) , allocatable :: TotalSimuTime (:) type ( Residuals_t ) :: residuals class ( VolumeMonitor_t ) , allocatable :: volumeMonitors (:) class ( LoadBalancingMonitor_t ), allocatable :: loadBalancingMonitors (:) #ifdef FLOW class ( Probe_t ) , allocatable :: probes (:) #endif #if defined(NAVIERSTOKES) || defined(INCNS) class ( SurfaceMonitor_t ) , allocatable :: surfaceMonitors (:) type ( StatisticsMonitor_t ) :: stats #endif contains procedure :: Construct => Monitors_Construct procedure :: WriteLabel => Monitor_WriteLabel procedure :: WriteUnderlines => Monitor_WriteUnderlines procedure :: WriteValues => Monitor_WriteValues procedure :: UpdateValues => Monitor_UpdateValues procedure :: WriteToFile => Monitor_WriteToFile procedure :: destruct => Monitor_Destruct procedure :: copy => Monitor_Assign generic :: assignment ( = ) => copy end type Monitor_t ! !  ======== contains !  ======== ! !/////////////////////////////////////////////////////////////////////////////////////// ! subroutine Monitors_Construct ( Monitors , mesh , controlVariables ) use FTValueDictionaryClass use mainKeywordsModule implicit none class ( Monitor_t ) :: Monitors class ( HexMesh ), intent ( in ) :: mesh class ( FTValueDictionary ), intent ( in ) :: controlVariables ! !        --------------- !        Local variables !        --------------- ! integer :: fID , io integer :: i character ( len = STR_LEN_MONITORS ) :: line character ( len = STR_LEN_MONITORS ) :: solution_file logical , save :: FirstCall = . TRUE . logical :: saveGradients ! !        Setup the buffer !        ---------------- if ( controlVariables % containsKey ( \"monitors flush interval\" ) ) then BUFFER_SIZE = controlVariables % integerValueForKey ( \"monitors flush interval\" ) end if allocate ( Monitors % TotalSimuTime ( BUFFER_SIZE ), & Monitors % SolverSimuTime ( BUFFER_SIZE ), & Monitors % t ( BUFFER_SIZE ), & Monitors % iter ( BUFFER_SIZE ) ) ! !        Get the solution file name !        -------------------------- solution_file = controlVariables % stringValueForKey ( solutionFileNameKey , requestedLength = STR_LEN_MONITORS ) ! !        Remove the *.hsol termination !        ----------------------------- solution_file = trim ( getFileName ( solution_file )) Monitors % solution_file = trim ( solution_file ) ! !        Search in case file for probes, surface monitors, and volume monitors !        --------------------------------------------------------------------- if ( mesh % child ) then ! Return doing nothing if this is a child mesh Monitors % no_of_probes = 0 Monitors % no_of_surfaceMonitors = 0 Monitors % no_of_volumeMonitors = 0 Monitors % no_of_loadBalancingMonitors = 0 else call getNoOfMonitors ( Monitors % no_of_probes , Monitors % no_of_surfaceMonitors , Monitors % no_of_volumeMonitors , Monitors % no_of_loadBalancingMonitors ) end if ! !        Initialize !        ---------- call Monitors % residuals % Initialization ( solution_file , FirstCall ) allocate ( Monitors % volumeMonitors ( Monitors % no_of_volumeMonitors ) ) do i = 1 , Monitors % no_of_volumeMonitors call Monitors % volumeMonitors ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do allocate ( Monitors % loadBalancingMonitors ( Monitors % no_of_loadBalancingMonitors ) ) do i = 1 , Monitors % no_of_loadBalancingMonitors call Monitors % loadBalancingMonitors ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do #ifdef FLOW allocate ( Monitors % probes ( Monitors % no_of_probes ) ) do i = 1 , Monitors % no_of_probes call Monitors % probes ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) saveGradients = controlVariables % logicalValueForKey ( saveGradientsToSolutionKey ) call Monitors % stats % Construct ( mesh , saveGradients ) allocate ( Monitors % surfaceMonitors ( Monitors % no_of_surfaceMonitors ) ) do i = 1 , Monitors % no_of_surfaceMonitors call Monitors % surfaceMonitors ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do #endif Monitors % write_dt_restriction = controlVariables % logicalValueForKey ( \"write dt restriction\" ) Monitors % bufferLine = 0 FirstCall = . FALSE . end subroutine Monitors_Construct subroutine Monitor_WriteLabel ( self ) ! !        *************************************************** !           This subroutine prints the labels for the time !         integrator Display procedure. !        *************************************************** ! use MPI_Process_Info implicit none class ( Monitor_t ) :: self integer :: i if ( . not . MPI_Process % isRoot ) return ! !        Write \"Iteration\" and \"Time\" !        ---------------------------- write ( STD_OUT , ' ( A10    ) ' , advance = \"no\" ) \"Iteration\" write ( STD_OUT , ' ( 3X,A10 ) ' , advance = \"no\" ) \"Time\" ! !        Write residuals labels !        ---------------------- call self % residuals % WriteLabel ! !        Write volume monitors labels !        ----------------------------- do i = 1 , self % no_of_volumeMonitors call self % volumeMonitors ( i ) % WriteLabel end do ! !        Write load balancing monitor labels !        ------------------------------------ do i = 1 , self % no_of_loadBalancingMonitors call self % loadBalancingMonitors ( i ) % WriteLabel end do #ifdef FLOW ! !        Write probes labels !        ------------------- do i = 1 , self % no_of_probes call self % probes ( i ) % WriteLabel end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) ! !        Write surface monitors labels !        ----------------------------- do i = 1 , self % no_of_surfaceMonitors call self % surfaceMonitors ( i ) % WriteLabel end do call self % stats % WriteLabel #endif ! !        Write label for dt restriction !        ------------------------------ if ( self % write_dt_restriction ) write ( STD_OUT , ' ( 3X,A10 ) ' , advance = \"no\" ) \"dt restr.\" write ( STD_OUT , * ) end subroutine Monitor_WriteLabel subroutine Monitor_WriteUnderlines ( self ) ! !        ******************************************************** !              This subroutine displays the underlines for the !           time integrator Display procedure. !        ******************************************************** ! use PhysicsStorage use MPI_Process_Info implicit none class ( Monitor_t ) :: self ! !        --------------- !        Local variables !        --------------- ! integer :: i , j character ( len = MONITOR_LENGTH ), parameter :: dashes = \"----------\" if ( . not . MPI_Process % isRoot ) return ! !        Print dashes for \"Iteration\" and \"Time\" !        --------------------------------------- write ( STD_OUT , ' ( A10    ) ' , advance = \"no\" ) trim ( dashes ) write ( STD_OUT , ' ( 3X,A10 ) ' , advance = \"no\" ) trim ( dashes ) ! !        Print dashes for residuals !        -------------------------- do i = 1 , NCONS write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) trim ( dashes ) end do ! !        Print dashes for volume monitors !        -------------------------------- do i = 1 , self % no_of_volumeMonitors ; do j = 1 , size ( self % volumeMonitors ( i ) % values , 1 ) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) dashes ( 1 : min ( 10 , len_trim ( self % volumeMonitors ( i ) % monitorName ) + 2 ) ) end do ; end do ! !        Print dashes for load balancing monitor !        -------------------------------------- do i = 1 , self % no_of_loadBalancingMonitors ; do j = 1 , size ( self % loadBalancingMonitors ( i ) % values , 1 ) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) dashes ( 1 : min ( 10 , len_trim ( self % loadBalancingMonitors ( i ) % monitorName ) + 2 ) ) end do ; end do #ifdef FLOW ! !        Print dashes for probes !        ----------------------- do i = 1 , self % no_of_probes if ( self % probes ( i ) % active ) then write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) dashes ( 1 : min ( 10 , len_trim ( self % probes ( i ) % monitorName ) + 2 ) ) end if end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) ! !        Print dashes for surface monitors !        --------------------------------- do i = 1 , self % no_of_surfaceMonitors write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) dashes ( 1 : min ( 10 , len_trim ( self % surfaceMonitors ( i ) % monitorName ) + 2 ) ) end do if ( self % stats % state . ne . 0 ) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) trim ( dashes ) #endif ! !        Print dashes for dt restriction !        ------------------------------- if ( self % write_dt_restriction ) write ( STD_OUT , ' ( 3X,A10 ) ' , advance = \"no\" ) trim ( dashes ) write ( STD_OUT , * ) end subroutine Monitor_WriteUnderlines subroutine Monitor_WriteValues ( self ) ! !        ******************************************************* !              This subroutine prints the values for the time !           integrator Display procedure. !        ******************************************************* ! use MPI_Process_Info implicit none class ( Monitor_t ) :: self integer :: i if ( . not . MPI_Process % isRoot ) return ! !        Print iteration and time !        ------------------------ write ( STD_OUT , ' ( I10            ) ' , advance = \"no\" ) self % iter ( self % bufferLine ) write ( STD_OUT , ' ( 1X,A,1X,ES10.3 ) ' , advance = \"no\" ) \"|\" , self % t ( self % bufferLine ) ! !        Print residuals !        --------------- call self % residuals % WriteValues ( self % bufferLine ) ! !        Print volume monitors !        --------------------- do i = 1 , self % no_of_volumeMonitors call self % volumeMonitors ( i ) % WriteValues ( self % bufferLine ) end do ! !        Print load balancing monitors !        ----------------------------- do i = 1 , self % no_of_loadBalancingMonitors call self % loadBalancingMonitors ( i ) % WriteValues ( self % bufferLine ) end do #ifdef FLOW ! !        Print probes !        ------------ do i = 1 , self % no_of_probes call self % probes ( i ) % WriteValues ( self % bufferLine ) end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) ! !        Print surface monitors !        ---------------------- do i = 1 , self % no_of_surfaceMonitors call self % surfaceMonitors ( i ) % WriteValues ( self % bufferLine ) end do call self % stats % WriteValue #endif ! !        Print dt restriction !        -------------------- if ( self % write_dt_restriction ) then select case ( self % dt_restriction ) case ( DT_FIXED ) ; write ( STD_OUT , ' ( 1X,A,1X,A10) ' , advance = \"no\" ) \"|\" , 'Fixed' case ( DT_DIFF ) ; write ( STD_OUT , ' ( 1X,A,1X,A10) ' , advance = \"no\" ) \"|\" , 'Diffusive' case ( DT_CONV ) ; write ( STD_OUT , ' ( 1X,A,1X,A10) ' , advance = \"no\" ) \"|\" , 'Convective' end select end if write ( STD_OUT , * ) end subroutine Monitor_WriteValues subroutine Monitor_UpdateValues ( self , mesh , t , iter , maxResiduals , Autosave , dt ) ! !        *************************************************************** !              This subroutine updates the values for the residuals, !           for the probes, surface and volume monitors. !        *************************************************************** ! use PhysicsStorage use StopwatchClass implicit none class ( Monitor_t ) :: self class ( HexMesh ) :: mesh real ( kind = RP ) :: t integer :: iter real ( kind = RP ) :: maxResiduals ( NCONS ), dt logical :: Autosave ! !        --------------- !        Local variables !        --------------- ! integer :: i ! !        Move to next buffer line !        ------------------------ self % bufferLine = self % bufferLine + 1 ! !        Save time, iteration and CPU-time !        ----------------------- self % t ( self % bufferLine ) = t self % iter ( self % bufferLine ) = iter self % SolverSimuTime ( self % bufferLine ) = Stopwatch % ElapsedTime ( \"Solver\" ) self % TotalSimuTime ( self % bufferLine ) = Stopwatch % ElapsedTime ( \"TotalTime\" ) ! !        Compute current residuals !        ------------------------- call self % residuals % Update ( mesh , maxResiduals , self % bufferLine ) ! !        Update volume monitors !        ---------------------- do i = 1 , self % no_of_volumeMonitors call self % volumeMonitors ( i ) % Update ( mesh , self % bufferLine ) end do ! !        Update load balancing monitors !        ------------------------------ do i = 1 , self % no_of_loadBalancingMonitors call self % loadBalancingMonitors ( i ) % Update ( mesh , self % bufferLine ) end do #ifdef FLOW ! !        Update probes !        ------------- do i = 1 , self % no_of_probes call self % probes ( i ) % Update ( mesh , self % bufferLine ) end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) ! !        Update surface monitors !        ----------------------- do i = 1 , self % no_of_surfaceMonitors call self % surfaceMonitors ( i ) % Update ( mesh , self % bufferLine , iter , autosave , dt ) end do ! !        Update statistics !        ----------------- call self % stats % Update ( mesh , iter , t , trim ( self % solution_file ) ) #endif ! !        Update dt restriction !        --------------------- if ( self % write_dt_restriction ) self % dt_restriction = mesh % dt_restriction end subroutine Monitor_UpdateValues subroutine Monitor_WriteToFile ( self , mesh , force ) ! !        ****************************************************************** !              This routine has a double behaviour: !           force = .true.  -> Writes to file and resets buffers !           force = .false. -> Just writes to file if the buffer is full !        ****************************************************************** ! use MPI_Process_Info implicit none class ( Monitor_t ) :: self class ( HexMesh ) :: mesh logical , optional :: force !        ------------------------------------------------ integer :: i logical :: forceVal if ( present ( force ) ) then forceVal = force else forceVal = . false . end if if ( forceVal ) then ! !           In this case the monitors are exported to their files and the buffer is reset !           ----------------------------------------------------------------------------- call self % residuals % WriteToFile ( self % iter , self % t , self % TotalSimuTime , self % SolverSimuTime , self % bufferLine ) do i = 1 , self % no_of_volumeMonitors call self % volumeMonitors ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do do i = 1 , self % no_of_loadBalancingMonitors call self % loadBalancingMonitors ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do #ifdef FLOW do i = 1 , self % no_of_probes call self % probes ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) do i = 1 , self % no_of_surfaceMonitors call self % surfaceMonitors ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do ! !              Write statistics !              ---------------- if ( self % bufferLine . eq . 0 ) then i = 1 else i = self % bufferLine end if call self % stats % WriteFile ( mesh , self % iter ( i ), self % t ( i ), self % solution_file ) #endif ! !           Reset buffer !           ------------ self % bufferLine = 0 else ! !           The monitors are exported just if the buffer is full !           ---------------------------------------------------- if ( self % bufferLine . eq . BUFFER_SIZE ) then call self % residuals % WriteToFile ( self % iter , self % t , self % TotalSimuTime , self % SolverSimuTime , BUFFER_SIZE ) do i = 1 , self % no_of_volumeMonitors call self % volumeMonitors ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do do i = 1 , self % no_of_loadBalancingMonitors call self % loadBalancingMonitors ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do #ifdef FLOW do i = 1 , self % no_of_probes call self % probes ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do #endif #if defined(NAVIERSTOKES) || defined(INCNS) do i = 1 , self % no_of_surfaceMonitors call self % surfaceMonitors ( i ) % WriteToFile ( self % iter , self % t , self % bufferLine ) end do #endif ! !              Reset buffer !              ------------ self % bufferLine = 0 end if end if end subroutine Monitor_WriteToFile subroutine Monitor_Destruct ( self ) implicit none class ( Monitor_t ) :: self deallocate ( self % iter ) deallocate ( self % t ) deallocate ( self % TotalSimuTime ) deallocate ( self % SolverSimuTime ) call self % residuals % destruct call self % volumeMonitors % destruct safedeallocate ( self % volumeMonitors ) call self % loadBalancingMonitors % destruct safedeallocate ( self % loadBalancingMonitors ) #ifdef FLOW call self % probes % destruct safedeallocate ( self % probes ) #endif #if defined(NAVIERSTOKES) || defined(INCNS) call self % surfaceMonitors % destruct safedeallocate ( self % surfaceMonitors ) !call self % stats % destruct #endif end subroutine impure elemental subroutine Monitor_Assign ( to , from ) implicit none !-arguments-------------------------------------- class ( Monitor_t ), intent ( inout ) :: to type ( Monitor_t ) , intent ( in ) :: from !-local-variables-------------------------------- !------------------------------------------------ to % solution_file = from % solution_file to % no_of_probes = from % no_of_probes to % no_of_surfaceMonitors = from % no_of_surfaceMonitors to % no_of_volumeMonitors = from % no_of_volumeMonitors to % no_of_loadBalancingMonitors = from % no_of_loadBalancingMonitors to % bufferLine = from % bufferLine safedeallocate ( to % iter ) allocate ( to % iter ( size ( from % iter ) ) ) to % iter = from % iter to % dt_restriction = from % dt_restriction to % write_dt_restriction = from % write_dt_restriction safedeallocate ( to % t ) allocate ( to % t ( size ( from % t ) ) ) to % t = from % t safedeallocate ( to % TotalSimuTime ) allocate ( to % TotalSimuTime ( size ( from % TotalSimuTime ) ) ) to % TotalSimuTime = from % TotalSimuTime safedeallocate ( to % SolverSimuTime ) allocate ( to % SolverSimuTime ( size ( from % SolverSimuTime ) ) ) to % SolverSimuTime = from % SolverSimuTime to % residuals = from % residuals safedeallocate ( to % volumeMonitors ) allocate ( to % volumeMonitors ( size ( from % volumeMonitors ) ) ) to % volumeMonitors = from % volumeMonitors safedeallocate ( to % loadBalancingMonitors ) allocate ( to % loadBalancingMonitors ( size ( from % loadBalancingMonitors ) ) ) to % loadBalancingMonitors = from % loadBalancingMonitors #ifdef FLOW safedeallocate ( to % probes ) allocate ( to % probes ( size ( from % probes ) ) ) to % probes = from % probes #endif #if defined(NAVIERSTOKES) || defined(INCNS) safedeallocate ( to % surfaceMonitors ) allocate ( to % surfaceMonitors ( size ( from % surfaceMonitors ) ) ) to % surfaceMonitors = from % surfaceMonitors to % stats = from % stats #endif end subroutine Monitor_Assign ! !////////////////////////////////////////////////////////////////////////////// ! !        Auxiliars ! !////////////////////////////////////////////////////////////////////////////// ! subroutine getNoOfMonitors ( no_of_probes , no_of_surfaceMonitors , no_of_volumeMonitors , no_of_loadBalancingMonitors ) use ParamfileRegions implicit none integer , intent ( out ) :: no_of_probes integer , intent ( out ) :: no_of_surfaceMonitors integer , intent ( out ) :: no_of_volumeMonitors integer , intent ( out ) :: no_of_loadBalancingMonitors ! !     --------------- !     Local variables !     --------------- ! character ( len = LINE_LENGTH ) :: case_name , line integer :: fID integer :: io ! !     Initialize !     ---------- no_of_probes = 0 no_of_surfaceMonitors = 0 no_of_volumeMonitors = 0 no_of_loadBalancingMonitors = 0 ! !     Get case file name !     ------------------ call get_command_argument ( 1 , case_name ) ! !     Open case file !     -------------- open ( newunit = fID , file = case_name , status = \"old\" , action = \"read\" ) ! !     Read the whole file to find monitors !     ------------------------------------ readloop : do read ( fID , '(A)' , iostat = io ) line if ( io . lt . 0 ) then ! !           End of file !           ----------- line = \"\" exit readloop elseif ( io . gt . 0 ) then ! !           Error !           ----- errorMessage ( STD_OUT ) error stop \"Stopped.\" else ! !           Succeeded !           --------- line = getSquashedLine ( line ) if ( index ( line , '#defineprobe' ) . gt . 0 ) then no_of_probes = no_of_probes + 1 elseif ( index ( line , '#definesurfacemonitor' ) . gt . 0 ) then no_of_surfaceMonitors = no_of_surfaceMonitors + 1 elseif ( index ( line , '#definevolumemonitor' ) . gt . 0 ) then no_of_volumeMonitors = no_of_volumeMonitors + 1 elseif ( index ( line , '#defineloadbalancingmonitor' ) . gt . 0 ) then no_of_loadBalancingMonitors = no_of_loadBalancingMonitors + 1 end if end if end do readloop ! !     Close case file !     --------------- close ( fID ) end subroutine getNoOfMonitors end module MonitorsClass ! !/////////////////////////////////////////////////////////////////////////////////// !","tags":"","url":"sourcefile/monitors.f90.html"},{"title":"Samplings.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module Samplings use SMConstants use NodalStorageClass use HexMeshClass use MonitorDefinitions use FileReadingUtilities , only : getFileName use SurfaceSampling use PlaneSampling use SpatialMeanNode implicit none ! private public Sampling_t ! !  ***************************** !  Main sampling class definition !  ***************************** ! type Sampling_t character ( len = LINE_LENGTH ) :: solution_file integer :: no_of_surfaceSamplings = 0 integer :: no_of_planeSamplings = 0 integer :: no_of_spatialMeanNodes = 0 integer :: dt_restriction logical :: write_dt_restriction class ( SurfaceSampling_t ), allocatable :: surfaceSamplings (:) class ( PlaneSampling_t ), allocatable :: planeSamplings (:) class ( SpatialMeanNode_t ), allocatable :: spatialMeanNodes (:) contains procedure :: Construct => Samplings_Construct procedure :: UpdateInterp => Samplings_UpdateLagrangeInterp procedure :: UpdateValues => Sampling_UpdateValues procedure :: WriteToFile => Sampling_WriteToFile procedure :: destruct => Sampling_Destruct procedure :: copy => Sampling_Assign generic :: assignment ( = ) => copy end type Sampling_t ! !  ======== contains !  ======== ! !/////////////////////////////////////////////////////////////////////////////////////// ! subroutine Samplings_Construct ( Samplings , mesh , controlVariables ) use Headers use FTValueDictionaryClass use mainKeywordsModule implicit none class ( Sampling_t ) :: Samplings class ( HexMesh ), intent ( in ) :: mesh class ( FTValueDictionary ), intent ( in ) :: controlVariables ! !        --------------- !        Local variables !        --------------- ! integer :: fID , io integer :: i character ( len = STR_LEN_MONITORS ) :: line character ( len = STR_LEN_MONITORS ) :: solution_file logical , save :: FirstCall = . TRUE . ! !        Setup the buffer !        ---------------- if ( controlVariables % containsKey ( \"monitors flush interval\" ) ) then BUFFER_SIZE = controlVariables % integerValueForKey ( \"monitors flush interval\" ) end if ! !        Get the solution file name !        -------------------------- solution_file = controlVariables % stringValueForKey ( solutionFileNameKey , requestedLength = STR_LEN_MONITORS ) ! !        Remove the *.hsol termination !        ----------------------------- solution_file = trim ( getFileName ( solution_file )) Samplings % solution_file = trim ( solution_file ) ! !        Search in case file for samplings !        --------------------------------------------------------------------- if ( mesh % child ) then ! Return doing nothing if this is a child mesh Samplings % no_of_surfaceSamplings = 0 Samplings % no_of_planeSamplings = 0 Samplings % no_of_spatialMeanNodes = 0 else call getNoOfSamplings ( Samplings % no_of_surfaceSamplings , Samplings % no_of_planeSamplings , Samplings % no_of_spatialMeanNodes ) end if ! !        Initialize !        ---------- allocate ( Samplings % surfaceSamplings ( Samplings % no_of_surfaceSamplings ) ) allocate ( Samplings % planeSamplings ( Samplings % no_of_planeSamplings ) ) allocate ( Samplings % spatialMeanNodes ( Samplings % no_of_spatialMeanNodes ) ) if ( Samplings % no_of_surfaceSamplings . GT . 0 ) then call Section_Header ( \"Initialize Surface Samplings\" ) end if do i = 1 , Samplings % no_of_surfaceSamplings call Samplings % surfaceSamplings ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do if ( Samplings % no_of_planeSamplings . GT . 0 ) then call Section_Header ( \"Initialize Plane Samplings\" ) end if do i = 1 , Samplings % no_of_planeSamplings call Samplings % planeSamplings ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do if ( Samplings % no_of_spatialMeanNodes . GT . 0 ) then call Section_Header ( \"Initialize Spatial Mean Node\" ) end if do i = 1 , Samplings % no_of_spatialMeanNodes call Samplings % spatialMeanNodes ( i ) % Initialization ( mesh , i , solution_file , FirstCall ) end do FirstCall = . FALSE . end subroutine Samplings_Construct subroutine Samplings_UpdateLagrangeInterp ( self , mesh ) ! !        ******************************************************************* !        This subroutine updates the Lagrange interpolants after pAdaptation !        ******************************************************************* ! implicit none class ( Sampling_t ) :: self class ( HexMesh ) :: mesh ! !        --------------- !        Local variables !        --------------- ! integer :: i ! !        Update interpolants plane Samplings !        ----------------------------------- do i = 1 , self % no_of_planeSamplings call self % planeSamplings ( i ) % UpdateInterp ( mesh ) end do end subroutine Samplings_UpdateLagrangeInterp subroutine Sampling_UpdateValues ( self , mesh , t ) ! !        *************************************************************** !              This subroutine updates the values for the Samplings. !        *************************************************************** ! use PhysicsStorage use StopwatchClass implicit none class ( Sampling_t ) :: self class ( HexMesh ) :: mesh real ( kind = RP ) :: t ! !        --------------- !        Local variables !        --------------- ! integer :: i ! !        Update surface Samplings !        ------------------------ do i = 1 , self % no_of_surfaceSamplings call self % surfaceSamplings ( i ) % Update ( mesh , self % surfaceSamplings ( i ) % bufferLine , t ) end do ! !        Update plane Samplings !        ---------------------- do i = 1 , self % no_of_planeSamplings call self % planeSamplings ( i ) % Update ( mesh , self % planeSamplings ( i ) % bufferLine , t ) end do ! !        Update spatial mean node !        ------------------------ do i = 1 , self % no_of_spatialMeanNodes call self % spatialMeanNodes ( i ) % Update ( mesh , self % spatialMeanNodes ( i ) % bufferLine , t ) end do end subroutine Sampling_UpdateValues subroutine Sampling_WriteToFile ( self , mesh , force ) ! !        ****************************************************************** !              This routine has a double behaviour: !           force = .true.  -> Writes to file and resets buffers !           force = .false. -> Just writes to file if the buffer is full !        ****************************************************************** ! use MPI_Process_Info implicit none class ( Sampling_t ) :: self class ( HexMesh ) :: mesh logical , optional :: force !        ------------------------------------------------ integer :: i logical :: forceVal if ( present ( force ) ) then forceVal = force else forceVal = . false . end if if ( forceVal ) then ! !           In this case the Samplings are exported to their files and the buffer is reseted !           ------------------------------------------------------------------------------- do i = 1 , self % no_of_surfaceSamplings call self % surfaceSamplings ( i ) % WriteToFile ( self % surfaceSamplings ( i ) % bufferLine ) end do do i = 1 , self % no_of_planeSamplings call self % planeSamplings ( i ) % WriteToFile ( self % planeSamplings ( i ) % bufferLine ) end do do i = 1 , self % no_of_spatialMeanNodes call self % spatialMeanNodes ( i ) % WriteToFile ( self % spatialMeanNodes ( i ) % bufferLine ) end do else ! !           The Samplings are exported just if the buffer is full !           ---------------------------------------------------- do i = 1 , self % no_of_surfaceSamplings if ( self % surfaceSamplings ( i ) % bufferLine . eq . self % surfaceSamplings ( i ) % bufferSize ) then call self % surfaceSamplings ( i ) % WriteToFile ( self % surfaceSamplings ( i ) % bufferLine ) end if end do do i = 1 , self % no_of_planeSamplings if ( self % planeSamplings ( i ) % bufferLine . eq . self % planeSamplings ( i ) % bufferSize ) then call self % planeSamplings ( i ) % WriteToFile ( self % planeSamplings ( i ) % bufferLine ) end if end do do i = 1 , self % no_of_spatialMeanNodes if ( self % spatialMeanNodes ( i ) % bufferLine . eq . self % spatialMeanNodes ( i ) % bufferSize ) then call self % spatialMeanNodes ( i ) % WriteToFile ( self % spatialMeanNodes ( i ) % bufferLine ) end if end do end if end subroutine Sampling_WriteToFile subroutine Sampling_Destruct ( self ) implicit none class ( Sampling_t ) :: self if ( self % no_of_surfaceSamplings . gt . 0 ) call self % surfaceSamplings % destruct if ( self % no_of_planeSamplings . gt . 0 ) call self % planeSamplings % destruct if ( self % no_of_spatialMeanNodes . gt . 0 ) call self % spatialMeanNodes % destruct safedeallocate ( self % surfaceSamplings ) safedeallocate ( self % planeSamplings ) safedeallocate ( self % spatialMeanNodes ) end subroutine impure elemental subroutine Sampling_Assign ( to , from ) implicit none !-arguments-------------------------------------- class ( Sampling_t ), intent ( inout ) :: to type ( Sampling_t ) , intent ( in ) :: from !-local-variables-------------------------------- !------------------------------------------------ to % solution_file = from % solution_file to % no_of_surfaceSamplings = from % no_of_surfaceSamplings to % no_of_planeSamplings = from % no_of_planeSamplings to % no_of_spatialMeanNodes = from % no_of_spatialMeanNodes to % dt_restriction = from % dt_restriction to % write_dt_restriction = from % write_dt_restriction if ( to % no_of_surfaceSamplings . gt . 0 ) call to % surfaceSamplings % destruct if ( to % no_of_planeSamplings . gt . 0 ) call to % planeSamplings % destruct if ( to % no_of_spatialMeanNodes . gt . 0 ) call to % spatialMeanNodes % destruct safedeallocate ( to % surfaceSamplings ) safedeallocate ( to % planeSamplings ) safedeallocate ( to % spatialMeanNodes ) allocate ( to % surfaceSamplings ( size ( from % surfaceSamplings ) ) ) allocate ( to % planeSamplings ( size ( from % planeSamplings ) ) ) allocate ( to % spatialMeanNodes ( size ( from % spatialMeanNodes ) ) ) to % surfaceSamplings = from % surfaceSamplings to % planeSamplings = from % planeSamplings to % spatialMeanNodes = from % spatialMeanNodes end subroutine Sampling_Assign ! !////////////////////////////////////////////////////////////////////////////// ! !        Auxiliars ! !////////////////////////////////////////////////////////////////////////////// ! subroutine getNoOfSamplings ( no_of_surfaceSamplings , no_of_planeSamplings , no_of_spatialMeanNodes ) use ParamfileRegions implicit none integer , intent ( out ) :: no_of_surfaceSamplings integer , intent ( out ) :: no_of_planeSamplings integer , intent ( out ) :: no_of_spatialMeanNodes ! !     --------------- !     Local variables !     --------------- ! character ( len = LINE_LENGTH ) :: case_name , line integer :: fID integer :: io ! !     Initialize !     ---------- no_of_surfaceSamplings = 0 no_of_planeSamplings = 0 no_of_spatialMeanNodes = 0 ! !     Get case file name !     ------------------ call get_command_argument ( 1 , case_name ) ! !     Open case file !     -------------- open ( newunit = fID , file = case_name , status = \"old\" , action = \"read\" ) ! !     Read the whole file to find Samplings !     ------------------------------------ readloop : do read ( fID , '(A)' , iostat = io ) line if ( io . lt . 0 ) then ! !           End of file !           ----------- line = \"\" exit readloop elseif ( io . gt . 0 ) then ! !           Error !           ----- errorMessage ( STD_OUT ) stop \"Stopped.\" else ! !           Succeeded !           --------- line = getSquashedLine ( line ) if ( index ( line , '#definesurfacesampling' ) . gt . 0 ) then no_of_surfaceSamplings = no_of_surfaceSamplings + 1 else if ( index ( line , '#defineplanesampling' ) . gt . 0 ) then no_of_planeSamplings = no_of_planeSamplings + 1 else if ( index ( line , '#definespatialmeannode' ) . gt . 0 ) then no_of_spatialMeanNodes = no_of_spatialMeanNodes + 1 end if end if end do readloop ! !     Close case file !     --------------- close ( fID ) end subroutine getNoOfSamplings end module Samplings ! !/////////////////////////////////////////////////////////////////////////////////// !","tags":"","url":"sourcefile/samplings.f90.html"},{"title":"MonitorDefinitions.f90 – HORSES3D","text":"Source Code module MonitorDefinitions implicit none private public BUFFER_SIZE_DEFAULT , STR_LEN_MONITORS public MONITOR_LENGTH , VOLUME_UNDEFINED , VOLUME_INTEGRAL public BUFFER_SIZE integer , parameter :: BUFFER_SIZE_DEFAULT = 100 integer :: BUFFER_SIZE = BUFFER_SIZE_DEFAULT integer , parameter :: STR_LEN_MONITORS = 128 integer , parameter :: MONITOR_LENGTH = 10 integer , parameter :: VOLUME_UNDEFINED = 0 integer , parameter :: VOLUME_INTEGRAL = 1 end module MonitorDefinitions","tags":"","url":"sourcefile/monitordefinitions.f90.html"},{"title":"FWHObseverClass.f90 – HORSES3D","text":"Source Code ! !////////////////////////////////////////////////////// ! !This class represents the observer for the fW-H acoustic analogy, including the relations with several observers #include \"Includes.h\" Module FWHObseverClass ! use SMConstants use FaceClass use Physics use PhysicsStorage use NodalStorageClass use FWHDefinitions , only : OB_BUFFER_SIZE , OB_BUFFER_SIZE_DEFAULT , STR_LEN_OBSERVER use ZoneClass use HexMeshClass use MPI_Process_Info #ifdef _HAS_MPI_ use mpi #endif Implicit None ! !  ***************************** !  Observer source pair class definition !  class for the coupling of each pair of observer and source(face) !  mainly acoustic geometrical relations and face link !  ***************************** type ObserverSourcePairClass real ( kind = RP ), dimension (:,:,:), allocatable :: rVect real ( kind = RP ), dimension (:,:), allocatable :: r real ( kind = RP ), dimension (:,:), allocatable :: re real ( kind = RP ), dimension (:,:,:), allocatable :: reUnitVect real ( kind = RP ), dimension (:,:), allocatable :: reStar real ( kind = RP ), dimension (:,:,:), allocatable :: reStarUnitVect real ( kind = RP ) :: tDelay integer :: faceIDinMesh ! ID of the source (face) at the Mesh array (linked list) integer :: elementSide real ( kind = RP ) :: normalCorrection real ( kind = RP ), dimension (:,:), allocatable :: Pacc ! temporal solution of acoustic pressure for each pair real ( kind = RP ), dimension (:), allocatable :: tInterp ! time array for interpolation contains procedure :: construct => ObserverSourcePairConstruct procedure :: destruct => ObserverSourcePairDestruct procedure :: allocPacc => ObserverSourcePairAllocSolution procedure :: interpolateSolF => ObserverSourcePairInterpolateSolFirst procedure :: newUpdate => ObserverSourcePairNewUpdate procedure :: interpolateSolS => ObserverSourcePairInterpolateSolSecond procedure :: updateOneStep => ObserverSourcePairUpdateOneStep procedure :: FWHSurfaceIntegral end type ObserverSourcePairClass ! !  ***************************** !  General observer class definition !   (similar to a monitor, mostly surface monitor in many behaviours) !  ***************************** ! type ObserverClass integer :: ID real ( kind = RP ), dimension ( NDIM ) :: x ! position of the observer at global coordinates integer :: numberOfFaces class ( ObserverSourcePairClass ), dimension (:), allocatable :: sourcePair real ( kind = RP ), dimension (:,:), allocatable :: Pac ! acoustic pressure, two components and the total (sum) real ( kind = RP ) :: tDelay real ( kind = RP ) :: tDelayMax logical :: active character ( len = STR_LEN_OBSERVER ) :: observerName character ( len = STR_LEN_OBSERVER ) :: fileName contains procedure :: construct => ObserverConstruct procedure :: destruct => ObserverDestruct procedure :: update => ObserverUpdate procedure :: writeToFile => ObserverWriteToFile procedure :: updateTdelay => ObserverUpdateTdelay procedure :: interpolateSol => ObserverInterpolateSol procedure :: sumIntegrals => ObserverSumIntegrals procedure :: updateOneStep => ObserverUpdateOneStep end type ObserverClass contains !///////////////////////////////////////////////////////////////////////// !           OBSERVER CLASS PROCEDURES -------------------------- !///////////////////////////////////////////////////////////////////////// Subroutine ObserverConstruct ( self , sourceZone , mesh , ID , solution_file , FirstCall , interpolate , totalNumberOfFaces , elementSide ) !        ***************************************************************************** !              This subroutine initializes the observer similar to a monitor. The following !           data is obtained from the case file: !              -> Name: The observer name (10 characters maximum) !              -> x: The observer position !        ***************************************************************************** use ParamfileRegions use FileReadingUtilities , only : getRealArrayFromString implicit none class ( ObserverClass ) :: self class ( Zone_t ), intent ( in ) :: sourceZone class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: ID , totalNumberOfFaces character ( len =* ), intent ( in ) :: solution_file logical , intent ( in ) :: FirstCall , interpolate integer , dimension (:), intent ( in ) :: elementSide ! local variables character ( len = STR_LEN_OBSERVER ) :: in_label character ( len = STR_LEN_OBSERVER ) :: fileName character ( len = STR_LEN_OBSERVER ) :: paramFile character ( len = STR_LEN_OBSERVER ) :: coordinates integer :: fID integer :: MeshFaceID , zoneFaceID ! integer                          :: elementSide ! !      Get observer ID !      -------------- self % ID = ID ! !      Search for the parameters in the case file !      ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define acoustic observer \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ), \"name\" , self % observerName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ), \"position\" , coordinates , in_label , \"# end\" ) !      Get the coordinates !      ------------------- self % x = getRealArrayFromString ( coordinates ) !     Enable the observer !     ------------------ self % active = . true . allocate ( self % Pac ( OB_BUFFER_SIZE , 3 ) ) !     Get source information !     ------------------ self % numberOfFaces = sourceZone % no_of_faces !     Construct each pair observer-source !     ------------------ allocate ( self % sourcePair ( self % numberOfFaces ) ) !     Loop the zone to get faces do zoneFaceID = 1 , self % numberOfFaces !         Face global ID MeshFaceID = sourceZone % faces ( zoneFaceID ) call self % sourcePair ( zoneFaceID ) % construct ( self % x , mesh % faces ( MeshFaceID ), MeshFaceID , FirstCall , elementSide ( zoneFaceID )) end do !     Allocate variables for interpolation !     ------------------------------------------------- if ( interpolate ) then do zoneFaceID = 1 , self % numberOfFaces call self % sourcePair ( zoneFaceID ) % allocPacc ( OB_BUFFER_SIZE ) end do end if !     Set the average time delay of the observer !     ------------------------------------------------- call self % updateTdelay ( totalNumberOfFaces ) !     Prepare the file in which the observer is exported !     ------------------------------------------------- write ( self % fileName , '(A,A,A,A)' ) trim ( solution_file ) , \".\" , trim ( self % observerName ) , \".observer\" ! !     Create file !     ----------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) !        Write the file headers !        ---------------------- write ( fID , '(A20,A  )' ) \"Observer name:      \" , trim ( self % observerName ) write ( fID , '(A20,ES24.10)' ) \"x coordinate: \" , self % x ( 1 ) write ( fID , '(A20,ES24.10)' ) \"y coordinate: \" , self % x ( 2 ) write ( fID , '(A20,ES24.10)' ) \"z coordinate: \" , self % x ( 3 ) write ( fID , * ) write ( fID , '(A10,5(2X,A24))' ) \"Iteration\" , \"Time\" , \"Observer_Time\" , \"P'T\" , \"P'L\" , \"P'\" close ( fID ) end if End Subroutine ObserverConstruct Subroutine ObserverUpdate ( self , mesh , isSolid , BufferPosition , interpolate ) !     ******************************************************************* !        This subroutine updates the observer acoustic pressure computing it from !        the mesh storage. It is stored in the \"bufferPosition\" position of the !        buffer. !     ******************************************************************* ! use VariableConversion , only : Pressure , PressureDot implicit none class ( ObserverClass ) :: self class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ), optional :: bufferPosition logical , intent ( in ) :: isSolid , interpolate ! local variables real ( kind = RP ) :: Pt , Pl ! pressure of each pair real ( kind = RP ), dimension ( 3 ) :: localPacc , Pacc ! temporal variable to store the sum of the pressure real ( kind = RP ), dimension ( 3 ) :: mInterp ! slope of interpolation real ( kind = RP ) :: valx , valy , valz integer :: zoneFaceID , meshFaceID , ierr integer :: storePosition !     Initialization !     -------------- if ( present ( bufferPosition )) self % Pac ( bufferPosition ,:) = 0.0_RP Pacc = 0.0_RP valx = 0.0_RP valy = 0.0_RP valz = 0.0_RP !     Loop the pairs (equivalent to loop the zone) and get the values !     --------------------------------------- interp_cond : if ( interpolate ) then !        For this case only save the values of the solution of each pair, at the corresponding position !        --------------------------------------- !$omp parallel private(meshFaceID,storePosition,localPacc) shared(mesh,isSolid,interpolate,Pacc,NodalStorage,& !$omp&                                                     self,bufferPosition) !$omp do private(meshFaceID,storePosition,localPacc) schedule(runtime) do zoneFaceID = 1 , self % numberOfFaces !            Compute the integral !            -------------------- meshFaceID = self % sourcePair ( zoneFaceID ) % faceIDinMesh localPacc = self % sourcePair ( zoneFaceID ) % FWHSurfaceIntegral ( mesh % faces ( meshFaceID ), isSolid ) !save solution at bufferPosition or last position if ( present ( bufferPosition )) then storePosition = bufferPosition else storePosition = size ( self % sourcePair ( zoneFaceID ) % Pacc , dim = 1 ) end if self % sourcePair ( zoneFaceID ) % Pacc ( storePosition ,:) = localPacc end do !$omp end do !$omp end parallel else interp_cond !        For this case get the whole solution of the observer, adding all the pairs without saving !        --------------------------------------- !$omp parallel private(meshFaceID, localPacc) shared(mesh,isSolid,interpolate,Pacc,NodalStorage,& !$omp&                                        self,valx,valy,valz) !$omp do private(meshFaceID,localPacc) reduction(+:valx,valy,valz) schedule(runtime) do zoneFaceID = 1 , self % numberOfFaces !            Compute the integral !            -------------------- meshFaceID = self % sourcePair ( zoneFaceID ) % faceIDinMesh localPacc = self % sourcePair ( zoneFaceID ) % FWHSurfaceIntegral ( mesh % faces ( meshFaceID ), isSolid ) ! sum without interpolate: suppose little change of each tDelay valx = valx + localPacc ( 1 ) valy = valy + localPacc ( 2 ) valz = valz + localPacc ( 3 ) end do !$omp end do !$omp end parallel Pacc = ( / valx , valy , valz / ) #ifdef _HAS_MPI_ localPacc = Pacc call mpi_allreduce ( localPacc , Pacc , 3 , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif self % Pac ( bufferPosition ,:) = Pacc end if interp_cond End Subroutine ObserverUpdate Subroutine ObserverUpdateTdelay ( self , totalNumberOfFaces ) !     ******************************************************************* !        This subroutine updates the observer time delay. For static surfaces it !        doesn't need to be updated at every iteration. !        Minimum time is used, for interpolation procedures !     ******************************************************************* ! use MPI_Process_Info implicit none class ( ObserverClass ) :: self integer , intent ( in ) :: totalNumberOfFaces ! local variables integer :: i , ierr real ( kind = RP ) :: t , tmax real ( kind = RP ), dimension (:), allocatable :: alltDelay real ( kind = RP ), dimension ( self % numberOfFaces ) :: tDelayArray integer , dimension ( MPI_Process % nProcs ) :: no_of_faces_p , displs do i = 1 , self % numberOfFaces tDelayArray ( i ) = self % sourcePair ( i ) % tDelay end do if ( ( MPI_Process % doMPIAction ) ) then #ifdef _HAS_MPI_ call mpi_gather ( self % numberOfFaces , 1 , MPI_INT , no_of_faces_p , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierr ) if ( MPI_Process % isRoot ) then displs = 0 do i = 2 , MPI_Process % nProcs displs ( i ) = displs ( i - 1 ) + no_of_faces_p ( i - 1 ) end do end if allocate ( alltDelay ( totalNumberOfFaces )) call mpi_gatherv ( tDelayArray , self % numberOfFaces , MPI_DOUBLE , & alltDelay , no_of_faces_p , displs , MPI_DOUBLE , 0 , MPI_COMM_WORLD , ierr ) if ( MPI_Process % isRoot ) then t = minval ( alltDelay ) tmax = maxval ( alltDelay ) end if call mpi_Bcast ( t , 1 , MPI_DOUBLE , 0 , MPI_COMM_WORLD , ierr ) call mpi_Bcast ( tmax , 1 , MPI_DOUBLE , 0 , MPI_COMM_WORLD , ierr ) #endif else t = minval ( tDelayArray ) tmax = maxval ( tDelayArray ) end if self % tDelay = t self % tDelayMax = tmax End Subroutine ObserverUpdateTdelay Subroutine ObserverWriteToFile ( self , iter , tsource , no_of_lines ) ! !     ************************************************************* !           This subroutine writes the buffer to the file. !     ************************************************************* ! implicit none class ( ObserverClass ) :: self integer , dimension (:) :: iter real ( kind = RP ), dimension (:) :: tsource integer :: no_of_lines ! !     --------------- !     Local variables !     --------------- ! integer :: i integer :: fID if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) do i = 1 , no_of_lines write ( fID , '(I10,5(2X,ES24.16))' ) iter ( i ) , tsource ( i ), tsource ( i ) + self % tDelay , self % Pac ( i ,:) end do close ( fID ) end if if ( no_of_lines . ne . 0 ) self % Pac ( 1 ,:) = self % Pac ( no_of_lines ,:) End Subroutine ObserverWriteToFile Subroutine ObserverUpdateOneStep ( self , mesh , BufferPosition , isSolid , tsource ) implicit none class ( ObserverClass ) :: self class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: bufferPosition logical , intent ( in ) :: isSolid real ( kind = RP ), intent ( in ) :: tsource ! local variables real ( kind = RP ) :: tobserver integer :: i integer , dimension ( self % numberOfFaces ) :: nDiscard ! store the solution of each pair at the last position, by not giving the bufferPosition call self % update ( mesh , isSolid , interpolate = . TRUE .) ! interpolate the solution of each pair at first position ! and save the time of each pair at its last position tobserver = tsource + self % tDelay !$omp parallel shared(self) !$omp do schedule(runtime) do i = 1 , self % numberOfFaces if ( self % sourcePair ( i ) % tDelay . eq . self % tDelay ) cycle call self % sourcePair ( i ) % interpolateSolS ( tobserver , tsource ) end do !$omp end do !$omp end parallel ! sum all the pair solution and save it at bufferPosition of the observer sol nDiscard = 0 call self % sumIntegrals ( nDiscard , 1 , bufferPosition , bufferPosition ) ! update the solution of each pair and its times for next iteration !$omp parallel shared(self) !$omp do schedule(runtime) do i = 1 , self % numberOfFaces call self % sourcePair ( i ) % updateOneStep () end do !$omp end do !$omp end parallel End Subroutine ObserverUpdateOneStep !interpolate the solution of all the pairs to get it at the mean observer time Subroutine ObserverInterpolateSol ( self , tsource , no_of_lines ) implicit none class ( ObserverClass ) :: self real ( kind = RP ), dimension (:), intent ( in ) :: tsource integer , intent ( in ) :: no_of_lines !local variables real ( kind = RP ), dimension (:), allocatable :: tobserver integer :: i , n , k , m integer , dimension ( self % numberOfFaces ) :: nDiscard logical :: sameDelay allocate ( tobserver ( no_of_lines )) tobserver = tsource ( 1 : no_of_lines ) + self % tdelay ! get max tobserver that can be interpolated do k = 1 , no_of_lines if ( tobserver ( k ) . ge . ( self % tDelayMax + tsource ( 1 )) ) exit end do n = no_of_lines - k + 1 ! k is the min tobserver index safedeallocate ( tobserver ) allocate ( tobserver ( n )) tobserver ( 1 : n ) = tsource ( k : no_of_lines ) + self % tdelay !$omp parallel shared(self, nDiscard, n, no_of_lines, tobserver, tsource,k) !$omp do schedule(runtime) do i = 1 , self % numberOfFaces ! call interp of each pair that are not the minimum ! if (almostequal(self % sourcepair(i) % tdelay, self % tdelay)) then if ( self % sourcepair ( i ) % tdelay . eq . self % tdelay ) then nDiscard ( i ) = k - 1 else call self % sourcePair ( i ) % interpolateSolF ( n , no_of_lines , tobserver , tsource ( 1 : no_of_lines ), nDiscard ( i )) end if end do !$omp end do !$omp end parallel ! set to 0 the first part of the solution, which cannot be interpolated ! in this case Pacc is written from 1:no_of_lines, which have a value of 0 at first positions, not need to change obs write proc self % pac ( 1 : k - 1 ,:) = 0.0_RP ! sum all values from k to no_of_lines call self % sumIntegrals ( nDiscard , n , k , no_of_lines ) ! update all the solution of the pair to save the future ones do i = 1 , self % numberOfFaces ! sameDelay = almostequal(self % sourcepair(i) % tdelay, self % tdelay) sameDelay = self % sourcepair ( i ) % tdelay . eq . self % tdelay call self % sourcePair ( i ) % newUpdate ( n , nDiscard ( i ), no_of_lines , tsource ( 1 : no_of_lines ), sameDelay ) end do End Subroutine ObserverInterpolateSol ! sum all the interpolated solution of all pairs and save it at the observer solution Subroutine ObserverSumIntegrals ( self , nDiscard , N , startIndex , no_of_lines ) implicit none class ( observerclass ) :: self integer , intent ( in ) :: no_of_lines , startIndex , N integer , dimension ( self % numberOfFaces ), intent ( in ) :: nDiscard ! local variables real ( kind = RP ), dimension (:,:), allocatable :: localPacc , Pacc ! temporal variable to store the sum of the pressure real ( kind = RP ), dimension (:), allocatable :: valx , valy , valz integer :: i , ierr !     Initialization !     -------------- ! 1:N must be equal to startIndex:no_of_lines allocate ( Pacc ( N , 3 ), localPacc ( N , 3 ), valx ( N ), valy ( N ), valz ( N )) Pacc = 0.0_RP valx = 0.0_RP valy = 0.0_RP valz = 0.0_RP !$omp parallel private(localPacc) shared(Pacc,nDiscard,N,self,valx,valy,valz) !$omp do private(localPacc) reduction(+:valx,valy,valz) schedule(runtime) do i = 1 , self % numberOfFaces !        Get the array of interpolated values of each pair localPacc ( 1 : N ,:) = self % sourcePair ( i ) % Pacc ( nDiscard ( i ) + 1 : nDiscard ( i ) + N ,:) ! sum interpolated valx = valx + localPacc (:, 1 ) valy = valy + localPacc (:, 2 ) valz = valz + localPacc (:, 3 ) end do !$omp end do !$omp end parallel Pacc (:, 1 ) = valx (:) Pacc (:, 2 ) = valy (:) Pacc (:, 3 ) = valz (:) #ifdef _HAS_MPI_ localPacc = Pacc call mpi_allreduce ( localPacc , Pacc , 3 * N , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif self % Pac ( startIndex : no_of_lines ,:) = Pacc ( 1 : N ,:) End Subroutine ObserverSumIntegrals Subroutine ObserverDestruct ( self ) implicit none class ( ObserverClass ), intent ( inout ) :: self ! local variables integer :: i safedeallocate ( self % Pac ) do i = 1 , self % numberOfFaces call self % sourcePair ( i ) % destruct end do safedeallocate ( self % sourcePair ) End Subroutine ObserverDestruct !///////////////////////////////////////////////////////////////////////// !           OBSERVER SOURCE PAIR CLASS PROCEDURES -------------------------- !///////////////////////////////////////////////////////////////////////// Subroutine ObserverSourcePairConstruct ( self , x , f , fID , FirstCall , elementSide ) ! use fluiddata use FWHDefinitions , only : rho0 , P0 , c0 , U0 , M0 , fwGamma2 implicit none class ( ObserverSourcePairClass ) :: self real ( kind = RP ), dimension ( NDIM ), intent ( in ) :: x ! observer position type ( face ), intent ( in ) :: f ! source integer , intent ( in ) :: fID , elementSide logical , intent ( in ) :: FirstCall ! local variables integer :: Nx , Ny integer :: i , j real ( kind = RP ) :: fwGammaInv self % faceIDinMesh = fID Nx = f % Nf ( 1 ) Ny = f % Nf ( 2 ) self % elementSide = elementSide select case ( elementSide ) case ( 1 ) self % normalCorrection = 1.0_RP case ( 2 ) self % normalCorrection = - 1.0_RP end select allocate ( self % r ( 0 : Nx , 0 : Ny ), self % re ( 0 : Nx , 0 : Ny ), self % reStar ( 0 : Nx , 0 : Ny ) ) allocate ( self % rVect ( NDIM , 0 : Nx , 0 : Ny ), self % reUnitVect ( NDIM , 0 : Nx , 0 : Ny ) , self % reStarUnitVect ( NDIM , 0 : Nx , 0 : Ny ) ) fwGammaInv = 1.0_RP / sqrt ( fwGamma2 ) ! source position, for each node of the face associate ( y => f % geom % x ) do j = 0 , Ny ; do i = 0 , Nx ! store geometrical acoustic relations for each node self % rVect (:, i , j ) = x (:) - y (:, i , j ) self % r ( i , j ) = norm2 ( self % rVect (:, i , j )) self % reStar ( i , j ) = fwGammaInv * sqrt ( self % r ( i , j ) ** 2 + fwGamma2 * ( dot_product ( M0 , self % rVect (:, i , j )) ) ** 2 ) self % reStarUnitVect (:, i , j ) = ( self % rVect (:, i , j ) + fwGamma2 * dot_product ( M0 , self % rVect (:, i , j )) * M0 (:) ) / & ( fwGamma2 * self % reStar ( i , j )) self % re ( i , j ) = fwGamma2 * ( self % reStar ( i , j ) - dot_product ( M0 , self % rVect (:, i , j )) ) self % reUnitVect (:, i , j ) = fwGamma2 * ( self % reStarUnitVect (:, i , j ) - M0 (:) ) self % tDelay = ( sum ( self % re )) / real ( size ( self % re ), RP ) / c0 end do ; end do end associate End Subroutine ObserverSourcePairConstruct elemental Subroutine ObserverSourcePairDestruct ( self ) Class ( ObserverSourcePairClass ), intent ( inout ) :: self safedeallocate ( self % rVect ) safedeallocate ( self % r ) safedeallocate ( self % re ) safedeallocate ( self % reUnitVect ) safedeallocate ( self % reStar ) safedeallocate ( self % reStarUnitVect ) End Subroutine ObserverSourcePairDestruct ! allocate time history solution for a posterior interpolation Subroutine ObserverSourcePairAllocSolution ( self , buffer_size ) class ( ObserverSourcePairClass ) :: self integer , intent ( in ) :: buffer_size allocate ( self % Pacc ( buffer_size , 3 )) End Subroutine ObserverSourcePairAllocSolution Subroutine ObserverSourcePairInterpolateSolFirst ( self , N , M , tobserver , tsource , nd ) implicit none class ( ObserverSourcePairClass ) :: self integer , intent ( in ) :: N , M real ( kind = RP ), dimension ( N ), intent ( in ) :: tobserver real ( kind = RP ), dimension (:), intent ( in ) :: tsource integer , intent ( out ) :: nd ! local variables real ( kind = RP ), dimension ( N , 3 ) :: PaccInterp ! solution of the pair interpolated real ( kind = RP ), dimension ( M ) :: tPair ! time array of the panel integer :: i , j , ii ! get the times of the pair for interpolation tPair = tsource + self % tDelay j = 1 nd = 0 do i = 2 , M if ( j . gt . N ) exit ii = i - 1 if ( tPair ( i ) . lt . tobserver ( 1 )) then nd = nd + 1 cycle end if PaccInterp ( j ,:) = linearInterpolation ( tobserver ( j ), tPair ( ii ), self % Pacc ( ii ,:), tPair ( i ), self % Pacc ( i ,:), 3 ) j = j + 1 end do !update solution of the pair with the interpolated one self % Pacc ( nd + 1 : nd + N ,:) = PaccInterp End Subroutine ObserverSourcePairInterpolateSolFirst Subroutine ObserverSourcePairNewUpdate ( self , N , NDiscard , M , tsource , sameDelay ) implicit none class ( ObserverSourcePairClass ) :: self integer , intent ( in ) :: N , NDiscard , M ! real(kind=RP), dimension(N), intent(in)             :: tobserver real ( kind = RP ), dimension (:), intent ( in ) :: tsource logical , intent ( in ) :: sameDelay !local variables real ( kind = RP ), dimension ( M ) :: tPair ! time array of the panel real ( kind = RP ), dimension (:,:), allocatable :: PaccFuture ! solution of the pair of future (have not been interpolainterpolated) values integer :: Nfuture tPair = tsource + self % tDelay if ( sameDelay ) then !size = 1 for last value + 1(empty for next iter) Nfuture = 2 else !size = M - interpolated values +1 + 1(empty for next iter) Nfuture = M - N - NDiscard + 1 end if ! save old results and kept last position empty allocate ( PaccFuture ( Nfuture - 1 , 3 )) PaccFuture (:,:) = self % Pacc ( M - Nfuture + 2 : M ,:) safedeallocate ( self % Pacc ) allocate ( self % Pacc ( 1 : Nfuture , 3 )) self % Pacc ( 1 : Nfuture - 1 ,:) = PaccFuture (:,:) if (. not . sameDelay ) then allocate ( self % tInterp ( 1 : Nfuture )) ! save old results and kept last position empty self % tInterp ( 1 : Nfuture - 1 ) = tPair ( NDiscard + N + 1 : M ) end if End Subroutine ObserverSourcePairNewUpdate ! save the solution and times from position 2 to last as the first position, letting free the last one Subroutine ObserverSourcePairUpdateOneStep ( self ) implicit none class ( ObserverSourcePairClass ) :: self !local variables integer :: M M = size ( self % Pacc , dim = 1 ) if ( allocated ( self % tInterp )) self % tInterp ( 1 : M - 1 ) = self % tInterp ( 2 : M ) self % Pacc ( 1 : M - 1 ,:) = self % Pacc ( 2 : M ,:) End Subroutine ObserverSourcePairUpdateOneStep Subroutine ObserverSourcePairInterpolateSolSecond ( self , tobserver , tsource ) implicit none class ( ObserverSourcePairClass ) :: self real ( kind = RP ), intent ( in ) :: tobserver real ( kind = RP ), intent ( in ) :: tsource ! local variables real ( kind = RP ), dimension ( 2 ) :: tPair ! time array of the panel real ( kind = RP ), dimension ( 3 ) :: PaccInterp ! solution of the pair interpolated ! save last time self % tInterp ( size ( self % tInterp )) = tsource + self % tDelay ! use 2 first values to interpolate tPair = self % tInterp ( 1 : 2 ) PaccInterp (:) = linearInterpolation ( tobserver , tPair ( 1 ), self % Pacc ( 1 ,:), tPair ( 2 ), self % Pacc ( 2 ,:), 3 ) !update the first value of the solution of the pair with the interpolated one self % Pacc ( 1 ,:) = PaccInterp (:) End Subroutine ObserverSourcePairInterpolateSolSecond ! calculate the surface integrals of the FW-H analogy for stationary surfaces (permeable or impermeable) with a general flow ! direction of the medium ! the integrals are for a single face (pane in FWH terminology) for a single observer !         TODO: check if is more efficient to store FWHvariables for each face instead of calculating it always !               for many observers, its being recomputed as many as observers ! Function FWHSurfaceIntegral(self, f, isSolid, interpolate, bufferPosition) result(Pacc) Function FWHSurfaceIntegral ( self , f , isSolid ) result ( Pacc ) use FWHDefinitions , only : rho0 , P0 , c0 , U0 , M0 use VariableConversion , only : Pressure , PressureDot use fluiddata , only : dimensionless implicit none class ( ObserverSourcePairClass ) :: self class ( Face ), intent ( in ) :: f logical , intent ( in ) :: isSolid real ( kind = RP ), dimension ( 3 ) :: Pacc ! acoustic pressure values ! logical, intent(in)                                 :: isSolid, interpolate ! integer, intent(in), optional                       :: bufferPosition ! local variables integer :: i , j ! face indexes real ( kind = RP ), dimension ( NDIM ) :: Qi , QiDot , n real ( kind = RP ), dimension ( NDIM , NDIM ) :: Lij , LijDot type ( NodalStorage_t ), pointer :: spAxi , spAeta real ( kind = RP ) :: Pt , Pl real ( kind = RP ) :: LR , MR , UmMr , LdotR , LM ! integer                                             :: storePosition ! Initialization Pt = 0.0_RP Pl = 0.0_RP spAxi => NodalStorage ( f % Nf ( 1 )) spAeta => NodalStorage ( f % Nf ( 2 )) associate ( Q => f % storage ( self % elementSide ) % Q ) associate ( Qdot => f % storage ( self % elementSide ) % Qdot ) !           ********************************** !           Computes the surface integral !              I = \\int vec{f}·vec{n} * vec{g}·vec{r} dS !           ********************************** ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) n = f % geom % normal (:, i , j ) * self % normalCorrection call calculateFWHVariables ( Q (:, i , j ), Qdot (:, i , j ), isSolid , Qi , QiDot , Lij , LijDot ) LR = dot_product ( matmul ( Lij , n (:)), self % reUnitVect (:, i , j )) MR = dot_product ( M0 (:), self % reUnitVect (:, i , j )) UmMr = 1 - MR LdotR = dot_product ( matmul ( LijDot , n (:)), self % reUnitVect (:, i , j )) LM = dot_product ( matmul ( Lij , n (:)), M0 (:)) ! loading term integrals Pl = Pl + dot_product ( matmul ( LijDot , n (:)), self % reUnitVect (:, i , j )) / ( self % reStar ( i , j ) * c0 ) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) Pl = Pl + dot_product ( matmul ( Lij , n (:)), self % reStarUnitVect (:, i , j )) / ( self % reStar ( i , j ) ** 2 ) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) ! Pl = Pl + LdotR / ( c0 * self % re(i,j) * (UmMr**2) ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! Pl = Pl + (LR - LM) / ( (self % re(i,j) * UmMr)**2 ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! Pl = Pl + (LR * (MR - (dimensionless % Mach**2))) / ( (self % re(i,j)**2) * (UmMr**3) ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! thickness term integrals, only for permeable surfaces if (. not . isSolid ) then Pt = Pt + ( 1 - dot_product ( M0 (:), self % reUnitVect (:, i , j ))) * dot_product ( QiDot (:), n (:)) / ( self % reStar ( i , j )) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) Pt = Pt - dot_product ( U0 (:), self % reStarUnitVect (:, i , j )) * dot_product ( Qi (:), n (:)) / ( self % reStar ( i , j ) ** 2 ) * & spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) ! Pt = Pt + dot_product(QiDot(:),n(:)) / (self%reStar(i,j) * (UmMr**2)) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) ! Pt = Pt + (dot_product(Qi(:), n(:)) * c0 * (MR - (dimensionless % Mach**2))) / ( (self % re(i,j)**2) * (UmMr**3) ) * & !           spAxi % w(i) * spAeta % w(j) * f % geom % jacobian(i,j) end if end do ; end do end associate end associate Pt = Pt / ( 4.0_RP * PI ) Pl = Pl / ( 4.0_RP * PI ) ! get total acoustic pressure as the sum of the two components (the quadrapol terms are being ignored) Pacc = ( / Pt , Pl , Pt + Pl / ) End Function FWHSurfaceIntegral !///////////////////////////////////////////////////////////////////////// !           ZONE PROCEDURES -------------------------- !///////////////////////////////////////////////////////////////////////// Subroutine SourceProlongSolution ( source_zone , mesh , eSides ) !     ******************************************************************* !        This subroutine prolong the solution from the mesh storage to the faces (source). !         TODO: use openmp (commented) !         TODO: use mpi (see surface integral) !     ******************************************************************* ! use ElementClass implicit none class ( Zone_t ), intent ( in ) :: source_zone class ( HexMesh ), intent ( inout ), target :: mesh integer , dimension (:), intent ( in ) :: eSides ! local variables integer :: zoneFaceID , meshFaceID , eID integer , dimension ( 6 ) :: meshFaceIDs class ( Element ), pointer :: elements (:) !     ************************* !     Perform the interpolation !     ************************* ! elements => mesh % elements !$omp parallel private(meshFaceID,eID,meshFaceIDs) shared(elements,mesh,NodalStorage) !!$omp&                                        t) !$omp single !        Loop the zone to get faces and elements !        --------------------------------------- do zoneFaceID = 1 , source_zone % no_of_faces meshFaceID = source_zone % faces ( zoneFaceID ) eID = mesh % faces ( meshFaceID ) % elementIDs ( eSides ( zoneFaceID )) meshFaceIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS ,& mesh % faces ( meshFaceIDs ( 1 )),& mesh % faces ( meshFaceIDs ( 2 )),& mesh % faces ( meshFaceIDs ( 3 )),& mesh % faces ( meshFaceIDs ( 4 )),& mesh % faces ( meshFaceIDs ( 5 )),& mesh % faces ( meshFaceIDs ( 6 )),& computeQdot = . TRUE .) ! if ( computeGradients ) then !    call elements(eID) % ProlongGradientsToFaces(NGRAD, mesh % faces(meshFaceIDs(1)),& !                                     mesh % faces(meshFaceIDs(2)),& !                                     mesh % faces(meshFaceIDs(3)),& !                                     mesh % faces(meshFaceIDs(4)),& !                                     mesh % faces(meshFaceIDs(5)),& !                                     mesh % faces(meshFaceIDs(6)) ) ! end if !$omp end task end do !$omp end single !$omp end parallel End Subroutine SourceProlongSolution ! !///////////////////////////////////////////////////////////////////////// !           AUXILIARY PROCEDURES -------------------------- !///////////////////////////////////////////////////////////////////////// ! get the interpolated value of an array ! ------------ Function linearInterpolation ( x , x1 , y1 , x2 , y2 , N ) result ( y ) integer , intent ( in ) :: N real ( kind = RP ), intent ( in ) :: x1 , x2 , x real ( kind = RP ), dimension ( N ), intent ( in ) :: y1 , y2 real ( kind = RP ), dimension ( N ) :: y y = y1 + ( y2 - y1 ) / ( x2 - x1 ) * ( x - x1 ) End Function linearInterpolation Subroutine calculateFWHVariables ( Q , Qdot , isSolid , Qi , QiDot , Lij , LijDot ) use VariableConversion , only : Pressure , PressureDot use FWHDefinitions , only : rho0 , P0 , c0 , U0 , M0 use Utilities , only : AlmostEqual implicit none real ( kind = RP ), dimension ( NCONS ), intent ( in ) :: Q ! horses variables array real ( kind = RP ), dimension ( NCONS ), intent ( in ) :: Qdot ! horses time derivatives array logical , intent ( in ) :: isSolid real ( kind = RP ), dimension ( NDIM ), intent ( out ) :: Qi ! fwh Qi array, related with the acoustic pressure thickness real ( kind = RP ), dimension ( NDIM ), intent ( out ) :: Qidot real ( kind = RP ), dimension ( NDIM , NDIM ), intent ( out ) :: Lij ! fwh Lij tensor: related with the acoustic pressure loading real ( kind = RP ), dimension ( NDIM , NDIM ), intent ( out ) :: LijDot !local variables real ( kind = RP ) :: P , pDot real ( kind = RP ), dimension ( NDIM , NDIM ) :: Pij ! fwh perturbation stress tensor ! real(kind=RP), dimension(NDIM:NDIM)                 :: tau integer :: i , j , ii , jj P = Pressure ( Q ) pDot = PressureDot ( Q , Qdot ) Pij = 0.0_RP LijDot = 0.0_RP do i = 1 , NDIM Pij ( i , i ) = P - P0 !pressure derivative of LijDot LijDot ( i , i ) = pDot end do !TODO use the stress tensor and the time derivative for Lij and LijDot respectively ! call getStressTensor(Q, U_x, U_y, U_z, tau) ! Pij = Pij - tau ! LijDot = LijDot - tauDot ! set values for solid (impermeable) surface Qi (:) = - rho0 * U0 (:) Qidot = 0.0_RP Lij = Pij ! Lij = 0.0_RP !calculate terms for permeable surface if (. not . isSolid ) then Qi (:) = Qi (:) + Q ( 2 : 4 ) ! convert to complete velocity instead of perturbation velocity QiDot (:) = QiDot (:) + Qdot ( 2 : 4 ) do j = 1 , NDIM jj = j + 1 do i = 1 , NDIM ! one index is added since rhoV1 = Q(2), rhoV2 = Q(3) ... ii = i + 1 Lij ( i , j ) = Lij ( i , j ) + ( Q ( ii ) - Q ( 1 ) * U0 ( i )) * ( Q ( jj ) / Q ( 1 )) LijDot ( i , j ) = LijDot ( i , j ) + ( Qdot ( ii ) - Q ( ii ) / Q ( 1 ) * Qdot ( 1 ) ) / Q ( 1 ) * Q ( jj ) + & ( Q ( ii ) / Q ( 1 ) - U0 ( i )) * Qdot ( jj ) end do end do end if End Subroutine calculateFWHVariables End Module FWHObseverClass","tags":"","url":"sourcefile/fwhobseverclass.f90.html"},{"title":"Probe.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" #ifdef FLOW module ProbeClass use SMConstants use HexMeshClass use MonitorDefinitions use PhysicsStorage use VariableConversion use MPI_Process_Info use FluidData use FileReadingUtilities , only : getRealArrayFromString use NodalStorageClass , only : NodalStorage #ifdef _HAS_MPI_ use mpi #endif implicit none private public Probe_t ! !  ********************** !  Probe class definition !  ********************** ! type Probe_t logical :: active integer :: rank integer :: ID integer :: eID real ( kind = RP ) :: x ( NDIM ) real ( kind = RP ) :: xi ( NDIM ) real ( kind = RP ), allocatable :: values (:) real ( kind = RP ), allocatable :: lxi (:) , leta (:), lzeta (:) character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => Probe_Initialization procedure :: Update => Probe_Update procedure :: WriteLabel => Probe_WriteLabel procedure :: WriteValues => Probe_WriteValue procedure :: WriteToFile => Probe_WriteToFile procedure :: LookInOtherPartitions => Probe_LookInOtherPartitions procedure :: destruct => Probe_Destruct procedure :: copy => Probe_Assign generic :: assignment ( = ) => copy end type Probe_t contains subroutine Probe_Initialization ( self , mesh , ID , solution_file , FirstCall ) use ParamfileRegions use MPI_Process_Info use Utilities , only : toLower implicit none class ( Probe_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , fid character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile character ( len = STR_LEN_MONITORS ) :: coordinates if ( FirstCall ) then ! !           Allocate memory !           --------------- allocate ( self % values ( BUFFER_SIZE ) ) ! !           Get monitor ID !           -------------- self % ID = ID ! !           Search for the parameters in the case file !           ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define probe \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ), \"name\" , self % monitorName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ), \"variable\" , self % variable , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ), \"position\" , coordinates , in_label , \"# end\" ) ! !           Get the coordinates !           ------------------- self % x = getRealArrayFromString ( coordinates ) ! !           Check the variable !           ------------------ call tolower ( self % variable ) select case ( trim ( self % variable ) ) #ifdef NAVIERSTOKES case ( \"pressure\" ) case ( \"velocity\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case ( \"mach\" ) case ( \"k\" ) case default print * , 'Probe variable \"' , trim ( self % variable ), '\" not implemented.' print * , \"Options available are:\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" print * , \"   * Mach\" print * , \"   * K\" end select #endif #ifdef INCNS case ( \"pressure\" ) case ( \"velocity\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case default print * , 'Probe variable \"' , trim ( self % variable ), '\" not implemented.' print * , \"Options available are:\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" end select #endif #ifdef MULTIPHASE case ( \"static-pressure\" ) case ( \"pressure\" ) case ( \"velocity\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case ( \"concentration\" ) case default print * , 'Probe variable \"' , trim ( self % variable ), '\" not implemented.' print * , \"Options available are:\" print * , \"   * static-pressure\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" print * , \"   * concentration\" end select #endif #ifdef ACOUSTIC case ( \"pressure\" ) case ( \"density\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case default print * , 'Probe variable \"' , trim ( self % variable ), '\" not implemented.' print * , \"Options available are:\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" end select #endif ! !           Find the requested point in the mesh !           ------------------------------------ self % active = mesh % FindPointWithCoords ( self % x , self % eID , self % xi ) ! !           Check whether the probe is located in other partition !           ----------------------------------------------------- call self % LookInOtherPartitions ! !           Disable the probe if the point is not found !           ------------------------------------------- if ( . not . self % active ) then if ( MPI_Process % isRoot ) then write ( STD_OUT , '(A,I0,A)' ) \"Probe \" , ID , \" was not successfully initialized.\" print * , \"Probe is set to inactive.\" end if return end if ! !           Set the fileName !           ---------------- write ( self % fileName , '(A,A,A,A)' ) trim ( solution_file ) , \".\" , & trim ( self % monitorName ) , \".probe\" end if ! ! !           Return if the process does not contain the partition !           ---------------------------------------------------- if ( self % rank . ne . MPI_Process % rank ) then self % eID = 1 return end if ! !        If this is not the first call, just reload the reference frame coordinates !        -------------------------------------------------------------------------- if (. not . firstCall ) self % active = mesh % elements ( self % eID ) % FindPointWithCoords ( self % x , mesh % dir2D_ctrl , self % xi ) ! !        Get the Lagrange interpolants !        ----------------------------- associate ( e => mesh % elements ( self % eID )) associate ( spAxi => NodalStorage ( e % Nxyz ( 1 )), & spAeta => NodalStorage ( e % Nxyz ( 2 )), & spAzeta => NodalStorage ( e % Nxyz ( 3 )) ) safedeallocate ( self % lxi ) ; allocate ( self % lxi ( 0 : e % Nxyz ( 1 )) ) safedeallocate ( self % leta ) ; allocate ( self % leta ( 0 : e % Nxyz ( 2 )) ) safedeallocate ( self % lzeta ) ; allocate ( self % lzeta ( 0 : e % Nxyz ( 3 )) ) self % lxi = spAxi % lj ( self % xi ( 1 )) self % leta = spAeta % lj ( self % xi ( 2 )) self % lzeta = spAzeta % lj ( self % xi ( 3 )) ! !        **************** !        Prepare the file !        **************** ! !        Create file !        ----------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) ! !        Write the file headers !        ---------------------- write ( fID , '(A20,A  )' ) \"Monitor name:      \" , trim ( self % monitorName ) write ( fID , '(A20,A  )' ) \"Selected variable: \" , trim ( self % variable ) write ( fID , '(A20,ES24.10)' ) \"x coordinate: \" , self % x ( 1 ) write ( fID , '(A20,ES24.10)' ) \"y coordinate: \" , self % x ( 2 ) write ( fID , '(A20,ES24.10)' ) \"z coordinate: \" , self % x ( 3 ) write ( fID , * ) write ( fID , '(A10,2X,A24,2X,A24)' ) \"Iteration\" , \"Time\" , trim ( self % variable ) close ( fID ) end if end associate end associate end subroutine Probe_Initialization subroutine Probe_Update ( self , mesh , bufferPosition ) use Physics use MPI_Process_Info implicit none class ( Probe_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , ierr real ( kind = RP ) :: value , rho_multiphase real ( kind = RP ) :: var ( 0 : mesh % elements ( self % eID ) % Nxyz ( 1 ),& 0 : mesh % elements ( self % eID ) % Nxyz ( 2 ),& 0 : mesh % elements ( self % eID ) % Nxyz ( 3 ) ) if ( . not . self % active ) return if ( MPI_Process % rank . eq . self % rank ) then ! !           Update the probe !           ---------------- associate ( e => mesh % elements ( self % eID ) ) associate ( Q => e % storage % Q ) select case ( trim ( self % variable )) #ifdef NAVIERSTOKES case ( \"pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Pressure ( Q (:, i , j , k )) end do ; end do ; end do case ( \"velocity\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = sqrt ( POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k ))) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"u\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOU , i , j , k ) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"v\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOV , i , j , k ) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"w\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOW , i , j , k ) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"mach\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k )) / POW2 ( Q ( IRHO , i , j , k )) ! Vabs**2 var ( i , j , k ) = sqrt ( var ( i , j , k ) / ( thermodynamics % gamma * ( thermodynamics % gamma - 1.0_RP ) * ( Q ( IRHOE , i , j , k ) / Q ( IRHO , i , j , k ) - 0.5_RP * var ( i , j , k )) ) ) end do ; end do ; end do case ( \"k\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = 0.5_RP * ( POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k ))) / Q ( IRHO , i , j , k ) end do ; end do ; end do #endif #ifdef INCNS case ( \"pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( INSP , i , j , k ) end do ; end do ; end do case ( \"velocity\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = sqrt ( POW2 ( Q ( INSRHOU , i , j , k )) + POW2 ( Q ( INSRHOV , i , j , k )) + POW2 ( Q ( INSRHOW , i , j , k ))) / Q ( INSRHO , i , j , k ) end do ; end do ; end do case ( \"u\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( INSRHOU , i , j , k ) / Q ( INSRHO , i , j , k ) end do ; end do ; end do case ( \"v\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( INSRHOV , i , j , k ) / Q ( INSRHO , i , j , k ) end do ; end do ; end do case ( \"w\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( INSRHOW , i , j , k ) / Q ( INSRHO , i , j , k ) end do ; end do ; end do #endif #ifdef MULTIPHASE case ( \"static-pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMP , i , j , k ) + Q ( IMC , i , j , k ) * e % storage % mu ( 1 , i , j , k ) - 1 2.0_RP * multiphase % sigma * multiphase % invEps * ( POW2 ( Q ( IMC , i , j , k ) * ( 1.0_RP - Q ( IMC , i , j , k )))) & - 0.25_RP * 3.0_RP * multiphase % sigma * multiphase % eps * ( POW2 ( e % storage % c_x ( 1 , i , j , k )) + POW2 ( e % storage % c_y ( 1 , i , j , k )) + POW2 ( e % storage % c_z ( 1 , i , j , k ))) end do ; end do ; end do case ( \"pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMP , i , j , k ) end do ; end do ; end do case ( \"velocity\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) rho_multiphase = dimensionless % rho ( 1 ) * e % storage % Q ( IMC , i , j , k ) + dimensionless % rho ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) var ( i , j , k ) = sqrt ( POW2 ( Q ( IMSQRHOU , i , j , k )) + POW2 ( Q ( IMSQRHOV , i , j , k )) + POW2 ( Q ( IMSQRHOW , i , j , k ))) / rho_multiphase end do ; end do ; end do case ( \"u\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) rho_multiphase = dimensionless % rho ( 1 ) * e % storage % Q ( IMC , i , j , k ) + dimensionless % rho ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) var ( i , j , k ) = Q ( IMSQRHOU , i , j , k ) / rho_multiphase end do ; end do ; end do case ( \"v\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) rho_multiphase = dimensionless % rho ( 1 ) * e % storage % Q ( IMC , i , j , k ) + dimensionless % rho ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) var ( i , j , k ) = Q ( IMSQRHOV , i , j , k ) / rho_multiphase end do ; end do ; end do case ( \"w\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) rho_multiphase = dimensionless % rho ( 1 ) * e % storage % Q ( IMC , i , j , k ) + dimensionless % rho ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) var ( i , j , k ) = Q ( IMSQRHOW , i , j , k ) / rho_multiphase end do ; end do ; end do case ( \"concentration\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = e % storage % Q ( IMC , i , j , k ) end do ; end do ; end do #endif #ifdef ACOUSTIC case ( \"pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( ICAAP , i , j , k ) end do ; end do ; end do case ( \"density\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( ICAARHO , i , j , k ) end do ; end do ; end do case ( \"u\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( ICAAU , i , j , k ) end do ; end do ; end do case ( \"v\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( ICAAV , i , j , k ) end do ; end do ; end do case ( \"w\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( ICAAW , i , j , k ) end do ; end do ; end do #endif end select value = 0.0_RP do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) value = value + var ( i , j , k ) * self % lxi ( i ) * self % leta ( j ) * self % lzeta ( k ) end do ; end do ; end do self % values ( bufferPosition ) = value end associate end associate #ifdef _HAS_MPI_ if ( MPI_Process % doMPIAction ) then ! !              Share the result with the rest of the processes !              ----------------------------------------------- call mpi_bcast ( value , 1 , MPI_DOUBLE , self % rank , MPI_COMM_WORLD , ierr ) end if #endif else ! !           Receive the result from the rank that contains the probe !           -------------------------------------------------------- #ifdef _HAS_MPI_ if ( MPI_Process % doMPIAction ) then call mpi_bcast ( self % values ( bufferPosition ), 1 , MPI_DOUBLE , self % rank , MPI_COMM_WORLD , ierr ) end if #endif end if end subroutine Probe_Update subroutine Probe_WriteLabel ( self ) ! !        ************************************************************* !              This subroutine writes the label for the probe, !           when invoked from the time integrator Display !           procedure. !        ************************************************************* ! implicit none class ( Probe_t ) :: self write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) trim ( self % monitorName ( 1 : MONITOR_LENGTH )) end subroutine Probe_WriteLabel subroutine Probe_WriteValue ( self , bufferLine ) ! !        ************************************************************* !              This subroutine writes the monitor value for the time !           integrator Display procedure. !        ************************************************************* ! implicit none class ( Probe_t ) :: self integer :: bufferLine write ( STD_OUT , '(1X,A,1X,ES10.3)' , advance = \"no\" ) \"|\" , self % values ( bufferLine ) end subroutine Probe_WriteValue subroutine Probe_WriteToFile ( self , iter , t , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( Probe_t ) :: self integer :: iter (:) real ( kind = RP ) :: t (:) integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i integer :: fID if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) do i = 1 , no_of_lines write ( fID , '(I10,2X,ES24.16,2X,ES24.16)' ) iter ( i ) , t ( i ) , self % values ( i ) end do close ( fID ) end if if ( no_of_lines . ne . 0 ) self % values ( 1 ) = self % values ( no_of_lines ) end subroutine Probe_WriteToFile subroutine Probe_LookInOtherPartitions ( self ) use MPI_Process_Info implicit none class ( Probe_t ) :: self integer :: allActives ( MPI_Process % nProcs ) integer :: active , ierr if ( MPI_Process % doMPIAction ) then #ifdef _HAS_MPI_ ! !           Cast the logicals onto integers !           ------------------------------- if ( self % active ) then active = 1 else active = 0 end if ! !           Gather all data from all processes !           ---------------------------------- call mpi_allgather ( active , 1 , MPI_INT , allActives , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) ! !           Check if any of them found the probe !           ------------------------------------ if ( any ( allActives . eq . 1 ) ) then ! !              Assign the domain of the partition that contains the probe !              ---------------------------------------------------------- self % active = . true . self % rank = maxloc ( allActives , dim = 1 ) - 1 else ! !              Disable the probe !              ----------------- self % active = . false . self % rank = - 1 end if #endif else ! !           Without MPI select the rank 0 as default !           ---------------------------------------- self % rank = 0 end if end subroutine Probe_LookInOtherPartitions elemental subroutine Probe_Destruct ( self ) implicit none class ( Probe_t ), intent ( inout ) :: self safedeallocate ( self % values ) safedeallocate ( self % lxi ) safedeallocate ( self % leta ) safedeallocate ( self % lzeta ) end subroutine Probe_Destruct elemental subroutine Probe_Assign ( to , from ) implicit none class ( Probe_t ), intent ( inout ) :: to type ( Probe_t ) , intent ( in ) :: from to % active = from % active to % rank = from % rank to % ID = from % ID to % eID = from % eID to % x = from % x to % xi = from % xi safedeallocate ( to % values ) allocate ( to % values ( size ( from % values ) ) ) to % values = from % values safedeallocate ( to % lxi ) allocate ( to % lxi ( size ( from % lxi ) ) ) to % lxi = from % lxi safedeallocate ( to % leta ) allocate ( to % leta ( size ( from % leta ) ) ) to % leta = from % leta safedeallocate ( to % lzeta ) allocate ( to % lzeta ( size ( from % lzeta ) ) ) to % lzeta = from % lzeta to % fileName = from % fileName to % monitorName = from % monitorName to % variable = from % variable end subroutine Probe_Assign end module ProbeClass #endif","tags":"","url":"sourcefile/probe.f90.html"},{"title":"SurfaceSampling.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module SurfaceSampling use SMConstants use HexMeshClass use MonitorDefinitions use PhysicsStorage use MPI_Process_Info use FluidData use FileReadingUtilities , only : getRealArrayFromString , GetRealValue , getCharArrayFromString #ifdef _HAS_MPI_ use mpi #endif implicit none private public SurfaceSampling_t ! !  ******************************** !  Surface Sampling class definition !  ******************************** ! type SurfaceSampling_t logical :: active = . false . logical :: isDimensionless integer :: ID integer :: nVariables integer :: marker integer :: rank integer :: interval integer :: bufferSize integer :: bufferLine integer :: intervalCount integer , allocatable :: nData (:) real ( kind = RP ), allocatable :: values (:,:,:) character ( len = STR_LEN_MONITORS ) :: SamplingName character ( len = STR_LEN_MONITORS ), allocatable :: fileName (:) character ( len = STR_LEN_MONITORS ), allocatable :: variable (:) contains procedure :: Initialization => SurfaceSampling_Initialization procedure :: Update => SurfaceSampling_Update procedure :: WriteToFile => SurfaceSampling_WriteToFile procedure :: destruct => SurfaceSampling_Destruct procedure :: copy => SurfaceSampling_Assign generic :: assignment ( = ) => copy end type SurfaceSampling_t contains ! !///////////////////////////////////////////////////////////////////////// ! !           SURFACE Sampling PROCEDURES !           -------------------------- !///////////////////////////////////////////////////////////////////////// ! subroutine SurfaceSampling_Initialization ( self , mesh , ID , solution_file , FirstCall ) ! !        ***************************************************************************** !              This subroutine initializes the surface Sampling. The following !           data is obtained from the case file: !              -> Name: The Sampling name (10 characters maximum) !              -> Marker: The surface marker in which the Sampling will be computed. !              -> Variable: The variable to be Samplingized. !        ***************************************************************************** ! use Headers use ParamfileRegions use MPI_Process_Info implicit none class ( SurfaceSampling_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile integer , allocatable :: marker character ( len = STR_LEN_MONITORS ) :: markerName character ( len = STR_LEN_MONITORS ) :: bufferInt character ( len = STR_LEN_MONITORS ) :: formatFile character ( len = STR_LEN_MONITORS ) :: variables character ( len = STR_LEN_MONITORS ) :: writeInterval integer :: pos integer :: fID integer :: zoneID integer :: Nf ( 2 ) integer :: nData integer :: allnData ( MPI_Process % nProcs ), ierr integer :: zonefID integer :: i , j , k real ( kind = RP ), allocatable :: X (:,:) real ( kind = RP ), allocatable :: X1 (:,:) real ( kind = RP ), allocatable :: X2 (:,:) real ( kind = RP ), allocatable :: X3 (:,:) ! !        Get Sampling ID, assign zero to bufferLine and intervalCount !        -------------- self % ID = ID self % bufferLine = 0 self % intervalCount = 0 ! !        Search for the parameters in the case file !        ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define surface sampling \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ) , \"name\" , self % SamplingName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"surface\" , markerName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"variables\" , variables , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"sampling interval\" , bufferInt , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ), \"write interval\" , writeInterval , in_label , \"#end\" ) ! !        Enable the Sampling !        ------------------ self % active = . true . ! !        Get the variables and its size !        ------------------------------ call getCharArrayFromString ( variables , STR_LEN_MONITORS , self % variable ) self % nVariables = size ( self % variable ) ! !        Get the surface marker !        ---------------------- self % marker = - 1 do zoneID = 1 , size ( mesh % zones ) if ( trim ( mesh % zones ( zoneID ) % name ) . eq . trim ( markerName ) ) then self % marker = zoneID exit end if end do if ( self % marker . eq . - 1 ) then self % active = . false . if ( MPI_Process % isRoot ) then write ( * , '(A,I0)' ) \"Warning: Marker not specified for surface sampling \" , self % ID write ( * , '(A,I0,A)' ) \"     Surface Sampling \" , self % ID , \" disabled.\" end if end if if ( mesh % zones ( self % marker ) % no_of_faces . eq . 0 ) then self % active = . false . end if ! !        Select the variable from the available list, and compute auxiliary variables if needed !        -------------------------------------------------------------------------------------- ! DO i = 1 , self % nVariables !        **************************************** select case ( trim ( self % variable ( i ) ) ) !        **************************************** ! case ( \"shearstress-tangent\" ) self % isDimensionless = . false . case ( \"shearstress-x\" ) self % isDimensionless = . false . case ( \"shearstress-y\" ) self % isDimensionless = . false . case ( \"shearstress-z\" ) self % isDimensionless = . false . case ( \"pressure\" ) self % isDimensionless = . false . case ( \"q1\" ) self % isDimensionless = . true . case ( \"q2\" ) self % isDimensionless = . true . case ( \"q3\" ) self % isDimensionless = . true . case ( \"q4\" ) self % isDimensionless = . true . case ( \"q5\" ) self % isDimensionless = . true . !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! case default if ( MPI_Process % isRoot ) then if ( len_trim ( self % variable ( i )) . eq . 0 ) then print * , \"Variable was not specified for surface Sampling \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ( i )), '\" surface Sampling ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * shearstress-tangent\" print * , \"   * shearstress-x\" print * , \"   * shearstress-y\" print * , \"   * shearstress-z\" print * , \"   * pressure\" stop \"Stopped.\" end if end if ! !        ********** end select !        ********** END DO ! !        Get the number of Order and the sampling interval !        ------------------------------------------------- if ( mesh % zones ( self % marker ) % no_of_faces . gt . 0 ) then Nf ( 1 ) = mesh % faces ( mesh % zones ( self % marker ) % faces ( 1 ))% Nf ( 1 ) + 1 Nf ( 2 ) = mesh % faces ( mesh % zones ( self % marker ) % faces ( 1 ))% Nf ( 2 ) + 1 nData = mesh % zones ( self % marker ) % no_of_faces * Nf ( 1 ) * Nf ( 2 ) else self % active = . false . Nf ( 1 ) = 0 Nf ( 2 ) = 0 nData = 0 end if self % interval = GetRealValue ( bufferInt ) ALLOCATE ( self % nData ( MPI_Process % nProcs )) if ( MPI_Process % doMPIAction ) then #ifdef _HAS_MPI_ call mpi_allgather ( nData , 1 , MPI_INT , allnData , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) nData = sum ( allnData ) self % nData = allnData self % rank = maxloc ( allnData , 1 ) - 1 call mpi_allgather ( Nf ( 1 ), 1 , MPI_INT , allnData , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) Nf ( 1 ) = maxval ( allnData ) call mpi_allgather ( Nf ( 2 ), 1 , MPI_INT , allnData , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) Nf ( 2 ) = maxval ( allnData ) #endif end if ! !       Get the max. number of timestep in the buffer file before being written !       ----------------------------------------------------------------------- IF ( LEN ( TRIM ( writeInterval )) . EQ . 0 ) THEN self % bufferSize = 1 ; ELSE self % bufferSize = GetRealValue ( writeInterval ) ! !           Failsafe to prevent too many data being written at one time !           ----------------------------------------------------------- IF ( nData . GT . 200000 ) THEN self % bufferSize = 1 ; END IF END IF ALLOCATE ( X ( nDATA , 3 ), self % fileName ( self % nVariables ), X1 ( nData , MPI_Process % nProcs ), & X2 ( nData , MPI_Process % nProcs ), X3 ( nData , MPI_Process % nProcs ) ) if ( MPI_Process % isRoot ) then ALLOCATE ( self % values ( nData + 1 , self % bufferSize , self % nVariables )) end if k = 0 do zonefID = 1 , mesh % zones ( self % marker ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( self % marker ) % faces ( zonefID ) do j = 0 , Nf ( 2 ) - 1 ; do i = 0 , Nf ( 1 ) - 1 k = k + 1 X ( k , 1 ) = mesh % faces ( fID ) % geom % x ( 1 , i , j ) X ( k , 2 ) = mesh % faces ( fID ) % geom % x ( 2 , i , j ) X ( k , 3 ) = mesh % faces ( fID ) % geom % x ( 3 , i , j ) end do ; end do end do if ( MPI_Process % doMPIAction ) then #ifdef _HAS_MPI_ call mpi_allgather ( X (:, 1 ), nData , MPI_DOUBLE , X1 , nData , MPI_DOUBLE , MPI_COMM_WORLD , ierr ) call mpi_allgather ( X (:, 2 ), nData , MPI_DOUBLE , X2 , nData , MPI_DOUBLE , MPI_COMM_WORLD , ierr ) call mpi_allgather ( X (:, 3 ), nData , MPI_DOUBLE , X3 , nData , MPI_DOUBLE , MPI_COMM_WORLD , ierr ) if ( MPI_Process % isRoot ) then X (:, 1 ) = X1 (:, 1 ) X (:, 2 ) = X2 (:, 1 ) X (:, 3 ) = X3 (:, 1 ) do i = 1 , MPI_Process % nProcs - 1 X ( sum ( self % nData ( 1 : i )) + 1 : sum ( self % nData ( 1 : i + 1 )), 1 ) = X1 ( 1 : self % nData ( i + 1 ), i + 1 ) X ( sum ( self % nData ( 1 : i )) + 1 : sum ( self % nData ( 1 : i + 1 )), 2 ) = X2 ( 1 : self % nData ( i + 1 ), i + 1 ) X ( sum ( self % nData ( 1 : i )) + 1 : sum ( self % nData ( 1 : i + 1 )), 3 ) = X3 ( 1 : self % nData ( i + 1 ), i + 1 ) end do end if #endif end if DO i = 1 , self % nVariables ! !        Prepare the file in which the Sampling is exported !        ------------------------------------------------- write ( self % fileName ( i ) , '(A,A,A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( markerName ) , \"_\" , trim ( self % variable ( i )) & , \"_surface_\" , self % ID , \".sampling\" #if defined(NAVIERSTOKES) && (!(INCNS)) ! !        Create file !        ----------- if ( FirstCall ) then if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ( i )) , action = \"write\" , access = \"stream\" , status = \"replace\" , position = 'append' ) ! !        Write the file headers !        ---------------------- write ( fID ) self % ID write ( fID ) Nf ( 1 ) write ( fID ) Nf ( 2 ) write ( fID ) nData write ( fID ) self % interval write ( fID ) refValues % rho write ( fID ) refValues % V write ( fID ) refValues % p write ( fID ) refValues % T write ( fID ) refValues % mu write ( fID ) refValues % AoATheta write ( fID ) refValues % AoAPhi write ( fID ) X (:, 1 ) write ( fID ) X (:, 2 ) write ( fID ) X (:, 3 ) close ( fID ) end if end if #endif END DO ! !        Write Information into log !        -------------------------- write ( formatFile , '(A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( markerName ) , \"_'variable'_surface_\" , self % ID , \".sampling\" if ( . not . MPI_Process % isRoot ) return ! !        Write Information !        ----------------------------------------------- write ( STD_OUT , '(/)' ) call SubSection_Header ( \"Surface Samplings\" ) write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"Surface Sampling ID: \" , self % ID write ( STD_OUT , '(30X,A,A27,A27)' ) \"->\" , \"Surface Name: \" , markerName write ( STD_OUT , '(30X,A,A27,A128)' ) \"->\" , \"Variables: \" , variables write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"Samplings Interval: \" , self % interval write ( STD_OUT , '(30X,A,A27,A128)' ) \"->\" , \"Filename: \" , formatFile write ( STD_OUT , '(30X,A,A27,A25)' ) \"->\" , \"Note: \" , \"Extracted with dimension\" deallocate ( X , X1 , X2 , X3 ) end subroutine SurfaceSampling_Initialization subroutine SurfaceSampling_Update ( self , mesh , bufferPosition , t ) ! !        ******************************************************************* !           This subroutine updates the Sampling value computing it from !           the mesh. It is stored in the \"bufferPosition\" position of the !           buffer. !        ******************************************************************* ! use SamplingOperator implicit none class ( SurfaceSampling_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition real ( kind = RP ) :: t integer :: i , j , k , recv_req ( MPI_Process % nProcs - 1 ), send_req , ierr real ( kind = RP ) :: F ( NDIM ) real ( kind = RP ), allocatable :: data_out (:) if ( self % intervalCount . EQ . 0 ) then self % bufferLine = self % bufferLine + 1 if (( self % nData ( MPI_Process % rank + 1 ) . gt . 0 ). or . MPI_Process % isRoot ) then DO i = 1 , self % nVariables select case ( trim ( self % variable ( i ) ) ) case ( \"shearstress-tangent\" ) Call VectorSurfaceSampling ( mesh , self % marker , SHEAR_STRESS_TANGENT , self % SamplingName , data_out ) case ( \"shearstress-x\" ) Call VectorSurfaceSampling ( mesh , self % marker , SHEAR_STRESS_X , self % SamplingName , data_out ) case ( \"shearstress-y\" ) Call VectorSurfaceSampling ( mesh , self % marker , SHEAR_STRESS_Y , self % SamplingName , data_out ) case ( \"shearstress-z\" ) Call VectorSurfaceSampling ( mesh , self % marker , SHEAR_STRESS_Z , self % SamplingName , data_out ) case ( \"pressure\" ) Call VectorSurfaceSampling ( mesh , self % marker , PRESSURE_SURF , self % SamplingName , data_out ) case ( \"q1\" ) Call VectorSurfaceSampling ( mesh , self % marker , Q1 , self % SamplingName , data_out ) case ( \"q2\" ) Call VectorSurfaceSampling ( mesh , self % marker , Q2 , self % SamplingName , data_out ) case ( \"q3\" ) Call VectorSurfaceSampling ( mesh , self % marker , Q3 , self % SamplingName , data_out ) case ( \"q4\" ) Call VectorSurfaceSampling ( mesh , self % marker , Q4 , self % SamplingName , data_out ) case ( \"q5\" ) Call VectorSurfaceSampling ( mesh , self % marker , Q5 , self % SamplingName , data_out ) end select if ( MPI_Process % doMPIAction ) then #ifdef _HAS_MPI_ if ( MPI_Process % isRoot ) then self % values (:, bufferPosition , i ) = 0_RP self % values ( 1 , bufferPosition , i ) = t if ( self % nData ( 1 ) . gt . 0 ) then self % values ( 2 : self % nData ( 1 ) + 1 , bufferPosition , i ) = data_out end if k = 0 DO j = 1 , MPI_Process % nProcs - 1 if ( self % nData ( j + 1 ) . gt . 0 ) then k = k + 1 call mpi_irecv ( self % values ( sum ( self % nData ( 1 : j )) + 1 : sum ( self % nData ( 1 : j )) + 1 + self % nData ( j + 1 ), bufferPosition , i ), & self % nData ( j + 1 ), MPI_DOUBLE , j , MPI_ANY_TAG , MPI_COMM_WORLD , recv_req ( k ), ierr ) call mpi_wait ( recv_req ( k ), MPI_STATUS_IGNORE , ierr ) end if END DO else if ( self % nData ( MPI_Process % rank + 1 ) . gt . 0 ) then call mpi_isend ( data_out , self % nData ( MPI_Process % rank + 1 ), MPI_DOUBLE , 0 , & DEFAULT_TAG , MPI_COMM_WORLD , send_req , ierr ) call mpi_wait ( send_req , MPI_STATUS_IGNORE , ierr ) send_req = 0 end if end if #endif else self % values ( 1 , bufferPosition , i ) = t self % values ( 2 : size ( data_out , 1 ) + 1 , bufferPosition , i ) = data_out end if END DO end if end if self % intervalCount = self % intervalCount + 1 if ( self % intervalCount . EQ . self % interval ) then self % intervalCount = 0 end if end subroutine SurfaceSampling_Update subroutine SurfaceSampling_WriteToFile ( self , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( SurfaceSampling_t ) :: self integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i , k integer :: fID if ( MPI_Process % isRoot ) then DO k = 1 , self % nVariables open ( newunit = fID , file = trim ( self % fileName ( k ) ) , action = \"write\" , access = \"stream\" , status = \"old\" , position = 'append' ) do i = 1 , no_of_lines write ( fID ) self % values (:, i , k ) end do close ( fID ) if ( no_of_lines . ne . 0 ) self % values (:, 1 , k ) = self % values (:, no_of_lines , k ) END DO end if self % bufferLine = 0 end subroutine SurfaceSampling_WriteToFile ! elemental subroutine SurfaceSampling_Destruct ( self ) implicit none class ( SurfaceSampling_t ), intent ( inout ) :: self safedeallocate ( self % values ) safedeallocate ( self % nData ) safedeallocate ( self % fileName ) safedeallocate ( self % variable ) end subroutine SurfaceSampling_Destruct ! !////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! elemental subroutine SurfaceSampling_Assign ( to , from ) implicit none class ( SurfaceSampling_t ), intent ( inout ) :: to type ( SurfaceSampling_t ), intent ( in ) :: from if ( from % active ) then to % active = from % active to % isDimensionless = from % isDimensionless to % ID = from % ID to % nVariables = from % nVariables to % marker = from % marker to % interval = from % interval to % bufferSize = from % bufferSize to % bufferLine = from % bufferLine to % intervalCount = from % intervalCount safedeallocate ( to % values ) allocate ( to % values ( size ( from % values , 1 ), size ( from % values , 2 ), size ( from % values , 3 ) ) ) to % values = from % values to % SamplingName = from % SamplingName safedeallocate ( to % fileName ) allocate ( to % fileName ( size ( from % fileName ) ) ) to % fileName = from % fileName safedeallocate ( to % variable ) allocate ( to % variable ( size ( from % variable ) ) ) to % variable = from % variable else to % active = . FALSE . end if end subroutine SurfaceSampling_Assign end module SurfaceSampling","tags":"","url":"sourcefile/surfacesampling.f90.html"},{"title":"SurfaceMonitor.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module SurfaceMonitorClass use SMConstants use HexMeshClass use MonitorDefinitions use PhysicsStorage use MPI_Process_Info use FluidData use FileReadingUtilities , only : getRealArrayFromString implicit none #if defined(NAVIERSTOKES) || defined(INCNS) private public SurfaceMonitor_t ! !  ******************************** !  Surface monitor class definition !  ******************************** ! type SurfaceMonitor_t logical :: active logical :: isDimensionless , IBM = . false . integer :: ID real ( kind = RP ) :: direction ( NDIM ) integer :: marker real ( kind = RP ), allocatable :: referenceSurface real ( kind = RP ), allocatable :: values (:) real ( kind = RP ) :: dynamicPressure character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => SurfaceMonitor_Initialization procedure :: Update => SurfaceMonitor_Update procedure :: WriteLabel => SurfaceMonitor_WriteLabel procedure :: WriteValues => SurfaceMonitor_WriteValue procedure :: WriteToFile => SurfaceMonitor_WriteToFile procedure :: destruct => SurfaceMonitor_Destruct procedure :: copy => SurfaceMonitor_Assign generic :: assignment ( = ) => copy end type SurfaceMonitor_t contains ! !///////////////////////////////////////////////////////////////////////// ! !           SURFACE MONITOR PROCEDURES !           -------------------------- !///////////////////////////////////////////////////////////////////////// ! subroutine SurfaceMonitor_Initialization ( self , mesh , ID , solution_file , FirstCall ) ! !        ***************************************************************************** !              This subroutine initializes the surface monitor. The following !           data is obtained from the case file: !              -> Name: The monitor name (10 characters maximum) !              -> Marker: The surface marker in which the monitor will be computed. !              -> Variable: The variable to be monitorized. !              -> Reference surface (optional): Reference surface for lift/drag coefficients !              -> Direction (optional): Direction in which the forces are computed !        ***************************************************************************** ! use ParamfileRegions implicit none class ( SurfaceMonitor_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile character ( len = STR_LEN_MONITORS ) :: directionName integer , allocatable :: marker character ( len = STR_LEN_MONITORS ) :: markerName integer :: pos , i , STLNum integer :: fID integer :: zoneID real ( kind = RP ) :: directionValue ( NDIM ) ! !        Get monitor ID !        -------------- self % ID = ID ! !        Search for the parameters in the case file !        ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define surface monitor \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ) , \"name\" , self % monitorName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"marker\" , markerName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"variable\" , self % variable , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"reference surface\" , self % referenceSurface , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"direction\" , directionName , in_label , \"# end\" ) ! !        Enable the monitor !        ------------------ self % active = . true . allocate ( self % values ( BUFFER_SIZE ) ) ! !        Get the surface marker !        ---------------------- self % marker = - 1 if ( mesh % IBM % active ) then do STLNum = 1 , mesh % IBM % NumOfSTL if ( mesh % IBM % Integral ( STLNum )% compute ) cycle if ( trim ( mesh % IBM % STLfilename ( STLNum )) . eq . trim ( markerName ) ) then if ( . not . mesh % IBM % ComputeBandRegion ) then write ( * , '(A)' ) \"Warning: for surface monitors with IBM, 'band region' must be set '.true.'\" error stop end if self % marker = STLNum self % IBM = . true . mesh % IBM % Integral ( STLNum )% compute = . true . mesh % IBM % Integral ( STLNum )% ListComputed = . false . if ( MPI_Process % isRoot ) then call mesh % IBM % stlSurfaceIntegrals ( STLNum )% ReadTessellation ( mesh % IBM % STLfilename ( STLNum ) ) if ( mesh % IBM % ClipAxis . ne . 0 ) call mesh % IBM % stlSurfaceIntegrals ( STLNum )% Clip ( mesh % IBM % minCOORDS , mesh % IBM % maxCOORDS , mesh % IBM % ClipAxis , . false . ) call mesh % IBM % stlSurfaceIntegrals ( STLNum )% SetIntegrationPoints () call mesh % IBM % stlSurfaceIntegrals ( STLNum )% SetIntegration ( mesh % IBM % NumOfInterPoints ) end if call mesh % IBM % SetIntegration ( STLNum ) exit end if end do else do zoneID = 1 , size ( mesh % zones ) if ( trim ( mesh % zones ( zoneID ) % name ) . eq . trim ( markerName ) ) then self % marker = zoneID exit end if end do end if if ( self % marker . eq . - 1 ) then self % active = . false . write ( * , '(A,I0)' ) \"Warning: Marker not specified for surface monitor \" , self % ID write ( * , '(A,I0,A)' ) \"     Surface monitor \" , self % ID , \" disabled.\" end if ! !        Select the variable from the available list, and compute auxiliary variables if needed !        -------------------------------------------------------------------------------------- ! !        **************************************** select case ( trim ( self % variable ) ) !        **************************************** ! case ( \"mass-flow\" ) self % isDimensionless = . false . case ( \"flow\" ) self % isDimensionless = . false . case ( \"pressure-force\" ) self % isDimensionless = . false . if ( len_trim ( directionName ) . eq . 0 ) then print * , \"Direction not specified for pressure-force in surface monitor \" , self % ID , \".\" error stop \"error stopped\" else directionValue = getRealArrayFromString ( directionName ) if ( size ( directionValue ) . ne . 3 ) then print * , \"Incorrect direction for monitor \" , self % ID , \".\" else self % direction = directionValue end if end if case ( \"viscous-force\" ) self % isDimensionless = . false . if ( len_trim ( directionName ) . eq . 0 ) then print * , \"Direction not specified for pressure-force in surface monitor \" , self % ID , \".\" error stop \"error stopped\" else directionValue = getRealArrayFromString ( directionName ) if ( size ( directionValue ) . ne . 3 ) then print * , \"Incorrect direction for monitor \" , self % ID , \".\" else self % direction = directionValue end if end if case ( \"force\" ) self % isDimensionless = . false . if ( len_trim ( directionName ) . eq . 0 ) then print * , \"Direction not specified for pressure-force in surface monitor \" , self % ID , \".\" error stop \"error stopped\" else directionValue = getRealArrayFromString ( directionName ) if ( size ( directionValue ) . ne . 3 ) then print * , \"Incorrect direction for monitor \" , self % ID , \".\" else self % direction = directionValue end if end if case ( \"lift\" ) self % isDimensionless = . true . if ( . not . allocated ( self % referenceSurface ) ) then print * , \"Reference surface not specified for lift surface monitor \" , self % ID , \".\" error stop \"error stopped\" end if if ( len_trim ( directionName ) . eq . 0 ) then print * , \"Direction not specified for lift in surface monitor \" , self % ID , \".\" print * , \"    ...  Using [0,1,0] as default.\" self % direction = [ 0._RP , 1._RP , 0._RP ] else directionValue = getRealArrayFromString ( directionName ) if ( size ( directionValue ) . ne . 3 ) then print * , \"Incorrect direction for monitor \" , self % ID , \".\" else self % direction = directionValue end if end if self % dynamicPressure = 0.5_RP * refValues % rho * POW2 ( refValues % V ) * self % referenceSurface case ( \"drag\" ) self % isDimensionless = . true . if ( . not . allocated ( self % referenceSurface ) ) then print * , \"Reference surface not specified for drag surface monitor \" , self % ID , \".\" error stop \"error stopped\" end if if ( len_trim ( directionName ) . eq . 0 ) then print * , \"Direction not specified for drag in surface monitor \" , self % ID , \".\" print * , \"    ...  Using [1,0,0] as default.\" self % direction = [ 1._RP , 0._RP , 0._RP ] else directionValue = getRealArrayFromString ( directionName ) if ( size ( directionValue ) . ne . 3 ) then print * , \"Incorrect direction for monitor \" , self % ID , \".\" else self % direction = directionValue end if end if self % dynamicPressure = 0.5_RP * refValues % rho * refValues % V * refValues % V * self % referenceSurface case ( \"pressure-average\" ) self % isDimensionless = . false . case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for surface monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" surface monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * mass-flow\" print * , \"   * flow\" print * , \"   * pressure-force\" print * , \"   * viscous-force\" print * , \"   * force\" print * , \"   * lift\" print * , \"   * drag\" print * , \"   * pressure-average\" error stop \"error stopped.\" end if ! !        ********** end select !        ********** ! !        Prepare the file in which the monitor is exported !        ------------------------------------------------- write ( self % fileName , '(A,A,A,A)' ) trim ( solution_file ) , \".\" , trim ( self % monitorName ) , \".surface\" ! !        Create file !        ----------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) ! !        Write the file headers !        ---------------------- write ( fID , '(A20,A  )' ) \"Monitor name:      \" , trim ( self % monitorName ) write ( fID , '(A20,I0 )' ) \"Surface marker:    \" , self % marker write ( fID , '(A20,A  )' ) \"Selected variable: \" , trim ( self % variable ) if ( self % isDimensionless ) then write ( fID , '(A20,ES24.10)' ) \"Dynamic pressure: \" , self % dynamicPressure end if write ( fID , * ) write ( fID , '(A10,2X,A24,2X,A24)' ) \"Iteration\" , \"Time\" , trim ( self % variable ) close ( fID ) end if end subroutine SurfaceMonitor_Initialization subroutine SurfaceMonitor_Update ( self , mesh , bufferPosition , iter , autosave , dt ) ! !        ******************************************************************* !           This subroutine updates the monitor value computing it from !           the mesh. It is stored in the \"bufferPosition\" position of the !           buffer. !        ******************************************************************* ! use SurfaceIntegrals use IBMClass implicit none class ( SurfaceMonitor_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition , iter , STLNum real ( kind = RP ) :: F ( NDIM ) real ( kind = RP ) :: dt logical :: autosave select case ( trim ( self % variable ) ) case ( \"mass-flow\" ) if ( self % IBM ) then STLNum = self % marker call ScalarDataReconstruction ( mesh % IBM , mesh % elements , STLNum , MASS_FLOW , iter , autosave , dt ) self % values ( bufferPosition ) = mesh % IBM % stlSurfaceIntegrals ( STLNum )% ComputeScalarIntegral () else self % values ( bufferPosition ) = ScalarSurfaceIntegral ( mesh , self % marker , MASS_FLOW , iter ) end if case ( \"flow\" ) if ( self % IBM ) then STLNum = self % marker call ScalarDataReconstruction ( mesh % IBM , mesh % elements , STLNum , FLOW_RATE , iter , autosave , dt ) self % values ( bufferPosition ) = mesh % IBM % stlSurfaceIntegrals ( STLNum )% ComputeScalarIntegral () else self % values ( bufferPosition ) = ScalarSurfaceIntegral ( mesh , self % marker , FLOW_RATE , iter ) end if case ( \"pressure-force\" ) if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , PRESSURE_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum )% ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , PRESSURE_FORCE , iter ) end if F = refValues % rho * POW2 ( refValues % V ) * POW2 ( Lref ) * F self % values ( bufferPosition ) = dot_product ( F , self % direction ) case ( \"viscous-force\" ) if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , VISCOUS_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum )% ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , VISCOUS_FORCE , iter ) end if F = refValues % rho * POW2 ( refValues % V ) * POW2 ( Lref ) * F self % values ( bufferPosition ) = dot_product ( F , self % direction ) case ( \"force\" ) if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , TOTAL_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum ) % ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , TOTAL_FORCE , iter ) end if F = refValues % rho * POW2 ( refValues % V ) * POW2 ( Lref ) * F self % values ( bufferPosition ) = dot_product ( F , self % direction ) case ( \"lift\" ) if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , TOTAL_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum ) % ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , TOTAL_FORCE , iter ) end if F = 2.0_RP * POW2 ( Lref ) * F / self % referenceSurface self % values ( bufferPosition ) = dot_product ( F , self % direction ) #if defined (NAVIERSTOKES) case ( \"drag\" ) if ( flowIsNavierStokes ) then if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , TOTAL_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum ) % ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , TOTAL_FORCE , iter ) end if else if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , TOTAL_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum ) % ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , PRESSURE_FORCE , iter ) end if end if F = 2.0_RP * POW2 ( Lref ) * F / self % referenceSurface self % values ( bufferPosition ) = dot_product ( F , self % direction ) #endif !TODO if true #if defined (INCNS) case ( \"drag\" ) if (. true .) then if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , TOTAL_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum ) % ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , TOTAL_FORCE , iter ) end if else if ( self % IBM ) then STLNum = self % marker call VectorDataReconstruction ( mesh % IBM , mesh % elements , STLNum , TOTAL_FORCE , iter , autosave , dt ) F = mesh % IBM % stlSurfaceIntegrals ( STLNum ) % ComputeVectorIntegral () else F = VectorSurfaceIntegral ( mesh , self % marker , PRESSURE_FORCE , iter ) end if end if F = 2.0_RP * POW2 ( Lref ) * F / self % referenceSurface self % values ( bufferPosition ) = dot_product ( F , self % direction ) #endif case ( \"pressure-average\" ) self % values ( bufferPosition ) = ScalarSurfaceIntegral ( mesh , self % marker , PRESSURE_FORCE , iter ) / ScalarSurfaceIntegral ( mesh , self % marker , SURFACE , iter ) end select end subroutine SurfaceMonitor_Update subroutine SurfaceMonitor_WriteLabel ( self ) ! !        ************************************************************* !              This subroutine writes the label for the surface !           monitor, when invoked from the time integrator Display !           procedure. !        ************************************************************* ! implicit none class ( SurfaceMonitor_t ), intent ( in ) :: self write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) trim ( self % monitorName ( 1 : MONITOR_LENGTH )) end subroutine SurfaceMonitor_WriteLabel subroutine SurfaceMonitor_WriteValue ( self , bufferLine ) ! !        ************************************************************* !              This subroutine writes the monitor value for the time !           integrator Display procedure. !        ************************************************************* ! implicit none class ( SurfaceMonitor_t ) :: self integer :: bufferLine write ( STD_OUT , '(1X,A,1X,ES10.3)' , advance = \"no\" ) \"|\" , self % values ( bufferLine ) end subroutine SurfaceMonitor_WriteValue subroutine SurfaceMonitor_WriteToFile ( self , iter , t , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( SurfaceMonitor_t ) :: self integer :: iter (:) real ( kind = RP ) :: t (:) integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i integer :: fID if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) do i = 1 , no_of_lines write ( fID , '(I10,2X,ES24.16,2X,ES24.16)' ) iter ( i ) , t ( i ) , self % values ( i ) end do close ( fID ) end if if ( no_of_lines . ne . 0 ) self % values ( 1 ) = self % values ( no_of_lines ) end subroutine SurfaceMonitor_WriteToFile ! elemental subroutine SurfaceMonitor_Destruct ( self ) implicit none class ( SurfaceMonitor_t ), intent ( inout ) :: self safedeallocate ( self % values ) safedeallocate ( self % referenceSurface ) end subroutine SurfaceMonitor_Destruct ! !////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! elemental subroutine SurfaceMonitor_Assign ( to , from ) implicit none class ( SurfaceMonitor_t ), intent ( inout ) :: to type ( SurfaceMonitor_t ), intent ( in ) :: from if ( from % active ) then to % active = from % active to % isDimensionless = from % isDimensionless to % ID = from % ID to % direction = from % direction to % marker = from % marker safedeallocate ( to % referenceSurface ) if ( allocated ( from % referenceSurface ) ) then allocate ( to % referenceSurface ) to % referenceSurface = from % referenceSurface end if safedeallocate ( to % values ) allocate ( to % values ( size ( from % values ) ) ) to % values = from % values to % dynamicPressure = from % dynamicPressure to % monitorName = from % monitorName to % fileName = from % fileName to % variable = from % variable else to % active = . FALSE . end if end subroutine SurfaceMonitor_Assign #endif end module SurfaceMonitorClass","tags":"","url":"sourcefile/surfacemonitor.f90.html"},{"title":"StatisticsMonitor.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" #if defined(NAVIERSTOKES) || defined(INCNS) module StatisticsMonitor use SMConstants use HexMeshClass use StorageClass use Utilities , only : GreatestCommonDivisor #ifdef _HAS_MPI_ use mpi #endif private public StatisticsMonitor_t , U , V , W , UU , VV , WW , UV , UW , VW public NO_OF_VARIABLES_Sij , NO_OF_VARIABLES ! !  Commands for the parameter file !  ------------------------------- #define START_COMMAND \"@start\" #define PAUSE_COMMAND \"@pause\" #define STOP_COMMAND \"@stop\" #define RESET_COMMAND \"@reset\" #define DUMP_COMMAND \"@dump\" ! !  Statistics monitor states !  ------------------------- #define OFF 0 #define WAITING_STATE 1 #define STOP_STATE 2 #define ACTIVE_STATE 3 ! !  Statistics monitor content !  -------------------------- integer :: NO_OF_VARIABLES integer , parameter :: NO_OF_VARIABLES_Sij = 9 integer , parameter :: U = 1 integer , parameter :: V = 2 integer , parameter :: W = 3 integer , parameter :: UU = 4 integer , parameter :: VV = 5 integer , parameter :: WW = 6 integer , parameter :: UV = 7 integer , parameter :: UW = 8 integer , parameter :: VW = 9 type StatisticsMonitor_t integer :: state integer :: sampling_interval integer :: dump_interval integer :: reset_interval integer :: starting_iteration real ( kind = RP ) :: starting_time integer :: no_of_samples logical :: saveGradients contains procedure :: Construct => StatisticsMonitor_Construct procedure :: Update => StatisticsMonitor_Update procedure :: UpdateValues => StatisticsMonitor_UpdateValues procedure :: GetState => StatisticsMonitor_GetState procedure :: WriteLabel => StatisticsMonitor_WriteLabel procedure :: WriteValue => StatisticsMonitor_WriteValue procedure :: WriteFile => StatisticsMonitor_WriteFile end type StatisticsMonitor_t ! !  ======== contains !  ======== ! !////////////////////////////////////////////////////////////////////////////////// ! subroutine StatisticsMonitor_Construct ( self , mesh , saveGradients ) use ParamfileRegions use PhysicsStorage , only : NCONS , NGRAD use HexMeshClass , only : no_of_stats_variables implicit none class ( StatisticsMonitor_t ) :: self class ( HexMesh ) :: mesh logical , intent ( in ) :: saveGradients integer , allocatable :: Nsample , i0 , Ndump , Nreset real ( kind = RP ), allocatable :: t0 integer :: eID character ( len = LINE_LENGTH ) :: paramFile NO_OF_VARIABLES = NO_OF_VARIABLES_Sij + NCONS self % saveGradients = saveGradients if ( saveGradients ) NO_OF_VARIABLES = NO_OF_VARIABLES + NGRAD * NDIM no_of_stats_variables = NO_OF_VARIABLES ! !        Search for the parameters in the case file !        ------------------------------------------ call get_command_argument ( 1 , paramFile ) ! !        Search if the #define statistics section is defined !        --------------------------------------------------- if ( findIfStatsAreActive ( paramFile ) ) then self % state = WAITING_STATE else self % state = OFF return end if call readValueInRegion ( trim ( paramFile ) , \"sampling interval\" , Nsample , \"#define statistics\" , \"#end\" ) call readValueInRegion ( trim ( paramFile ) , \"starting iteration\" , i0 , \"#define statistics\" , \"#end\" ) call readValueInRegion ( trim ( paramFile ) , \"starting time\" , t0 , \"#define statistics\" , \"#end\" ) call readValueInRegion ( trim ( paramFile ) , \"dump interval\" , Ndump , \"#define statistics\" , \"#end\" ) call readValueInRegion ( trim ( paramFile ) , \"reset interval\" , Nreset , \"#define statistics\" , \"#end\" ) ! !        Check the input data !        -------------------- if ( allocated ( i0 ) ) self % starting_iteration = i0 ! Both iteration and time can start the statistics calculation if ( allocated ( t0 ) ) self % starting_time = t0 ! if ( allocated ( i0 ) . and . (. not . allocated ( t0 )) ) self % starting_time = huge ( 1.0_RP ) ! Statistics controlled by iterations if ( allocated ( t0 ) . and . (. not . allocated ( i0 )) ) self % starting_iteration = huge ( 1 ) ! Statistics controlled by time if ( (. not . allocated ( i0 )) . and . (. not . allocated ( t0 )) ) then ! self % starting_time = 0.0_RP ! Start since the beginning by default self % starting_iteration = 0 ! end if ! if ( allocated ( Nsample ) ) then ! self % sampling_interval = Nsample !  Set 1 by default else ! self % sampling_interval = 1 ! end if if ( allocated ( Ndump ) ) then ! self % dump_interval = Ndump !  Set huge by default else ! self % dump_interval = huge ( 1 ) ! end if ! if ( allocated ( Nreset ) ) then ! if ( allocated ( Ndump ) ) then ! self % dump_interval = GreatestCommonDivisor ( Nreset , Ndump ) !  Set huge by default else ! self % dump_interval = Nreset ! end if ! self % reset_interval = Nreset ! else ! self % reset_interval = huge ( 1 ) ! end if ! ! !        Initial state: waiting !        ---------------------- self % state = WAITING_STATE self % no_of_samples = 0 ! !        Construct the data !        ------------------ do eID = 1 , mesh % no_of_elements associate ( e => mesh % elements ( eID )) call e % storage % stats % Construct ( NO_OF_VARIABLES , e % Nxyz ) end associate end do end subroutine StatisticsMonitor_Construct subroutine StatisticsMonitor_WriteFile ( self , mesh , iter , t , solution_file ) implicit none class ( StatisticsMonitor_t ) :: self class ( HexMesh ) :: mesh integer , intent ( in ) :: iter real ( kind = RP ), intent ( in ) :: t character ( len =* ), intent ( in ) :: solution_file character ( len = LINE_LENGTH ) :: fileName write ( fileName , '(A,A)' ) trim ( solution_file ), '.stats.hsol' if ( self % state . ne . OFF ) call mesh % SaveStatistics ( iter , t , trim ( fileName ), self % saveGradients ) end subroutine StatisticsMonitor_WriteFile subroutine StatisticsMonitor_Update ( self , mesh , iter , t , solution_file ) implicit none class ( StatisticsMonitor_t ) :: self class ( HexMesh ) :: mesh integer , intent ( in ) :: iter real ( kind = RP ), intent ( in ) :: t character ( len =* ), intent ( in ) :: solution_file ! !        --------------- !        Local variables !        --------------- ! logical :: reset , dump character ( len = LINE_LENGTH ) :: fileName if ( self % state . eq . OFF ) return if ( mod ( iter , self % sampling_interval ) . ne . 0 ) return ! !        Read the parameter file to check the state !        ------------------------------------------ call self % GetState ( reset , dump ) ! !        Dump the contents if requested !        ------------------------------ if ( dump . or . ( ( mod ( iter , self % dump_interval ) == 0 ) . and . ( iter > self % starting_iteration . or . t > self % starting_time ) ) ) then write ( fileName , '(A,A,I10.10,A)' ) trim ( solution_file ), '.stats.' , iter , '.hsol' call mesh % SaveStatistics ( iter , t , trim ( fileName ), self % saveGradients ) write ( STD_OUT , '(A,A,A)' ) '   *** Saving statistics file as \"' , trim ( fileName ), '\".' end if ! !        Reset the statistics if requested !        --------------------------------- if ( reset . or . ( ( mod ( iter , self % reset_interval ) == 0 ) . and . ( iter > self % starting_iteration ) ) ) then call mesh % ResetStatistics self % no_of_samples = 0 end if ! !        Update the state if it is waiting !        --------------------------------- if ( self % state . eq . WAITING_STATE ) then if ( ( t . gt . self % starting_time ) . or . ( iter . ge . self % starting_iteration ) ) then self % state = ACTIVE_STATE end if end if !        Update the values if the state is \"active\" !        ------------------------------------------ if ( self % state . eq . ACTIVE_STATE ) call self % UpdateValues ( mesh ) end subroutine StatisticsMonitor_Update subroutine StatisticsMonitor_UpdateValues ( self , mesh ) use PhysicsStorage implicit none class ( StatisticsMonitor_t ) :: self class ( HexMesh ) :: mesh ! !        --------------- !        Local variables !        --------------- ! integer :: eID integer :: i , j , k real ( RP ) :: ratio , inv_nsamples_plus_1 real ( RP ) :: rfactor1 , rfactor2 integer , dimension ( 5 ) :: limits #ifdef NAVIERSTOKES !  if gradients are not saved, limits(2) is equal to limits(5), the latter wont be used limits ( 1 ) = NO_OF_VARIABLES_Sij + IRHO limits ( 2 ) = NO_OF_VARIABLES_Sij + NCONS limits ( 3 ) = NO_OF_VARIABLES_Sij + NCONS + NGRAD limits ( 4 ) = NO_OF_VARIABLES_Sij + NCONS + 2 * NGRAD limits ( 5 ) = NO_OF_VARIABLES inv_nsamples_plus_1 = 1.0_RP / ( self % no_of_samples + 1 ) ratio = self % no_of_samples * inv_nsamples_plus_1 do eID = 1 , size ( mesh % elements ) associate ( e => mesh % elements ( eID ), & data => mesh % elements ( eID ) % storage % stats % data ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) rfactor1 = inv_nsamples_plus_1 / e % storage % Q ( IRHO , i , j , k ) rfactor2 = inv_nsamples_plus_1 / POW2 ( e % storage % Q ( IRHO , i , j , k ) ) data ( U , i , j , k ) = data ( U , i , j , k ) * ratio + e % storage % Q ( IRHOU , i , j , k ) * rfactor1 data ( V , i , j , k ) = data ( V , i , j , k ) * ratio + e % storage % Q ( IRHOV , i , j , k ) * rfactor1 data ( W , i , j , k ) = data ( W , i , j , k ) * ratio + e % storage % Q ( IRHOW , i , j , k ) * rfactor1 data ( UU , i , j , k ) = data ( UU , i , j , k ) * ratio + POW2 ( e % storage % Q ( IRHOU , i , j , k ) ) * rfactor2 data ( VV , i , j , k ) = data ( VV , i , j , k ) * ratio + POW2 ( e % storage % Q ( IRHOV , i , j , k ) ) * rfactor2 data ( WW , i , j , k ) = data ( WW , i , j , k ) * ratio + POW2 ( e % storage % Q ( IRHOW , i , j , k ) ) * rfactor2 data ( UV , i , j , k ) = data ( UV , i , j , k ) * ratio + e % storage % Q ( IRHOU , i , j , k ) * e % storage % Q ( IRHOV , i , j , k ) * rfactor2 data ( UW , i , j , k ) = data ( UW , i , j , k ) * ratio + e % storage % Q ( IRHOU , i , j , k ) * e % storage % Q ( IRHOW , i , j , k ) * rfactor2 data ( VW , i , j , k ) = data ( VW , i , j , k ) * ratio + e % storage % Q ( IRHOV , i , j , k ) * e % storage % Q ( IRHOW , i , j , k ) * rfactor2 data ( limits ( 1 ): limits ( 2 ), i , j , k ) = data ( limits ( 1 ): limits ( 2 ), i , j , k ) * ratio + e % storage % Q (:, i , j , k ) * inv_nsamples_plus_1 if ( self % saveGradients ) then data ( limits ( 2 ) + 1 : limits ( 3 ), i , j , k ) = data ( limits ( 2 ) + 1 : limits ( 3 ), i , j , k ) * ratio + e % storage % U_x (:, i , j , k ) * inv_nsamples_plus_1 data ( limits ( 3 ) + 1 : limits ( 4 ), i , j , k ) = data ( limits ( 3 ) + 1 : limits ( 4 ), i , j , k ) * ratio + e % storage % U_y (:, i , j , k ) * inv_nsamples_plus_1 data ( limits ( 4 ) + 1 : limits ( 5 ), i , j , k ) = data ( limits ( 4 ) + 1 : limits ( 5 ), i , j , k ) * ratio + e % storage % U_z (:, i , j , k ) * inv_nsamples_plus_1 end if end do ; end do ; end do end associate end do #endif #ifdef INCNS !  if gradients are not saved, limits(2) is equal to limits(5), the latter wont be used limits ( 1 ) = NO_OF_VARIABLES_Sij + INSRHO limits ( 2 ) = NO_OF_VARIABLES_Sij + NCONS limits ( 3 ) = NO_OF_VARIABLES_Sij + NCONS + NGRAD limits ( 4 ) = NO_OF_VARIABLES_Sij + NCONS + 2 * NGRAD limits ( 5 ) = NO_OF_VARIABLES inv_nsamples_plus_1 = 1.0_RP / ( self % no_of_samples + 1 ) ratio = self % no_of_samples * inv_nsamples_plus_1 do eID = 1 , size ( mesh % elements ) associate ( e => mesh % elements ( eID ), & data => mesh % elements ( eID ) % storage % stats % data ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) rfactor1 = inv_nsamples_plus_1 / e % storage % Q ( INSRHO , i , j , k ) rfactor2 = inv_nsamples_plus_1 / POW2 ( e % storage % Q ( INSRHO , i , j , k ) ) data ( U , i , j , k ) = data ( U , i , j , k ) * ratio + e % storage % Q ( INSRHOU , i , j , k ) * rfactor1 data ( V , i , j , k ) = data ( V , i , j , k ) * ratio + e % storage % Q ( INSRHOV , i , j , k ) * rfactor1 data ( W , i , j , k ) = data ( W , i , j , k ) * ratio + e % storage % Q ( INSRHOW , i , j , k ) * rfactor1 data ( UU , i , j , k ) = data ( UU , i , j , k ) * ratio + POW2 ( e % storage % Q ( INSRHOU , i , j , k ) ) * rfactor2 data ( VV , i , j , k ) = data ( VV , i , j , k ) * ratio + POW2 ( e % storage % Q ( INSRHOV , i , j , k ) ) * rfactor2 data ( WW , i , j , k ) = data ( WW , i , j , k ) * ratio + POW2 ( e % storage % Q ( INSRHOW , i , j , k ) ) * rfactor2 data ( UV , i , j , k ) = data ( UV , i , j , k ) * ratio + e % storage % Q ( INSRHOU , i , j , k ) * e % storage % Q ( INSRHOV , i , j , k ) * rfactor2 data ( UW , i , j , k ) = data ( UW , i , j , k ) * ratio + e % storage % Q ( INSRHOU , i , j , k ) * e % storage % Q ( INSRHOW , i , j , k ) * rfactor2 data ( VW , i , j , k ) = data ( VW , i , j , k ) * ratio + e % storage % Q ( INSRHOV , i , j , k ) * e % storage % Q ( INSRHOW , i , j , k ) * rfactor2 data ( limits ( 1 ): limits ( 2 ), i , j , k ) = data ( limits ( 1 ): limits ( 2 ), i , j , k ) * ratio + e % storage % Q (:, i , j , k ) * inv_nsamples_plus_1 if ( self % saveGradients ) then data ( limits ( 2 ) + 1 : limits ( 3 ), i , j , k ) = data ( limits ( 2 ) + 1 : limits ( 3 ), i , j , k ) * ratio + e % storage % U_x (:, i , j , k ) * inv_nsamples_plus_1 data ( limits ( 3 ) + 1 : limits ( 4 ), i , j , k ) = data ( limits ( 3 ) + 1 : limits ( 4 ), i , j , k ) * ratio + e % storage % U_y (:, i , j , k ) * inv_nsamples_plus_1 data ( limits ( 4 ) + 1 : limits ( 5 ), i , j , k ) = data ( limits ( 4 ) + 1 : limits ( 5 ), i , j , k ) * ratio + e % storage % U_z (:, i , j , k ) * inv_nsamples_plus_1 end if end do ; end do ; end do end associate end do #endif self % no_of_samples = self % no_of_samples + 1 end subroutine StatisticsMonitor_UpdateValues subroutine StatisticsMonitor_GetState ( self , reset , dump ) use ParamfileRegions use MPI_Process_Info implicit none class ( StatisticsMonitor_t ) :: self logical , intent ( out ) :: reset , dump ! !        --------------- !        Local variables !        --------------- ! integer :: fID , io , ierr integer :: no_of_lines character ( len = LINE_LENGTH ) :: paramFile character ( len = LINE_LENGTH ) :: line logical :: isInside logical :: hasStart , hasPause , hasStop , hasDump , hasReset integer :: rstInt , dumpInt reset = . false . dump = . false . ! !        Only root will read, and it will broadcast the result to the rest !        ----------------------------------------------------------------- if ( MPI_Process % isRoot ) then call get_command_argument ( 1 , paramFile ) ! !           Open the file and get to the statistics zone !           -------------------------------------------- open ( newunit = fID , file = trim ( paramFile ), status = \"old\" , action = \"read\" ) isInside = . false . no_of_lines = 0 hasStart = . false . hasPause = . false . hasStop = . false . hasReset = . false . hasDump = . false . do read ( fID , '(A)' , iostat = io ) line if ( io . ne . 0 ) exit no_of_lines = no_of_lines + 1 ! !              Check whether the line is in or out of the statistics region !              ------------------------------------------------------------ if ( index ( getSquashedLine ( trim ( adjustl ( line ))), \"#definestatistics\" ) . ne . 0 ) then isInside = . true . cycle end if if ( isInside . and . ( index ( getSquashedLine ( trim ( adjustl ( line ))), \"#end\" ) . ne . 0 ) ) then isInside = . false . cycle end if ! !              Cycle if it is outside !              ---------------------- if ( . not . isInside ) cycle ! !              It is inside, check whether the marks are present !              ------------------------------------------------- select case ( trim ( adjustl ( line )) ) case ( START_COMMAND ) if ( index ( line , \"*\" ) . eq . 0 ) hasStart = . true . case ( PAUSE_COMMAND ) if ( index ( line , \"*\" ) . eq . 0 ) hasPause = . true . case ( STOP_COMMAND ) if ( index ( line , \"*\" ) . eq . 0 ) hasStop = . true . case ( RESET_COMMAND ) if ( index ( line , \"*\" ) . eq . 0 ) hasReset = . true . case ( DUMP_COMMAND ) if ( index ( line , \"*\" ) . eq . 0 ) hasDump = . true . end select end do ! !           Update the status of the statistics monitor !           ------------------------------------------- reset = hasReset dump = hasDump if ( ( self % state . eq . WAITING_STATE ) . or . ( self % state . eq . ACTIVE_STATE ) ) then if ( hasStop ) then dump = . true . reset = . true . self % state = STOP_STATE end if if ( hasPause ) then self % state = STOP_STATE end if if ( hasStart ) then self % state = ACTIVE_STATE end if elseif ( self % state . eq . STOP_STATE ) then if ( hasStart ) self % state = ACTIVE_STATE end if close ( fID ) ! !           Rewrite the control file to remove the controllers !           -------------------------------------------------- if ( hasStart . or . hasPause . or . hasStop . or . hasReset . or . hasDump ) call rewriteControlFile ( paramFile , no_of_lines ) end if ! !        Broadcast the result to the rest of the processes !        ------------------------------------------------- if ( MPI_Process % DoMPIAction ) then #ifdef _HAS_MPI_ if ( reset ) then rstInt = 1 else rstInt = 0 end if if ( dump ) then dumpInt = 1 else dumpInt = 0 end if call mpi_bcast ( rstInt , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierr ) #endif end if end subroutine StatisticsMonitor_GetState logical function findIfStatsAreActive ( paramFile ) use ParamfileRegions implicit none character ( len =* ), intent ( in ) :: paramFile ! !        --------------- !        Local variables !        --------------- ! integer :: fID , io character ( len = LINE_LENGTH ) :: line open ( newunit = fID , file = trim ( paramFile ), action = \"read\" , status = \"old\" ) findIfStatsAreActive = . false . do read ( fID , '(A)' , iostat = io ) line if ( io . ne . 0 ) exit if ( index ( getSquashedLine ( line ), '#definestatistics' ) . ne . 0 ) then findIfStatsAreActive = . true . close ( fID ) return end if end do close ( fID ) end function findIfStatsAreActive subroutine rewriteControlFile ( paramFile , no_of_lines ) implicit none character ( len =* ), intent ( in ) :: paramFile integer , intent ( in ) :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: fID , i character ( len = LINE_LENGTH ) :: lines ( no_of_lines ) open ( newunit = fID , file = trim ( paramFIle ), action = \"read\" , status = \"old\" ) do i = 1 , no_of_lines read ( fID , '(A)' ) lines ( i ) select case ( trim ( adjustl ( lines ( i )))) case ( START_COMMAND ) lines ( i ) = \"   \" // START_COMMAND // \"*\" case ( PAUSE_COMMAND ) lines ( i ) = \"   \" // PAUSE_COMMAND // \"*\" case ( STOP_COMMAND ) lines ( i ) = \"   \" // STOP_COMMAND // \"*\" case ( DUMP_COMMAND ) lines ( i ) = \"   \" // DUMP_COMMAND // \"*\" case ( RESET_COMMAND ) lines ( i ) = \"   \" // RESET_COMMAND // \"*\" end select end do close ( fID ) open ( newunit = fID , file = trim ( paramFile ), action = \"write\" , status = \"old\" ) do i = 1 , no_of_lines write ( fID , '(A)' ) trim ( lines ( i )) end do close ( fID ) end subroutine rewriteControlFile subroutine StatisticsMonitor_WriteLabel ( self ) implicit none class ( StatisticsMonitor_t ) :: self if ( self % state . eq . OFF ) return write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"Stats.\" end subroutine StatisticsMonitor_WriteLabel subroutine StatisticsMonitor_WriteValue ( self ) ! !        ************************************************************* !              This subroutine writes the monitor value for the time !           integrator Display procedure. !        ************************************************************* ! implicit none class ( StatisticsMonitor_t ) :: self integer :: bufferLine character ( len = 10 ) :: state if ( self % state . eq . OFF ) return select case ( self % state ) case ( ACTIVE_STATE ) state = \"Active\" case ( WAITING_STATE ) state = \"Waiting\" case ( STOP_STATE ) state = \"Inactive\" end select write ( STD_OUT , '(1X,A,1X,A10)' , advance = \"no\" ) \"|\" , trim ( state ) end subroutine StatisticsMonitor_WriteValue end module StatisticsMonitor #endif","tags":"","url":"sourcefile/statisticsmonitor.f90.html"},{"title":"FWHGeneralClass.f90 – HORSES3D","text":"Source Code !////////////////////////////////////////////////////// ! !This class represents the general behaviour of the Ffowcs Williams and Hawckings aero acoustic analogy ! !////////////////////////////////////////////////////// ! #include \"Includes.h\" Module FWHGeneralClass ! use SMConstants use FWHDefinitions , only : OB_BUFFER_SIZE_DEFAULT , OB_BUFFER_SIZE_DEFAULT , STR_LEN_OBSERVER use FWHObseverClass use HexMeshClass use FileReadingUtilities , only : getFileName use SurfaceMesh , only : surfacesMesh , FWH_POSITION , SURFACE_TYPE_FWH Implicit None ! !   ***************************** !   Main FWH class definition !   ***************************** type FWHClass character ( len = LINE_LENGTH ) :: solution_file integer :: numberOfObservers = 0 integer :: bufferLine integer , dimension (:), allocatable :: iter real ( kind = RP ), dimension (:), allocatable :: t class ( ObserverClass ), dimension (:), allocatable :: observers integer :: totalNumberOfFaces logical :: isSolid logical :: isActive = . false . logical :: firstWrite logical :: interpolate contains procedure :: construct => FWHConstruct procedure :: destruct => FWHDestruct procedure :: updateValues => FWHUpate procedure :: writeToFile => FWHWriteToFile end type FWHClass contains Subroutine FWHConstruct ( self , mesh , controlVariables ) use FTValueDictionaryClass use mainKeywordsModule use FileReadingUtilities , only : getCharArrayFromString use FWHDefinitions , only : getMeanStreamValues use Headers use Utilities , only : toLower #ifdef _HAS_MPI_ use mpi #endif implicit none class ( FWHClass ) :: self class ( HexMesh ), intent ( in ) :: mesh class ( FTValueDictionary ), intent ( in ) :: controlVariables !       --------------- !       Local variables !       --------------- ! integer :: fID , io integer :: i character ( len = STR_LEN_OBSERVER ) :: line character ( len = STR_LEN_OBSERVER ) :: solution_file integer :: no_of_zones , no_of_face_i , ierr , no_of_faces logical , save :: FirstCall = . TRUE . !        look if the acoustic analogy calculations are set to be computed !        -------------------------------- !TODO read acoustic analogy type and return if is not defined, check for FWH if is defined and not FWH stop and send error if (. not . controlVariables % containsKey ( \"acoustic analogy\" )) then self % isActive = . FALSE . ! print *, \"FWH not activated\" return end if !       check the that sourceZone is FWH !       ---------------------------------- if ( surfacesMesh % surfaceTypes ( FWH_POSITION ) . ne . SURFACE_TYPE_FWH ) then self % isActive = . FALSE . print * , \"FWH surface not found, the FWH routines will not deactivated\" return end if !       Setup the buffer !       ---------------- if ( controlVariables % containsKey ( \"observers flush interval\" ) ) then OB_BUFFER_SIZE = controlVariables % integerValueForKey ( \"observers flush interval\" ) end if self % isActive = . TRUE . allocate ( self % t ( OB_BUFFER_SIZE ), self % iter ( OB_BUFFER_SIZE ) ) !       Get the general configuration of control file !       First get the surface as a zone !       ------------------------------- self % isSolid = . not . controlVariables % logicalValueForKey ( \"acoustic analogy permeable\" ) !       Get the solution file name !       -------------------------- solution_file = controlVariables % stringValueForKey ( solutionFileNameKey , requestedLength = STR_LEN_OBSERVER ) ! !       Remove the *.hsol termination !       ----------------------------- solution_file = trim ( getFileName ( solution_file )) self % solution_file = trim ( solution_file ) !       Search in case file for observers !       --------------------------------------------------------------------- if ( mesh % child ) then ! Return doing nothing if this is a child mesh self % numberOfObservers = 0 else self % numberOfObservers = getNoOfObservers () end if !       Set interpolate attribute as TRUE by default ! todo: read from constrol variables self % interpolate = . TRUE . ! self % interpolate = .FALSE. !       Initialize observers !       -------------------- call getMeanStreamValues () no_of_faces = surfacesMesh % totalFaces ( SURFACE_TYPE_FWH ) allocate ( self % observers ( self % numberOfObservers ) ) do i = 1 , self % numberOfObservers call self % observers ( i ) % construct ( surfacesMesh % zones ( SURFACE_TYPE_FWH ) , mesh , i , self % solution_file , FirstCall , & self % interpolate , no_of_faces , surfacesMesh % elementSide (:, 1 )) end do self % bufferLine = 0 self % firstWrite = . FALSE . FirstCall = . FALSE . !        Describe the zones !        ------------------ if ( . not . MPI_Process % isRoot ) return call Subsection_Header ( \"Fictitious FWH zone\" ) write ( STD_OUT , '(30X,A,A28,I0)' ) \"->\" , \"Number of faces: \" , no_of_faces write ( STD_OUT , '(30X,A,A28,I0)' ) \"->\" , \"Number of observers: \" , self % numberOfObservers write ( STD_OUT , '(30X,A,A28,I0)' ) \"->\" , \"Number of integrals: \" , self % numberOfObservers * no_of_faces write ( STD_OUT , '(30X,A,A28,L1)' ) \"->\" , \"Save zone solution: \" , controlVariables % containsKey ( \"acoustic save timestep\" ) End Subroutine FWHConstruct Subroutine FWHUpate ( self , mesh , t , iter , isFromFile ) implicit none class ( FWHClass ) :: self class ( HexMesh ) :: mesh real ( kind = RP ), intent ( in ) :: t integer , intent ( in ) :: iter logical , intent ( in ), optional :: isFromFile !       --------------- !       Local variables !       --------------- ! integer :: i logical :: prolong !       Check if is activated !       ------------------------ if (. not . self % isActive ) return !       Check if prolong is necessary !       ------------------------ if ( present ( isFromFile )) then prolong = . not . isFromFile else prolong = . TRUE . end if ! !       Move to next buffer line !       ------------------------ self % bufferLine = self % bufferLine + 1 ! !       Save time and iteration !       ----------------------- self % t ( self % bufferLine ) = t self % iter ( self % bufferLine ) = iter ! !       Save Solution to elements faces of fwh surface !       ----------------------- if ( prolong ) call SourceProlongSolution ( surfacesMesh % zones ( SURFACE_TYPE_FWH ), mesh , surfacesMesh % elementSide (:, 1 )) !       see if its regular or interpolated !       ----------------------- if (. not . self % firstWrite ) then do i = 1 , self % numberOfObservers call self % observers ( i ) % update ( mesh , self % isSolid , self % bufferLine , self % interpolate ) end do else do i = 1 , self % numberOfObservers call self % observers ( i ) % updateOneStep ( mesh , self % bufferLine , self % isSolid , t ) end do end if End Subroutine FWHUpate Subroutine FWHWriteToFile ( self , force ) ! !        ****************************************************************** !              This routine has a double behaviour: !           force = .true.  -> Writes to file and resets buffers !           force = .false. -> Just writes to file if the buffer is full !        ****************************************************************** ! use MPI_Process_Info implicit none class ( FWHClass ) :: self logical , optional :: force !       --------------- !       Local variables !       --------------- integer :: i logical :: forceVal !       Check if is activated !       ------------------------ if (. not . self % isActive ) return if ( present ( force ) ) then forceVal = force else forceVal = . false . end if if ( forceVal ) then ! !           In this case the observers are exported to their files and the buffer is reset !           ------------------------------------------------------------------------------ if (. not . self % firstWrite . and . self % interpolate ) then do i = 1 , self % numberOfObservers call self % observers ( i ) % interpolateSol ( self % t , self % bufferLine ) end do self % firstWrite = . TRUE . end if do i = 1 , self % numberOfObservers call self % observers ( i ) % writeToFile ( self % iter , self % t , self % bufferLine ) end do !               Reset buffer !               ------------ self % bufferLine = 0 else !               The observers are exported just if the buffer is full !               ---------------------------------------------------- if ( self % bufferLine . eq . OB_BUFFER_SIZE ) then if (. not . self % firstWrite . and . self % interpolate ) then do i = 1 , self % numberOfObservers call self % observers ( i ) % interpolateSol ( self % t , self % bufferLine ) end do self % firstWrite = . TRUE . end if do i = 1 , self % numberOfObservers call self % observers ( i ) % writeToFile ( self % iter , self % t , self % bufferLine ) end do !               Reset buffer !               ------------ self % bufferLine = 0 end if end if End Subroutine FWHWriteToFile Subroutine FWHDestruct ( self ) implicit none class ( FWHClass ), intent ( inout ) :: self !       --------------- !       Local variables !       --------------- integer :: i !       Check if is activated !       ------------------------ if (. not . self % isActive ) return safedeallocate ( self % iter ) safedeallocate ( self % t ) ! safedeallocate(self % sourceZone) do i = 1 , self % numberOfObservers call self % observers ( i ) % destruct end do safedeallocate ( self % observers ) End Subroutine FWHDestruct ! !////////////////////////////////////////////////////////////////////////////// ! !        Auxiliars ! !////////////////////////////////////////////////////////////////////////////// ! Function getNoOfObservers () result ( no_of_observers ) use ParamfileRegions implicit none integer :: no_of_observers ! !     --------------- !     Local variables !     --------------- ! character ( len = LINE_LENGTH ) :: case_name , line integer :: fID integer :: io ! !     Initialize !     ---------- no_of_observers = 0 ! !     Get case file name !     ------------------ call get_command_argument ( 1 , case_name ) ! !     Open case file !     -------------- open ( newunit = fID , file = case_name , status = \"old\" , action = \"read\" ) ! !     Read the whole file to find the observers !     ------------------------------------ readloop : do read ( fID , '(A)' , iostat = io ) line if ( io . lt . 0 ) then ! !           End of file !           ----------- line = \"\" exit readloop elseif ( io . gt . 0 ) then ! !           Error !           ----- errorMessage ( STD_OUT ) error stop \"Stopped.\" else ! !           Succeeded !           --------- line = getSquashedLine ( line ) if ( index ( line , '#defineacousticobserver' ) . gt . 0 ) then no_of_observers = no_of_observers + 1 end if end if end do readloop ! !     Close case file !     --------------- close ( fID ) End Function getNoOfObservers End Module FWHGeneralClass","tags":"","url":"sourcefile/fwhgeneralclass.f90.html"},{"title":"SurfaceIntegrals.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" #if defined(NAVIERSTOKES) || (defined(INCNS)) module SurfaceIntegrals use SMConstants use PhysicsStorage use Physics use FaceClass use ElementClass use HexMeshClass use VariableConversion , only : Pressure use NodalStorageClass #ifdef _HAS_MPI_ use mpi #endif implicit none private public SURFACE , TOTAL_FORCE , PRESSURE_FORCE , VISCOUS_FORCE , MASS_FLOW , FLOW_RATE , PRESSURE_DISTRIBUTION public ScalarSurfaceIntegral , VectorSurfaceIntegral , ScalarDataReconstruction , VectorDataReconstruction integer , parameter :: SURFACE = 1 integer , parameter :: TOTAL_FORCE = 2 integer , parameter :: PRESSURE_FORCE = 3 integer , parameter :: VISCOUS_FORCE = 4 integer , parameter :: MASS_FLOW = 5 integer , parameter :: FLOW_RATE = 6 integer , parameter :: PRESSURE_DISTRIBUTION = 7 integer , parameter :: USER_DEFINED = 99 ! !  ======== contains !  ======== ! !//////////////////////////////////////////////////////////////////////////////////////// ! !           SCALAR INTEGRALS PROCEDURES ! !//////////////////////////////////////////////////////////////////////////////////////// ! function ScalarSurfaceIntegral ( mesh , zoneID , integralType , iter ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes scalar integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           Implemented integrals are: !              * Surface: computes the zone surface. !              * Mass flow: computes the mass flow across the zone. !              * Flow: computes the volumetric flow across the zone. !        ----------------------------------------------------------- ! implicit none class ( HexMesh ), intent ( inout ), target :: mesh integer , intent ( in ) :: zoneID integer , intent ( in ) :: integralType , iter real ( kind = RP ) :: val , localval ! !        --------------- !        Local variables !        --------------- ! integer :: zonefID , fID , eID , fIDs ( 6 ), ierr class ( Element ), pointer :: elements (:) ! !        Initialization !        -------------- val = 0.0_RP ! !        Loop the zone to get faces and elements !        --------------------------------------- elements => mesh % elements !$omp parallel private(fID, eID, fIDs) shared(elements,mesh,NodalStorage,zoneID,integralType,val,& !$omp&                                          computeGradients) !$omp single do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces fID = mesh % zones ( zoneID ) % faces ( zonefID ) eID = mesh % faces ( fID ) % elementIDs ( 1 ) fIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) if ( computeGradients ) then call elements ( eID ) % ProlongGradientsToFaces ( NGRAD , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) end if !$omp end task end do !$omp end single ! !        Loop the zone to get faces and elements !        --------------------------------------- !$omp do private(fID) reduction(+:val) schedule(runtime) do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( zoneID ) % faces ( zonefID ) ! !           Compute the integral !           -------------------- val = val + ScalarSurfaceIntegral_Face ( mesh % faces ( fID ), integralType ) end do !$omp end do !$omp end parallel #ifdef _HAS_MPI_ localval = val call mpi_allreduce ( localval , val , 1 , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function ScalarSurfaceIntegral function ScalarSurfaceIntegral_Face ( f , integralType ) result ( val ) implicit none class ( Face ), intent ( in ) :: f integer , intent ( in ) :: integralType real ( kind = RP ) :: val ! !        --------------- !        Local variables !        --------------- ! integer :: i , j ! Face indices real ( kind = RP ) :: p type ( NodalStorage_t ), pointer :: spAxi , spAeta ! !        Initialization !        -------------- val = 0.0_RP spAxi => NodalStorage ( f % Nf ( 1 )) spAeta => NodalStorage ( f % Nf ( 2 )) ! !        Perform the numerical integration !        --------------------------------- associate ( Q => f % storage ( 1 ) % Q ) select case ( integralType ) case ( SURFACE ) ! !           ********************************** !           Computes the surface integral !              val = \\int dS !           ********************************** ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) val = val + spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) end do ; end do case ( MASS_FLOW ) ! !           *********************************** !           Computes the mass-flow integral !              I = \\int rho \\vec{v}·\\vec{n}dS !           *********************************** ! #if defined(NAVIERSTOKES) do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- val = val + ( Q ( IRHOU , i , j ) * f % geom % normal ( 1 , i , j ) & + Q ( IRHOV , i , j ) * f % geom % normal ( 2 , i , j ) & + Q ( IRHOW , i , j ) * f % geom % normal ( 3 , i , j ) ) & * spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) end do ; end do #endif #if defined(INCNS) do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- val = val + ( Q ( INSRHOU , i , j ) * f % geom % normal ( 1 , i , j ) & + Q ( INSRHOV , i , j ) * f % geom % normal ( 2 , i , j ) & + Q ( INSRHOW , i , j ) * f % geom % normal ( 3 , i , j ) ) & * spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) end do ; end do #endif case ( FLOW_RATE ) ! !           *********************************** !           Computes the flow integral !              val = \\int \\vec{v}·\\vec{n}dS !           *********************************** ! #if defined(NAVIERSTOKES) do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- val = val + ( 1.0_RP / Q ( IRHO , i , j )) * ( Q ( IRHOU , i , j ) * f % geom % normal ( 1 , i , j ) & + Q ( IRHOV , i , j ) * f % geom % normal ( 2 , i , j ) & + Q ( IRHOW , i , j ) * f % geom % normal ( 3 , i , j ) ) & * spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) end do ; end do #endif #if defined(INCNS) do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- val = val + ( 1.0_RP / Q ( INSRHO , i , j )) * ( Q ( INSRHOU , i , j ) * f % geom % normal ( 1 , i , j ) & + Q ( INSRHOV , i , j ) * f % geom % normal ( 2 , i , j ) & + Q ( INSRHOW , i , j ) * f % geom % normal ( 3 , i , j ) ) & * spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) end do ; end do #endif case ( PRESSURE_FORCE ) ! !           *********************************** !           Computes the pressure integral !              val = \\int pdS !           *********************************** ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- p = Pressure ( Q (:, i , j )) val = val + p * spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) end do ; end do case ( USER_DEFINED ) ! TODO end select end associate nullify ( spAxi , spAeta ) end function ScalarSurfaceIntegral_Face ! !//////////////////////////////////////////////////////////////////////////////////////// ! !           VECTOR INTEGRALS PROCEDURES ! !//////////////////////////////////////////////////////////////////////////////////////// ! function VectorSurfaceIntegral ( mesh , zoneID , integralType , iter ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes scalar integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           Implemented integrals are: !              * Surface: computes the zone surface. !              * Mass flow: computes the mass flow across the zone. !              * Flow: computes the volumetric flow across the zone. !        ----------------------------------------------------------- ! #ifdef _HAS_MPI_ use mpi #endif implicit none class ( HexMesh ), intent ( inout ), target :: mesh integer , intent ( in ) :: zoneID integer , intent ( in ) :: integralType , iter real ( kind = RP ) :: val ( NDIM ) real ( kind = RP ) :: localVal ( NDIM ) real ( kind = RP ) :: valx , valy , valz ! !        --------------- !        Local variables !        --------------- ! integer :: zonefID , fID , eID , fIDs ( 6 ), ierr class ( Element ), pointer :: elements (:) ! !        Initialization !        -------------- val = 0.0_RP valx = 0.0_RP valy = 0.0_RP valz = 0.0_RP ! !        ************************* !        Perform the interpolation !        ************************* ! elements => mesh % elements !$omp parallel private(fID, eID, fIDs, localVal) shared(elements,mesh,NodalStorage,zoneID,integralType,val,& !$omp&                                        valx,valy,valz,computeGradients) !$omp single do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces fID = mesh % zones ( zoneID ) % faces ( zonefID ) eID = mesh % faces ( fID ) % elementIDs ( 1 ) fIDs = mesh % elements ( eID ) % faceIDs !$omp task depend(inout:elements(eID)) call elements ( eID ) % ProlongSolutionToFaces ( NCONS , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) if ( computeGradients ) then call elements ( eID ) % ProlongGradientsToFaces ( NGRAD , mesh % faces ( fIDs ( 1 )),& mesh % faces ( fIDs ( 2 )),& mesh % faces ( fIDs ( 3 )),& mesh % faces ( fIDs ( 4 )),& mesh % faces ( fIDs ( 5 )),& mesh % faces ( fIDs ( 6 )) ) end if !$omp end task end do !$omp end single ! !        Loop the zone to get faces and elements !        --------------------------------------- !$omp do private(fID,localVal) reduction(+:valx,valy,valz) schedule(runtime) do zonefID = 1 , mesh % zones ( zoneID ) % no_of_faces ! !           Face global ID !           -------------- fID = mesh % zones ( zoneID ) % faces ( zonefID ) ! !           Compute the integral !           -------------------- localVal = VectorSurfaceIntegral_Face ( mesh % faces ( fID ), integralType ) valx = valx + localVal ( 1 ) valy = valy + localVal ( 2 ) valz = valz + localVal ( 3 ) end do !$omp end do !$omp end parallel val = ( / valx , valy , valz / ) #ifdef _HAS_MPI_ localVal = val call mpi_allreduce ( localVal , val , NDIM , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function VectorSurfaceIntegral function VectorSurfaceIntegral_Face ( f , integralType ) result ( val ) implicit none class ( Face ), intent ( in ) :: f integer , intent ( in ) :: integralType real ( kind = RP ) :: val ( NDIM ) ! !        --------------- !        Local variables !        --------------- ! integer :: i , j ! Face indices real ( kind = RP ) :: p , tau ( NDIM , NDIM ) type ( NodalStorage_t ), pointer :: spAxi , spAeta ! !        Initialization !        -------------- val = 0.0_RP spAxi => NodalStorage ( f % Nf ( 1 )) spAeta => NodalStorage ( f % Nf ( 2 )) ! !        Perform the numerical integration !        --------------------------------- associate ( Q => f % storage ( 1 ) % Q , & U_x => f % storage ( 1 ) % U_x , & U_y => f % storage ( 1 ) % U_y , & U_z => f % storage ( 1 ) % U_z ) select case ( integralType ) case ( SURFACE ) ! !           ********************************** !           Computes the surface integral !              val = \\int \\vec{n} dS !           ********************************** ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) val = val + spAxi % w ( i ) * spAeta % w ( j ) * f % geom % jacobian ( i , j ) & * f % geom % normal (:, i , j ) end do ; end do case ( TOTAL_FORCE ) ! !           ************************************************ !           Computes the total force experienced by the zone !              F = \\int p \\vec{n}ds - \\int tau'·\\vec{n}ds !           ************************************************ ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- p = Pressure ( Q (:, i , j )) call getStressTensor ( Q (:, i , j ), U_x (:, i , j ), U_y (:, i , j ), U_z (:, i , j ), tau ) val = val + ( p * f % geom % normal (:, i , j ) - matmul ( tau , f % geom % normal (:, i , j )) ) & * f % geom % jacobian ( i , j ) * spAxi % w ( i ) * spAeta % w ( j ) end do ; end do case ( PRESSURE_FORCE ) ! !           **************************************************** !           Computes the pressure forces experienced by the zone !              F = \\int p \\vec{n}ds !           **************************************************** ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- p = Pressure ( Q (:, i , j )) val = val + ( p * f % geom % normal (:, i , j ) ) * f % geom % jacobian ( i , j ) & * spAxi % w ( i ) * spAeta % w ( j ) end do ; end do case ( VISCOUS_FORCE ) ! !           ************************************************ !           Computes the total force experienced by the zone !              F =  - \\int tau'·\\vec{n}ds !           ************************************************ ! do j = 0 , f % Nf ( 2 ) ; do i = 0 , f % Nf ( 1 ) ! !              Compute the integral !              -------------------- call getStressTensor ( Q (:, i , j ), U_x (:, i , j ), U_y (:, i , j ), U_z (:, i , j ), tau ) val = val - matmul ( tau , f % geom % normal (:, i , j )) * f % geom % jacobian ( i , j ) & * spAxi % w ( i ) * spAeta % w ( j ) end do ; end do case ( USER_DEFINED ) ! TODO end select end associate nullify ( spAxi , spAeta ) end function VectorSurfaceIntegral_Face ! !//////////////////////////////////////////////////////////////////////////////////////// ! !           INTEGRALS PROCEDURES FOR IBM DATA RECONSTRUCTION ! !                          SURFACE INTEGRALS ! !//////////////////////////////////////////////////////////////////////////////////////// subroutine ScalarDataReconstruction ( IBM , elements , STLNum , integralType , iter , autosave , dt ) use TessellationTypes use MappedGeometryClass use IBMClass use OrientedBoundingBox use KDClass use MPI_Process_Info use MPI_IBMUtilities #ifdef _HAS_MPI_ use mpi #endif ! !        ----------------------------------------------------------------------------------------- !           This function computes Scalar integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           The data at the boundary point (BP) is computed through a Inverse Distance Weight !           procedure. !        ----------------------------------------------------------------------------------------- implicit none !-arguments-------------------------------------------------------- type ( IBM_type ), intent ( inout ) :: IBM type ( element ), intent ( inout ) :: elements (:) integer , intent ( in ) :: integralType , STLNum , iter real ( kind = RP ), intent ( in ) :: dt !-local-variables------------------------------------------------- real ( kind = rp ), allocatable :: Qsurf (:,:), U_xsurf (:,:), U_ysurf (:,:), U_zsurf (:,:) integer :: i , j logical :: found , autosave if ( . not . IBM % Integral ( STLNum )% compute ) return allocate ( Qsurf ( NCONS , IBM % NumOfInterPoints ) ) call IBM % BandPoint_state ( elements , STLNum , . true . ) if ( IBM % stlSurfaceIntegrals ( STLNum )% move ) then if ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . ROTATION ) then call IBM % stlSurfaceIntegrals ( STLNum )% getRotationaMatrix ( dt ) call OBB ( STLNum )% STL_rotate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) elseif ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . LINEAR ) then call IBM % stlSurfaceIntegrals ( STLNum )% getDisplacement ( dt ) call OBB ( STLNum )% STL_translate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) end if end if if ( . not . MPI_Process % isRoot ) return !$omp parallel !$omp do schedule(runtime) private(j,found) do i = 1 , IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs do j = 1 , NumOfVertices + 4 call GetSurfaceState ( IBM , IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i ), IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), STLNum ) Qsurf = IBM % BandRegion ( STLNum )% Q (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) end do do j = 1 , NumOfVertices + 4 IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% ScalarValue = IntegratedScalarValue ( Q = Qsurf , & vertex = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), & normal = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% normal , & integralType = integralType , & InterpolationType = IBM % InterpolationType ) end do end do !$omp end do !$omp end parallel if ( IBM % stl ( STLNum )% move ) then IBM % Integral ( STLNum )% ListComputed = . false . else IBM % Integral ( STLNum )% ListComputed = . true . end if if ( autosave ) call GenerateScalarmonitorTECfile ( IBM , STLNum , integralType , iter ) end subroutine ScalarDataReconstruction ! !//////////////////////////////////////////////////////////////////////////////////////// ! !                          VECTOR INTEGRALS ! !//////////////////////////////////////////////////////////////////////////////////////// subroutine VectorDataReconstruction ( IBM , elements , STLNum , integralType , iter , autosave , dt ) use TessellationTypes use MappedGeometryClass use IBMClass use OrientedBoundingBox use KDClass use MPI_Process_Info use MPI_IBMUtilities use omp_lib #ifdef _HAS_MPI_ use mpi #endif ! !        ----------------------------------------------------------------------------------------- !           This function computes Vector integrals, that is, those !           in the form: !                 val = \\int \\vec{v}·\\vec{n}dS !           The data at the boundary point (BP) is computed through a Inverse Distance Weight !           procedure. !        ----------------------------------------------------------------------------------------- implicit none !-arguments--------------------------------------------------------------------------------- type ( IBM_type ), intent ( inout ) :: IBM type ( element ), intent ( inout ) :: elements (:) integer , intent ( in ) :: integralType , STLNum , iter real ( kind = RP ), intent ( in ) :: dt !-local-variables--------------------------------------------------------------------------- real ( kind = rp ), allocatable :: Qsurf (:,:,:), U_xsurf (:,:,:), U_ysurf (:,:,:), U_zsurf (:,:,:) integer :: i , j logical :: found , autosave if ( . not . IBM % Integral ( STLNum )% compute ) return allocate ( Qsurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ), & U_xsurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ), & U_ysurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ), & U_zsurf ( NCONS , IBM % NumOfInterPoints , NumOfVertices + 4 ) ) call IBM % BandPoint_state ( elements , STLNum , . true . ) if ( . not . MPI_Process % isRoot ) return if ( IBM % stlSurfaceIntegrals ( STLNum )% move ) then if ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . ROTATION ) then call IBM % stlSurfaceIntegrals ( STLNum )% getRotationaMatrix ( dt ) call OBB ( STLNum )% STL_rotate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) elseif ( IBM % stlSurfaceIntegrals ( STLNum )% motionType . eq . LINEAR ) then call IBM % stlSurfaceIntegrals ( STLNum )% getDisplacement ( dt ) call OBB ( STLNum )% STL_translate ( IBM % stlSurfaceIntegrals ( STLNum ), . true . ) end if end if !$omp parallel !$omp do schedule(runtime) private(j,found,Qsurf,U_xsurf,U_ysurf,U_zsurf) do i = 1 , IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs do j = 1 , NumOfVertices + 4 call GetSurfaceState ( IBM , IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i ), IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), STLNum ) Qsurf (:,:, j ) = IBM % BandRegion ( STLNum )% Q (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) U_xsurf (:,:, j ) = IBM % BandRegion ( STLNum )% U_x (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) U_ysurf (:,:, j ) = IBM % BandRegion ( STLNum )% U_y (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) U_zsurf (:,:, j ) = IBM % BandRegion ( STLNum )% U_z (:, IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% nearestPoints ) end do do j = 1 , NumOfVertices + 4 IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j )% VectorValue = IntegratedVectorValue ( Q = Qsurf (:,:, j ), & U_x = U_xsurf (:,:, j ), & U_y = U_ysurf (:,:, j ), & U_z = U_zsurf (:,:, j ), & vertex = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% vertices ( j ), & normal = IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i )% normal , & y = IBM % IP_Distance , & Wallfunction = IBM % Wallfunction , & integralType = integralType , & InterpolationType = IBM % InterpolationType ) end do end do !$omp end do !$omp end parallel deallocate ( Qsurf , U_xsurf , U_ysurf , U_zsurf ) if ( IBM % stl ( STLNum )% move ) then IBM % Integral ( STLNum )% ListComputed = . false . else IBM % Integral ( STLNum )% ListComputed = . true . end if if ( autosave ) call GenerateVectormonitorTECfile ( IBM , STLNum , integralType , iter ) end subroutine VectorDataReconstruction subroutine GetSurfaceState ( IBM , obj , vertex , STLNum ) use TessellationTypes use IBMClass use MPI_Process_Info use omp_lib #ifdef _HAS_MPI_ use mpi #endif implicit none class ( IBM_type ), intent ( inout ) :: IBM type ( object_type ), intent ( inout ) :: obj type ( point_type ), intent ( inout ) :: vertex integer , intent ( in ) :: STLNum real ( kind = RP ) :: Dist integer :: i , j , k if ( IBM % Integral ( STLNum )% ListComputed ) return vertex % nearestPoints = 0 do k = 1 , IBM % NumOfInterPoints if ( IBM % Wallfunction ) then call MinimumDistancePoints ( vertex % coords + IBM % IP_Distance * obj % Normal , & IBM % rootPoints ( STLNum ), IBM % BandRegion ( STLNum ), & Dist , k , vertex % nearestPoints ) else call MinimumDistancePoints ( vertex % coords , IBM % rootPoints ( STLNum ), & IBM % BandRegion ( STLNum ), Dist , k , & vertex % nearestPoints ) end if end do call GetMatrixInterpolationSystem ( vertex % coords , & IBM % BandRegion ( STLNum )% x ( vertex % nearestPoints ), & vertex % invPhi , & vertex % b , IBM % InterpolationType ) end subroutine GetSurfaceState subroutine GetSurfaceState_HO ( IBM , obj , vertex , STLNum , elements , Qs , U_xs , U_ys , U_zs , gradients , found ) use TessellationTypes use IBMClass use MPI_Process_Info use omp_lib #ifdef _HAS_MPI_ use mpi #endif implicit none class ( IBM_type ), intent ( in ) :: IBM type ( object_type ), intent ( inout ) :: obj type ( point_type ), intent ( inout ) :: vertex integer , intent ( in ) :: STLNum type ( element ), intent ( inout ) :: elements (:) real ( kind = RP ), intent ( inout ) :: Qs ( NCONS , 1 ) real ( kind = RP ), intent ( inout ) :: U_xs ( NCONS , 1 ), U_ys ( NCONS , 1 ), U_zs ( NCONS , 1 ) logical , intent ( in ) :: gradients logical , intent ( out ) :: found real ( kind = RP ) :: xi ( NDIM ) integer :: eID , i , j , k Qs = 0.0_RP if ( gradients ) then U_xs = 0.0_RP ; U_ys = 0.0_RP ; U_zs = 0.0_RP end if if ( IBM % Integral ( STLNum )% ListComputed ) then if ( vertex % partition . eq . MPI_Process % rank ) then eID = vertex % element_index xi = vertex % xi associate ( e => elements ( eID ) ) Qs (:, 1 ) = elements ( eID )% EvaluateSolutionAtPoint ( NCONS , xi ) if ( gradients ) then U_xs (:, 1 ) = elements ( eID )% EvaluateGradientAtPoint ( NCONS , xi , IX ) U_ys (:, 1 ) = elements ( eID )% EvaluateGradientAtPoint ( NCONS , xi , IY ) U_zs (:, 1 ) = elements ( eID )% EvaluateGradientAtPoint ( NCONS , xi , IZ ) end if end associate found = . true . else found = . false . end if return end if do eID = 1 , size ( elements ) associate ( e => elements ( eID ) ) found = e % FindPointWithCoords ( vertex % coords , 0 , xi ) if ( found ) then vertex % element_index = eID vertex % partition = MPI_Process % rank vertex % xi = xi Qs (:, 1 ) = elements ( eID )% EvaluateSolutionAtPoint ( NCONS , xi ) if ( gradients ) then U_xs (:, 1 ) = elements ( eID )% EvaluateGradientAtPoint ( NCONS , xi , IX ) U_ys (:, 1 ) = elements ( eID )% EvaluateGradientAtPoint ( NCONS , xi , IY ) U_zs (:, 1 ) = elements ( eID )% EvaluateGradientAtPoint ( NCONS , xi , IZ ) end if exit end if end associate end do end subroutine GetSurfaceState_HO ! !//////////////////////////////////////////////////////////////////////////////////////// ! !           INVERSE DISTANCE WEIGHTED INTERPOLATION PROCEDURES FOR IBM DATA RECONSTRUCTION ! !                                   SCALAR INTERPOLATION ! !//////////////////////////////////////////////////////////////////////////////////////// function IntegratedScalarValue ( Q , vertex , normal , integralType , InterpolationType ) result ( outvalue ) use IBMClass implicit none ! !        ----------------------------------------------------------- !           This function computes the IDW interpolat for a scalar !           quantity in the point \"Point\". !           Available scalars are: !           Mass flow !           Flow rate !           Pressure !        ----------------------------------------------------------- !-arguments-------------------------------------------------------------- real ( kind = rp ), intent ( in ) :: Q (:,:), normal (:) type ( point_type ), intent ( inout ) :: vertex integer , intent ( in ) :: integralType , InterpolationType real ( kind = rp ) :: outvalue !-local-variables-------------------------------------------------------- real ( kind = rp ) :: Qi ( NCONS ), P integer :: i outvalue = 0.0_RP select case ( integralType ) case ( MASS_FLOW ) do i = 1 , NCONS Qi ( i ) = GetInterpolatedValue ( Q ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do #if defined(NAVIERSTOKES) outvalue = - ( 1.0_RP / Qi ( IRHO )) * ( Qi ( IRHOU ) * normal ( 1 ) + Qi ( IRHOV ) * normal ( 2 ) + Qi ( IRHOW ) * normal ( 3 )) #endif #if defined(INCNS) outvalue = - ( 1.0_RP / Qi ( INSRHO )) * ( Qi ( INSRHOU ) * normal ( 1 ) + Qi ( INSRHOV ) * normal ( 2 ) + Qi ( INSRHOW ) * normal ( 3 )) #endif case ( FLOW_RATE ) do i = 1 , NCONS Qi ( i ) = GetInterpolatedValue ( Q ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do #if defined(NAVIERSTOKES) outvalue = - ( Qi ( IRHOU ) * normal ( 1 ) + Qi ( IRHOV ) * normal ( 2 ) + Qi ( IRHOW ) * normal ( 3 )) #endif #if defined(INCNS) outvalue = - ( Qi ( INSRHOU ) * normal ( 1 ) + Qi ( INSRHOV ) * normal ( 2 ) + Qi ( INSRHOW ) * normal ( 3 )) #endif case ( PRESSURE_DISTRIBUTION ) do i = 1 , NCONS Qi ( i ) = GetInterpolatedValue ( Q ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do outvalue = pressure ( Qi ) case ( USER_DEFINED ) ! TODO end select end function IntegratedScalarValue ! !//////////////////////////////////////////////////////////////////////////////////////// ! !                          VECTOR INTERPOLATION ! !//////////////////////////////////////////////////////////////////////////////////////// function IntegratedVectorValue ( Q , U_x , U_y , U_z , vertex , normal , & y , Wallfunction , integralType , & InterpolationType ) result ( outvalue ) use IBMClass use VariableConversion use FluidData #if defined(NAVIERSTOKES) use WallFunctionBC #endif implicit none ! !        ----------------------------------------------------------- !           This function computes the IDW interpolat for a vector !           quantity in the point \"Point\". !           Available scalars are: !           Total force !           Pressure force !           Viscous force !        ----------------------------------------------------------- !-arguments----------------------------------------------------------------- real ( kind = rp ), intent ( in ) :: Q (:,:), U_x (:,:), U_y (:,:), & U_z (:,:), normal ( NDIM ) type ( point_type ), intent ( inout ) :: vertex real ( kind = rp ), intent ( in ) :: y logical , intent ( in ) :: Wallfunction integer , intent ( in ) :: integralType , InterpolationType real ( kind = rp ) :: outvalue ( NDIM ) !-local-variables----------------------------------------------------------- integer :: i real ( kind = rp ) :: viscStress ( NDIM ), U ( NDIM ), U_t ( NDIM ), tangent ( NDIM ), & Qi ( NCONS ), U_xi ( NCONS ), U_yi ( NCONS ), U_zi ( NCONS ), & tau ( NDIM , NDIM ), P , T , T_w , rho_w , mu , nu , u_II , u_tau , & tau_w , kappa_ outvalue = 0.0_RP select case ( integralType ) case ( TOTAL_FORCE ) do i = 1 , NCONS Qi ( i ) = GetInterpolatedValue ( Q ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do P = pressure ( Qi ) if ( Wallfunction ) then #if defined(NAVIERSTOKES) T = Temperature ( Qi ) call get_laminar_mu_kappa ( Qi , mu , kappa_ ) nu = mu / Qi ( IRHO ) U = Qi ( IRHOU : IRHOW ) / Qi ( IRHO ) U_t = U - ( dot_product ( U , normal ) * normal ) tangent = U_t / norm2 ( U_t ) u_II = dot_product ( U , tangent ) u_tau = u_tau_f ( u_II , y , nu , u_tau0 = 0.1_RP ) T_w = T + ( dimensionless % Pr ) ** ( 1._RP / 3._RP ) / ( 2.0_RP * thermodynamics % cp ) * POW2 ( u_II ) T_w = T_w * refvalues % T rho_w = P * refvalues % p / ( thermodynamics % R * T_w ) rho_w = rho_w / refvalues % rho #endif tau_w = rho_w * POW2 ( u_tau ) viscStress = tau_w * tangent else do i = 1 , NCONS U_xi ( i ) = GetInterpolatedValue ( U_x ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) U_yi ( i ) = GetInterpolatedValue ( U_y ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) U_zi ( i ) = GetInterpolatedValue ( U_z ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do call getStressTensor ( Qi , U_xi , U_yi , U_zi , tau ) viscStress = matmul ( tau , normal ) end if outvalue = - P * normal + viscStress case ( PRESSURE_FORCE ) do i = 1 , NCONS Qi ( i ) = GetInterpolatedValue ( Q ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do P = pressure ( Qi ) outvalue = - P * normal case ( VISCOUS_FORCE ) if ( Wallfunction ) then #if defined(NAVIERSTOKES) T = Temperature ( Qi ) call get_laminar_mu_kappa ( Qi , mu , kappa_ ) nu = mu / Qi ( IRHO ) U = Qi ( IRHOU : IRHOW ) / Qi ( IRHO ) U_t = U - ( dot_product ( U , normal ) * normal ) tangent = U_t / norm2 ( U_t ) u_II = dot_product ( U , tangent ) u_tau = u_tau_f ( u_II , y , nu , u_tau0 = 0.1_RP ) T_w = T + ( dimensionless % Pr ) ** ( 1._RP / 3._RP ) / ( 2.0_RP * thermodynamics % cp ) * POW2 ( u_II ) T_w = T_w * refvalues % T rho_w = P * refvalues % p / ( thermodynamics % R * T_w ) rho_w = rho_w / refvalues % rho #endif tau_w = rho_w * POW2 ( u_tau ) viscStress = tau_w * tangent else do i = 1 , NCONS U_xi ( i ) = GetInterpolatedValue ( U_x ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) U_yi ( i ) = GetInterpolatedValue ( U_y ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) U_zi ( i ) = GetInterpolatedValue ( U_z ( i ,:), vertex % invPhi , vertex % b , InterpolationType ) end do call getStressTensor ( Qi , U_xi , U_yi , U_zi , tau ) viscStress = matmul ( tau , normal ) end if outvalue = viscStress case ( USER_DEFINED ) ! TODO end select end function IntegratedVectorValue subroutine GenerateScalarmonitorTECfile ( IBM , STLNum , integralType , iter ) use MPI_Process_Info use TessellationTypes use MPI_IBMUtilities use IBMClass implicit none !-arguments------------------------------------------------------- type ( IBM_type ), intent ( in ) :: IBM integer , intent ( in ) :: STLNum , integralType , iter !-local-variables------------------------------------------------- real ( kind = RP ), allocatable :: x (:), y (:), z (:), scalar (:), & local_sum (:), global_sum (:) integer :: i , j , index , NumOfObjs character ( len = LINE_LENGTH ) :: FileName , FinalName #ifdef _HAS_MPI_ integer :: ierr #endif NumOfObjs = NumOfVertices * IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs allocate ( x ( NumOfObjs ), & y ( NumOfObjs ), & z ( NumOfObjs ), & scalar ( NumOfObjs ) ) index = 0 do i = 1 , IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs associate ( obj => IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i ) ) do j = 1 , NumOfVertices index = index + 1 x ( index ) = obj % vertices ( j )% coords ( IX ) y ( index ) = obj % vertices ( j )% coords ( IY ) z ( index ) = obj % vertices ( j )% coords ( IZ ) scalar ( index ) = obj % vertices ( j )% ScalarValue end do end associate end do #ifdef _HAS_MPI_ if ( MPI_Process % doMPIAction ) then allocate ( local_sum ( NumOfObjs ), global_sum ( NumOfObjs )) local_sum = scalar call mpi_allreduce ( local_sum , global_sum , NumOfObjs , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) scalar = global_sum deallocate ( local_sum , global_sum ) end if #endif if ( . not . MPI_Process % isRoot ) then deallocate ( x , y , z , scalar ) return end if if ( . not . MPI_Process % isRoot ) return select case ( integralType ) case ( MASS_FLOW ) FileName = 'MASS_FLOW_' write ( FinalName , '(A,A,I10.10,A)' ) trim ( FileName ), trim ( OBB ( STLNum )% FileName ) // '_' , iter , '.tec' call STLScalarTEC ( x , y , z , scalar , STLNum , FinalName , 'MASS FLOW' , '\"x\",\"y\",\"z\",\"MassFlow\"' ) case ( FLOW_RATE ) FileName = 'FLOW_RATE_FORCE_' write ( FinalName , '(A,A,I10.10,A)' ) trim ( FileName ), trim ( OBB ( STLNum )% FileName ) // '_' , iter , '.tec' call STLScalarTEC ( x , y , z , scalar , STLNum , FinalName , 'FLOW RATE' , '\"x\",\"y\",\"z\",\"FlowRate\"' ) case ( PRESSURE_DISTRIBUTION ) FileName = 'PRESSURE_' write ( FinalName , '(A,A,I10.10,A)' ) trim ( FileName ), trim ( OBB ( STLNum )% FileName ) // '_' , iter , '.tec' call STLScalarTEC ( x , y , z , scalar , STLNum , FinalName , 'PRESSURE DISTRIBUTION' , '\"x\",\"y\",\"z\",\"Pressure\"' ) end select deallocate ( x , y , z , scalar ) end subroutine GenerateScalarmonitorTECfile subroutine GenerateVectormonitorTECfile ( IBM , STLNum , integralType , iter ) use MPI_Process_Info use TessellationTypes use MPI_IBMUtilities use IBMClass implicit none !-arguments--------------------------------------------------------- type ( IBM_type ), intent ( in ) :: IBM integer , intent ( in ) :: STLNum , integralType , iter !-local-variables--------------------------------------------------- real ( kind = RP ), allocatable :: x (:), y (:), z (:), vector_x (:), & vector_y (:), vector_z (:), & local_sum (:), global_sum (:) character ( len = LINE_LENGTH ) :: FileName , FinalName integer :: index , NumOfObjs , i , j #ifdef _HAS_MPI_ integer :: ierr #endif NumOfObjs = NumOfVertices * IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs allocate ( x ( NumOfObjs ), & y ( NumOfObjs ), & z ( NumOfObjs ), & vector_x ( NumOfObjs ), & vector_y ( NumOfObjs ), & vector_z ( NumOfObjs ) ) index = 0 do i = 1 , IBM % stlSurfaceIntegrals ( STLNum )% NumOfObjs associate ( obj => IBM % stlSurfaceIntegrals ( STLNum )% ObjectsList ( i ) ) do j = 1 , NumOfVertices index = index + 1 x ( index ) = obj % vertices ( j )% coords ( IX ) y ( index ) = obj % vertices ( j )% coords ( IY ) z ( index ) = obj % vertices ( j )% coords ( IZ ) vector_x ( index ) = obj % vertices ( j )% VectorValue ( IX ) vector_y ( index ) = obj % vertices ( j )% VectorValue ( IY ) vector_z ( index ) = obj % vertices ( j )% VectorValue ( IZ ) end do end associate end do #ifdef _HAS_MPI_ if ( MPI_Process % doMPIAction ) then allocate ( local_sum ( NumOfObjs ), global_sum ( NumOfObjs )) local_sum = vector_x call mpi_allreduce ( local_sum , global_sum , NumOfObjs , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) vector_x = global_sum local_sum = vector_y call mpi_allreduce ( local_sum , global_sum , NumOfObjs , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) vector_y = global_sum local_sum = vector_z call mpi_allreduce ( local_sum , global_sum , NumOfObjs , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) vector_z = global_sum deallocate ( local_sum , global_sum ) end if #endif if ( . not . MPI_Process % isRoot ) then deallocate ( x , y , z , vector_x , vector_y , vector_z ) return end if select case ( integralType ) case ( TOTAL_FORCE ) FileName = 'TOTAL_FORCE_' write ( FinalName , '(A,A,I10.10,A)' ) trim ( FileName ), trim ( OBB ( STLNum )% FileName ) // '_' , iter , '.tec' call STLvectorTEC ( x , y , z , vector_x , vector_y , vector_z , STLNum , FinalName , 'TOTAL FORCE' , '\"x\",\"y\",\"z\",\"Ftot_x\",\"Ftot_y\",\"Ftot_z\"' ) case ( PRESSURE_FORCE ) FileName = 'PRESSURE_FORCE_' write ( FinalName , '(A,A,I10.10,A)' ) trim ( FileName ), trim ( OBB ( STLNum )% FileName ) // '_' , iter , '.tec' call STLvectorTEC ( x , y , z , vector_x , vector_y , vector_z , STLNum , FinalName , 'PRESSURE FORCE' , '\"x\",\"y\",\"z\",\"Fpres_x\",\"Fpres_y\",\"Fpres_z\"' ) case ( VISCOUS_FORCE ) FileName = 'VISCOUS_FORCE_' write ( FinalName , '(A,A,I10.10,A)' ) trim ( FileName ), trim ( OBB ( STLNum )% FileName ) // '_' , iter , '.tec' call STLvectorTEC ( x , y , z , vector_x , vector_y , vector_z , STLNum , FinalName , 'VISCOUS FORCE' , '\"x\",\"y\",\"z\",\"Fvisc_x\",\"Fvisc_y\",\"Fvisc_z\"' ) end select deallocate ( x , y , z , vector_x , vector_y , vector_z ) end subroutine GenerateVectormonitorTECfile end module SurfaceIntegrals #endif","tags":"","url":"sourcefile/surfaceintegrals.f90.html"},{"title":"VolumeIntegrals.f90 – HORSES3D","text":"Source Code module VolumeIntegrals use SMConstants use PhysicsStorage use Physics use VariableConversion use ElementClass use HexMeshClass use FluidData use NodalStorageClass , only : NodalStorage , NodalStorage_t #ifdef _HAS_MPI_ use mpi use MPI_Utilities , only : MPI_MinMax #endif #include \"Includes.h\" private public VOLUME #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) public KINETIC_ENERGY , KINETIC_ENERGY_RATE , KINETIC_ENERGY_BALANCE , ENSTROPHY , VELOCITY public ENTROPY , ENTROPY_RATE , INTERNAL_ENERGY , MOMENTUM , SOURCE , PSOURCE , ARTIFICIAL_DISSIPATION public ENTROPY_BALANCE , MATH_ENTROPY #endif #if defined(INCNS) public MASS , ENTROPY , KINETIC_ENERGY_RATE , ENTROPY_RATE , SOURCE #endif #if defined(MULTIPHASE) public ENTROPY_RATE , ENTROPY_BALANCE , PHASE2_AREA , PHASE2_XCOG , PHASE2_XVEL , SOURCE #endif #if defined(CAHNHILLIARD) public FREE_ENERGY #endif #if defined(ACOUSTIC) public ACOUSTIC_ENERGY , SOURCE #endif public ScalarVolumeIntegral , VectorVolumeIntegral , GetSensorRange enum , bind ( C ) enumerator :: VOLUME #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) enumerator :: KINETIC_ENERGY , KINETIC_ENERGY_RATE , KINETIC_ENERGY_BALANCE enumerator :: ENSTROPHY , VELOCITY , ENTROPY , ENTROPY_RATE , INTERNAL_ENERGY , MOMENTUM , SOURCE , PSOURCE enumerator :: ARTIFICIAL_DISSIPATION , ENTROPY_BALANCE , MATH_ENTROPY #endif #if defined(INCNS) enumerator :: MASS , ENTROPY , KINETIC_ENERGY_RATE , ENTROPY_RATE , SOURCE #endif #if defined(MULTIPHASE) enumerator :: ENTROPY_RATE , ENTROPY_BALANCE , PHASE2_AREA , PHASE2_XCOG , PHASE2_XVEL , SOURCE #endif #if defined(CAHNHILLIARD) enumerator :: FREE_ENERGY #endif #if defined(ACOUSTIC) enumerator :: ACOUSTIC_ENERGY , SOURCE #endif end enum ! !  ======== contains !  ======== ! !//////////////////////////////////////////////////////////////////////////////////////// ! !           SCALAR INTEGRALS PROCEDURES ! !//////////////////////////////////////////////////////////////////////////////////////// ! function ScalarVolumeIntegral ( mesh , integralType ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes scalar integrals, that is, those !           in the form: !                 val = \\int v dx !        ----------------------------------------------------------- ! implicit none class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: integralType real ( kind = RP ) :: val ! !        --------------- !        Local variables !        --------------- ! real ( kind = RP ) :: localVal integer :: eID , ierr ! !        Initialization !        -------------- val = 0.0_RP ! !        Loop the mesh !        ------------- !$omp parallel do reduction(+:val) private(eID) schedule(guided) do eID = 1 , mesh % no_of_elements ! !           Compute the integral !           -------------------- val = val + ScalarVolumeIntegral_Local ( mesh % elements ( eID ), & integralType ) end do !$omp end parallel do #ifdef _HAS_MPI_ localVal = val call mpi_allreduce ( localVal , val , 1 , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function ScalarVolumeIntegral function ScalarVolumeIntegral_Local ( e , integralType ) result ( val ) implicit none class ( Element ), target , intent ( in ) :: e integer , intent ( in ) :: integralType real ( kind = RP ) :: val ! !        --------------- !        Local variables !        --------------- ! integer :: Nel ( 3 ) ! Element polynomial order integer :: i , j , k real ( kind = RP ) :: EntropyVars ( NCONS ) real ( kind = RP ) :: ViscFlux ( NCONS , NDIM ) real ( kind = RP ) :: KinEn ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: U_x ( NDIM , 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: U_y ( NDIM , 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: U_z ( NDIM , 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: uvw ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: inv_rho ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: p_3d ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: grad_Mp ( 1 : NDIM , 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: M_grad_p ( 1 : NDIM , 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: correction_term ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: Ma2 ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 )) real ( kind = RP ) :: p , s , ms real ( kind = RP ), pointer :: Qb (:) real ( kind = RP ) :: free_en , fchem , entr , area , rho , u , v , w , en , thetaeddy real ( kind = RP ) :: Strain ( NDIM , NDIM ) real ( kind = RP ) :: mu Nel = e % Nxyz associate ( wx => NodalStorage ( e % Nxyz ( 1 )) % w , & wy => NodalStorage ( e % Nxyz ( 2 )) % w , & wz => NodalStorage ( e % Nxyz ( 3 )) % w ) ! !        Initialization !        -------------- val = 0.0_RP ! !        Perform the numerical integration !        --------------------------------- select case ( integralType ) case ( VOLUME ) ! !           ********************************** !           Computes the volume integral !              val = \\int dV !           ********************************** ! do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) case ( KINETIC_ENERGY ) ! !           *********************************** !              Computes the kinetic energy !              integral: !              K = \\int \\rho V&#94;2 dV !           *********************************** ! KinEn = POW2 ( e % storage % Q ( IRHOU ,:,:,:)) KinEn = KinEn + POW2 ( e % storage % Q ( IRHOV ,:,:,:) ) KinEn = KinEn + POW2 ( e % storage % Q ( IRHOW ,:,:,:) ) KinEn = 0.5_RP * KinEn / e % storage % Q ( IRHO ,:,:,:) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * kinEn ( i , j , k ) end do ; end do ; end do case ( KINETIC_ENERGY_RATE ) ! !           *********************************** !              Computes the kinetic energy !              time derivative: !              K_t = (d/dt)\\int \\rho V&#94;2 dV !           *********************************** ! uvw = e % storage % Q ( IRHOU ,:,:,:) / e % storage % Q ( IRHO ,:,:,:) KinEn = uvw * e % storage % QDot ( IRHOU ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( IRHO ,:,:,:) uvw = e % storage % Q ( IRHOV ,:,:,:) / e % storage % Q ( IRHO ,:,:,:) KinEn = KinEn + uvw * e % storage % QDot ( IRHOV ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( IRHO ,:,:,:) uvw = e % storage % Q ( IRHOW ,:,:,:) / e % storage % Q ( IRHO ,:,:,:) KinEn = KinEn + uvw * e % storage % QDot ( IRHOW ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( IRHO ,:,:,:) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * kinEn ( i , j , k ) end do ; end do ; end do case ( KINETIC_ENERGY_BALANCE ) ! !           *************************************************** !              Computes the kinetic energy !              balance: will also work the for Pirozzoli scheme !              with energy gradient variables. !           *************************************************** ! inv_rho = 1.0_RP / e % storage % Q ( IRHO ,:,:,:) uvw = e % storage % Q ( IRHOU ,:,:,:) * inv_rho KinEn = uvw * e % storage % QDot ( IRHOU ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( IRHO ,:,:,:) uvw = e % storage % Q ( IRHOV ,:,:,:) * inv_rho KinEn = KinEn + uvw * e % storage % QDot ( IRHOV ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( IRHO ,:,:,:) uvw = e % storage % Q ( IRHOW ,:,:,:) * inv_rho KinEn = KinEn + uvw * e % storage % QDot ( IRHOW ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( IRHO ,:,:,:) ! !           I also need the pressure work !           ----------------------------- p_3d = thermodynamics % gammaMinus1 * ( e % storage % Q ( IRHOE ,:,:,:) & - 0.5_RP * ( POW2 ( e % storage % Q ( IRHOU ,:,:,:)) + POW2 ( e % storage % Q ( IRHOV ,:,:,:)) + & POW2 ( e % storage % Q ( IRHOW ,:,:,:))) * inv_rho ) ! !           This correction term is because the split-form scheme will compute the pressure terms with de-aliased metrics, so I need !           to replicate that de-aliasing: 0.5<u,M∇p> + 0.5<u,∇(Mp)> = <u,∇(Mp)> + 0.5(<u,M∇p-∇(Mp)>). !           The first term is computed as <-p,M∇·u>, using the gradients, that already contain the surface term. !           ------------------------------------------------------------------------------------------------------------------------ call GetPressureLocalGradient ( Nel , p_3d , e % geom % jGradXi , e % geom % jGradEta , e % geom % jGradZeta , grad_Mp , M_grad_p ) correction_term = 0.5_RP * ( e % storage % Q ( IRHOU ,:,:,:) * ( M_grad_p ( IX ,:,:,:) - grad_Mp ( IX ,:,:,:)) & + e % storage % Q ( IRHOV ,:,:,:) * ( M_grad_p ( IY ,:,:,:) - grad_Mp ( IY ,:,:,:)) & + e % storage % Q ( IRHOW ,:,:,:) * ( M_grad_p ( IZ ,:,:,:) - grad_Mp ( IZ ,:,:,:))) * inv_rho do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call ViscousFlux_ENERGY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), e % storage % U_x (:, i , j , k ), e % storage % U_y (:, i , j , k ), & e % storage % U_z (:, i , j , k ), e % storage % mu_ns ( 1 , i , j , k ), 0.0_RP , e % storage % mu_ns ( 2 , i , j , k ), ViscFlux ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * ( e % geom % jacobian ( i , j , k ) * ( kinEn ( i , j , k ) + & sum ( ViscFlux ( 2 : 4 , 1 ) * e % storage % U_x ( 2 : 4 , i , j , k ) + ViscFlux ( 2 : 4 , 2 ) * e % storage % U_y ( 2 : 4 , i , j , k ) + ViscFlux ( 2 : 4 , 3 ) * e % storage % U_z ( 2 : 4 , i , j , k )) & - p_3d ( i , j , k ) * ( e % storage % U_x ( IRHOU , i , j , k ) + e % storage % U_y ( IRHOV , i , j , k ) + e % storage % U_z ( IRHOW , i , j , k ))) & + correction_term ( i , j , k )) end do ; end do ; end do val = val + e % storage % artificialDiss case ( ENSTROPHY ) ! !           *************************** !           Computes the flow enstrophy !           *************************** ! do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call getVelocityGradients ( e % storage % Q (:, i , j , k ),& e % storage % U_x (:, i , j , k ), & e % storage % U_y (:, i , j , k ), & e % storage % U_z (:, i , j , k ), & U_x (:, i , j , k ), U_y (:, i , j , k ), U_z (:, i , j , k )) KinEn = POW2 ( U_y ( IZ , i , j , k ) - U_z ( IY , i , j , k ) ) & + POW2 ( U_z ( IX , i , j , k ) - U_x ( IZ , i , j , k ) ) & + POW2 ( U_x ( IY , i , j , k ) - U_y ( IX , i , j , k ) ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * kinEn ( i , j , k ) end do ; end do ; end do case ( VELOCITY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * sqrt ( POW2 ( e % storage % Q ( IRHOU , i , j , k )) & + POW2 ( e % storage % Q ( IRHOV , i , j , k )) & + POW2 ( e % storage % Q ( IRHOW , i , j , k )) ) & / e % storage % Q ( IRHO , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do case ( ENTROPY ) ! !           ******************************************** !              Computes the specific entropy integral !           ******************************************** ! do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) p = Pressure ( e % storage % Q (:, i , j , k ) ) s = ( log ( p ) - thermodynamics % gamma * log ( e % storage % Q ( IRHO , i , j , k )) ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * s end do ; end do ; end do case ( MATH_ENTROPY ) ! !           ****************************************************************** !              Computes the mathematical entropy as: -\\rho s / (\\gamma - 1) !           ****************************************************************** ! do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) p = Pressure ( e % storage % Q (:, i , j , k ) ) s = ( log ( p ) - thermodynamics % gamma * log ( e % storage % Q ( IRHO , i , j , k )) ) ms = - e % storage % Q ( IRHO , i , j , k ) * s / thermodynamics % gammaMinus1 val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ms end do ; end do ; end do case ( ENTROPY_RATE ) ! !           ************************************************************ !              Computes the specific entropy integral time derivative !           ************************************************************ ! do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call NSGradientVariables_ENTROPY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), EntropyVars ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * dot_product ( e % storage % QDot (:, i , j , k ), EntropyVars ) end do ; end do ; end do case ( ENTROPY_BALANCE ) ! !           **************************************************************************** !              Computes the specific entropy integral time derivative minus viscous work !           **************************************************************************** ! select case ( grad_vars ) case ( GRADVARS_STATE ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call NSGradientVariables_ENTROPY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), EntropyVars ) call ViscousFlux_STATE ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), e % storage % U_x (:, i , j , k ), e % storage % U_y (:, i , j , k ), & e % storage % U_z (:, i , j , k ), e % storage % mu_ns ( 1 , i , j , k ), 0.0_RP , e % storage % mu_ns ( 2 , i , j , k ), ViscFlux ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ( dot_product ( e % storage % QDot (:, i , j , k ), EntropyVars ) + & sum ( ViscFlux (:, 1 ) * e % storage % U_x (:, i , j , k ) + ViscFlux (:, 2 ) * e % storage % U_y (:, i , j , k ) + ViscFlux (:, 3 ) * e % storage % U_z (:, i , j , k ))) end do ; end do ; end do case ( GRADVARS_ENTROPY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call NSGradientVariables_ENTROPY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), EntropyVars ) call ViscousFlux_ENTROPY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), e % storage % U_x (:, i , j , k ), e % storage % U_y (:, i , j , k ), & e % storage % U_z (:, i , j , k ), e % storage % mu_ns ( 1 , i , j , k ), 0.0_RP , e % storage % mu_ns ( 2 , i , j , k ), ViscFlux ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ( dot_product ( e % storage % QDot (:, i , j , k ), EntropyVars ) + & sum ( ViscFlux (:, 1 ) * e % storage % U_x (:, i , j , k ) + ViscFlux (:, 2 ) * e % storage % U_y (:, i , j , k ) + ViscFlux (:, 3 ) * e % storage % U_z (:, i , j , k ))) end do ; end do ; end do val = val + e % storage % artificialDiss case ( GRADVARS_ENERGY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call NSGradientVariables_ENTROPY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), EntropyVars ) call ViscousFlux_ENERGY ( NCONS , NGRAD , e % storage % Q (:, i , j , k ), e % storage % U_x (:, i , j , k ), e % storage % U_y (:, i , j , k ), & e % storage % U_z (:, i , j , k ), e % storage % mu_ns ( 1 , i , j , k ), 0.0_RP , e % storage % mu_ns ( 2 , i , j , k ), ViscFlux ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ( dot_product ( e % storage % QDot (:, i , j , k ), EntropyVars ) + & sum ( ViscFlux (:, 1 ) * e % storage % U_x (:, i , j , k ) + ViscFlux (:, 2 ) * e % storage % U_y (:, i , j , k ) + ViscFlux (:, 3 ) * e % storage % U_z (:, i , j , k ))) end do ; end do ; end do end select case ( ARTIFICIAL_DISSIPATION ) val = val + e % storage % artificialDiss case ( INTERNAL_ENERGY ) ! !           *********************************** !              Computes the internal energy !              integral: !              \\rho e = \\int \\rho e dV !           *********************************** ! do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * e % storage % Q ( IRHOE , i , j , k ) end do ; end do ; end do #endif #if defined(INCNS) case ( MASS ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * e % storage % Q ( INSRHO , i , j , k ) end do ; end do ; end do case ( ENTROPY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) entr = 0.5_RP * ( sum ( POW2 ( e % storage % Q ( INSRHOU : INSRHOW , i , j , k )))) / e % storage % Q ( INSRHO , i , j , k ) & + 0.5_RP * POW2 ( e % storage % Q ( INSP , i , j , k )) / thermodynamics % rho0c02 val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * entr end do ; end do ; end do case ( KINETIC_ENERGY_RATE ) ! !           *********************************** !              Computes the kinetic energy !              time derivative: !              K_t = (d/dt)\\int \\rho V&#94;2 dV !           *********************************** ! uvw = e % storage % Q ( INSRHOU ,:,:,:) / e % storage % Q ( INSRHO ,:,:,:) KinEn = uvw * e % storage % QDot ( INSRHOU ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( INSRHO ,:,:,:) uvw = e % storage % Q ( INSRHOV ,:,:,:) / e % storage % Q ( INSRHO ,:,:,:) KinEn = KinEn + uvw * e % storage % QDot ( INSRHOV ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( INSRHO ,:,:,:) uvw = e % storage % Q ( INSRHOW ,:,:,:) / e % storage % Q ( INSRHO ,:,:,:) KinEn = KinEn + uvw * e % storage % QDot ( INSRHOW ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( INSRHO ,:,:,:) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * kinEn ( i , j , k ) end do ; end do ; end do case ( ENTROPY_RATE ) ! !           *********************************** !              Computes the kinetic energy !              time derivative: !              K_t = (d/dt)\\int \\rho V&#94;2 dV !           *********************************** ! uvw = e % storage % Q ( INSRHOU ,:,:,:) / e % storage % Q ( INSRHO ,:,:,:) KinEn = uvw * e % storage % QDot ( INSRHOU ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( INSRHO ,:,:,:) uvw = e % storage % Q ( INSRHOV ,:,:,:) / e % storage % Q ( INSRHO ,:,:,:) KinEn = KinEn + uvw * e % storage % QDot ( INSRHOV ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( INSRHO ,:,:,:) uvw = e % storage % Q ( INSRHOW ,:,:,:) / e % storage % Q ( INSRHO ,:,:,:) KinEn = KinEn + uvw * e % storage % QDot ( INSRHOW ,:,:,:) - 0.5_RP * POW2 ( uvw ) * e % storage % QDot ( INSRHO ,:,:,:) KinEn = KinEn + ( 1.0_RP / thermodynamics % rho0c02 ) * e % storage % Q ( INSP ,:,:,:) * e % storage % QDot ( INSP ,:,:,:) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * kinEn ( i , j , k ) end do ; end do ; end do #endif #ifdef MULTIPHASE case ( ENTROPY_RATE ) ! !           *********************************** !              Computes the kinetic energy !              time derivative: !              K_t = (d/dt)\\int \\rho V&#94;2 dV !           *********************************** ! KinEn = e % storage % QDot ( IMC ,:,:,:) * e % storage % mu ( 1 ,:,:,:) KinEn = KinEn + e % storage % Q ( IMSQRHOU ,:,:,:) * e % storage % QDot ( IMSQRHOU ,:,:,:) KinEn = KinEn + e % storage % Q ( IMSQRHOV ,:,:,:) * e % storage % QDot ( IMSQRHOV ,:,:,:) KinEn = KinEn + e % storage % Q ( IMSQRHOW ,:,:,:) * e % storage % QDot ( IMSQRHOW ,:,:,:) !KinEn = KinEn + dimensionless % Ma2*e % storage % Q(IMP,:,:,:)*e % storage % QDot(IMP,:,:,:) Ma2 = dimensionless % Ma2 ( 1 ) * e % storage % Q ( IMC ,:,:,:) + dimensionless % Ma2 ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC ,:,:,:)) KinEn = KinEn + Ma2 * e % storage % Q ( IMP ,:,:,:) * e % storage % QDot ( IMP ,:,:,:) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * kinEn ( i , j , k ) end do ; end do ; end do case ( ENTROPY_BALANCE ) ! !           *********************************** !              Computes the kinetic energy !              time derivative: !              K_t = (d/dt)\\int \\rho V&#94;2 dV !           *********************************** ! KinEn = e % storage % QDot ( IMC ,:,:,:) * e % storage % mu ( 1 ,:,:,:) KinEn = KinEn + e % storage % Q ( IMSQRHOU ,:,:,:) * e % storage % QDot ( IMSQRHOU ,:,:,:) KinEn = KinEn + e % storage % Q ( IMSQRHOV ,:,:,:) * e % storage % QDot ( IMSQRHOV ,:,:,:) KinEn = KinEn + e % storage % Q ( IMSQRHOW ,:,:,:) * e % storage % QDot ( IMSQRHOW ,:,:,:) !KinEn = KinEn + dimensionless % Ma2*e % storage % Q(IMP,:,:,:)*e % storage % QDot(IMP,:,:,:) Ma2 = dimensionless % Ma2 ( 1 ) * e % storage % Q ( IMC ,:,:,:) + dimensionless % Ma2 ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC ,:,:,:)) KinEn = KinEn + Ma2 * e % storage % Q ( IMP ,:,:,:) * e % storage % QDot ( IMP ,:,:,:) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) mu = max ( min ( e % storage % Q ( IMC , i , j , k ), 1.0_RP ), 0.0_RP ) mu = dimensionless % mu ( 2 ) + ( dimensionless % mu ( 1 ) - dimensionless % mu ( 2 )) * mu Strain ( 1 , 1 ) = e % storage % U_x ( IGU , i , j , k ) Strain ( 2 , 2 ) = e % storage % U_y ( IGV , i , j , k ) Strain ( 3 , 3 ) = e % storage % U_z ( IGW , i , j , k ) Strain ( 1 , 2 ) = 0.5_RP * ( e % storage % U_x ( IGV , i , j , k ) + e % storage % U_y ( IGU , i , j , k )) Strain ( 1 , 3 ) = 0.5_RP * ( e % storage % U_x ( IGW , i , j , k ) + e % storage % U_z ( IGU , i , j , k )) Strain ( 2 , 3 ) = 0.5_RP * ( e % storage % U_y ( IGW , i , j , k ) + e % storage % U_z ( IGV , i , j , k )) Strain ( 2 , 1 ) = Strain ( 1 , 2 ) Strain ( 3 , 1 ) = Strain ( 1 , 3 ) Strain ( 3 , 2 ) = Strain ( 2 , 3 ) !               Strain = 0.0_RP val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ( kinEn ( i , j , k ) + 2.0_RP * mu * sum ( Strain * Strain ) & + multiphase % M0 * ( POW2 ( e % storage % U_x ( IGMU , i , j , k )) + POW2 ( e % storage % U_y ( IGMU , i , j , k )) + POW2 ( e % storage % U_z ( IGMU , i , j , k )) ) ) end do ; end do ; end do case ( PHASE2_AREA ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) end do ; end do ; end do case ( PHASE2_XCOG ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * e % geom % x ( IX , i , j , k ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) end do ; end do ; end do val = val case ( PHASE2_XVEL ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) rho = dimensionless % rho ( 1 ) * e % storage % Q ( IMC , i , j , k ) + dimensionless % rho ( 2 ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * e % storage % Q ( IMSQRHOU , i , j , k ) * ( 1.0_RP - e % storage % Q ( IMC , i , j , k )) / sqrt ( rho ) end do ; end do ; end do #endif #if defined(CAHNHILLIARD) case ( FREE_ENERGY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) call QuarticDWP ( e % storage % c ( 1 , i , j , k ), fchem ) free_en = fchem + 0.5_RP * POW2 ( multiphase % eps ) * ( POW2 ( e % storage % c_x ( 1 , i , j , k )) & + POW2 ( e % storage % c_y ( 1 , i , j , k )) & + POW2 ( e % storage % c_z ( 1 , i , j , k )) ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * free_en end do ; end do ; end do #endif #if defined(ACOUSTIC) case ( ACOUSTIC_ENERGY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % geom % jacobian ( i , j , k ) * ( & 0.5_RP * e % storage % Qbase ( ICAARHO , i , j , k ) * ( POW2 ( e % storage % Q ( ICAAU , i , j , k )) & + POW2 ( e % storage % Q ( ICAAV , i , j , k )) & + POW2 ( e % storage % Q ( ICAAW , i , j , k )) ) & + 0.5_RP / ( thermodynamics % gamma * e % storage % Qbase ( ICAAP , i , j , k )) * POW2 ( e % storage % Q ( ICAAP , i , j , k )) ) end do ; end do ; end do #endif end select end associate end function ScalarVolumeIntegral_Local ! !//////////////////////////////////////////////////////////////////////////////////////// ! !           VECTOR INTEGRALS PROCEDURES ! !//////////////////////////////////////////////////////////////////////////////////////// ! function VectorVolumeIntegral ( mesh , integralType , num_of_vars ) result ( val ) ! !        ----------------------------------------------------------- !           This function computes vector integrals, that is, those !           in the form: !                 val = \\int \\vec{v} dx !           Implemented integrals are: !              * VELOCITY !              * MOMENTUM !        ----------------------------------------------------------- ! implicit none class ( HexMesh ), intent ( in ) :: mesh integer , intent ( in ) :: integralType integer , intent ( in ) :: num_of_vars real ( kind = RP ) :: val ( num_of_vars ) ! !        --------------- !        Local variables !        --------------- ! logical :: fiveVars integer :: eID , ierr real ( kind = RP ) :: localVal ( num_of_vars ) real ( kind = RP ) :: valAux ( num_of_vars ) real ( kind = RP ) :: val1 , val2 , val3 , val4 , val5 if ( num_of_vars == 5 ) then ! Ugly hack.. But only way to make it work with ifort.... fiveVars = . TRUE . else fiveVars = . FALSE . end if ! !        Initialization !        -------------- val1 = 0.0_RP val2 = 0.0_RP val3 = 0.0_RP val4 = 0.0_RP val5 = 0.0_RP ! !        Loop the mesh !        ------------- !$omp parallel do reduction(+:val1,val2,val3,val4,val5) private(valAux) schedule(guided) do eID = 1 , mesh % no_of_elements ! !           Compute the integral !           -------------------- valAux = VectorVolumeIntegral_Local ( mesh % elements ( eID ), integralType , num_of_vars ) val1 = val1 + valAux ( 1 ) val2 = val2 + valAux ( 2 ) val3 = val3 + valAux ( 3 ) if ( fiveVars ) then val4 = val4 + valAux ( 4 ) val5 = val5 + valAux ( 5 ) end if end do !$omp end parallel do val ( 1 : 3 ) = [ val1 , val2 , val3 ] if ( fiveVars ) val ( 4 : 5 ) = [ val4 , val5 ] #ifdef _HAS_MPI_ localVal = val call mpi_allreduce ( localVal , val , num_of_vars , MPI_DOUBLE , MPI_SUM , MPI_COMM_WORLD , ierr ) #endif end function VectorVolumeIntegral ! !//////////////////////////////////////////////////////////////////////////////////////// ! function VectorVolumeIntegral_Local ( e , integralType , num_of_vars ) result ( val ) implicit none !-arguments--------------------------------------------------- class ( Element ), target , intent ( in ) :: e integer , intent ( in ) :: integralType integer , intent ( in ) :: num_of_vars real ( kind = RP ) :: val ( num_of_vars ) !-local-variables--------------------------------------------- integer :: Nel ( 3 ) ! Element polynomial order integer :: i , j , k !------------------------------------------------------------- Nel = e % Nxyz associate ( wx => NodalStorage ( e % Nxyz ( 1 )) % w , & wy => NodalStorage ( e % Nxyz ( 2 )) % w , & wz => NodalStorage ( e % Nxyz ( 3 )) % w ) ! !        Initialization !        -------------- val = 0.0_RP ! !        Perform the numerical integration !        --------------------------------- select case ( integralType ) #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) case ( VELOCITY ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % Q ( IRHOU : IRHOW , i , j , k ) / e % storage % Q ( IRHO , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do case ( MOMENTUM ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % Q ( IRHOU : IRHOW , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do case ( SOURCE ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % S_NS ( 1 : num_of_vars , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do case ( PSOURCE ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % S_NSP ( 1 : num_of_vars , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do #endif #if defined(INCNS) case ( SOURCE ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % S_NS ( 1 : num_of_vars , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do #endif #if defined(MULTIPHASE) case ( SOURCE ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % S_NS ( 1 : num_of_vars , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do #endif #if defined(ACOUSTIC) case ( SOURCE ) do k = 0 , Nel ( 3 ) ; do j = 0 , Nel ( 2 ) ; do i = 0 , Nel ( 1 ) val = val + wx ( i ) * wy ( j ) * wz ( k ) * e % storage % S_NS ( 1 : num_of_vars , i , j , k ) * e % geom % jacobian ( i , j , k ) end do ; end do ; end do #endif case default write ( STD_OUT , '(A,A)' ) 'VectorVolumeIntegral :: ERROR: Not defined integral type' error stop 99 end select end associate end function VectorVolumeIntegral_Local subroutine GetPressureLocalGradient ( N , p , Ja_xi , Ja_eta , Ja_zeta , grad_Mp , M_grad_p ) implicit none integer , intent ( in ) :: N ( 3 ) real ( kind = RP ), intent ( in ) :: p ( 0 : N ( 1 ), 0 : N ( 2 ), 0 : N ( 3 )) real ( kind = RP ), intent ( in ) :: Ja_xi ( 1 : NDIM , 0 : N ( 1 ), 0 : N ( 2 ), 0 : N ( 3 )) real ( kind = RP ), intent ( in ) :: Ja_eta ( 1 : NDIM , 0 : N ( 1 ), 0 : N ( 2 ), 0 : N ( 3 )) real ( kind = RP ), intent ( in ) :: Ja_zeta ( 1 : NDIM , 0 : N ( 1 ), 0 : N ( 2 ), 0 : N ( 3 )) real ( kind = RP ), intent ( out ) :: grad_Mp ( 1 : NDIM , 0 : N ( 1 ), 0 : N ( 2 ), 0 : N ( 3 )) real ( kind = RP ), intent ( out ) :: M_grad_p ( 1 : NDIM , 0 : N ( 1 ), 0 : N ( 2 ), 0 : N ( 3 )) ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , l type ( NodalStorage_t ), pointer :: spAxi , spAeta , spAzeta spAxi => NodalStorage ( N ( 1 )) spAeta => NodalStorage ( N ( 2 )) spAzeta => NodalStorage ( N ( 3 )) grad_Mp = 0.0_RP M_grad_p = 0.0_RP do k = 0 , N ( 3 ) ; do j = 0 , N ( 2 ) ; do l = 0 , N ( 1 ) ; do i = 0 , N ( 1 ) grad_Mp (:, i , j , k ) = grad_Mp (:, i , j , k ) + p ( l , j , k ) * Ja_xi (:, l , j , k ) * spAxi % D ( i , l ) M_grad_p (:, i , j , k ) = M_grad_p (:, i , j , k ) + p ( l , j , k ) * Ja_xi (:, i , j , k ) * spAxi % D ( i , l ) end do ; end do ; end do ; end do do k = 0 , N ( 3 ) ; do l = 0 , N ( 2 ) ; do j = 0 , N ( 2 ) ; do i = 0 , N ( 1 ) grad_Mp (:, i , j , k ) = grad_Mp (:, i , j , k ) + p ( i , l , k ) * Ja_eta (:, i , l , k ) * spAeta % D ( j , l ) M_grad_p (:, i , j , k ) = M_grad_p (:, i , j , k ) + p ( i , l , k ) * Ja_eta (:, i , j , k ) * spAeta % D ( j , l ) end do ; end do ; end do ; end do do l = 0 , N ( 3 ) ; do k = 0 , N ( 3 ) ; do j = 0 , N ( 2 ) ; do i = 0 , N ( 1 ) grad_Mp (:, i , j , k ) = grad_Mp (:, i , j , k ) + p ( i , j , l ) * Ja_zeta (:, i , j , l ) * spAzeta % D ( k , l ) M_grad_p (:, i , j , k ) = M_grad_p (:, i , j , k ) + p ( i , j , l ) * Ja_zeta (:, i , j , k ) * spAzeta % D ( k , l ) end do ; end do ; end do ; end do nullify ( spAxi , spAeta , spAzeta ) end subroutine GetPressureLocalGradient subroutine GetSensorRange ( mesh , minSensor , maxSensor ) implicit none class ( HexMesh ), intent ( in ) :: mesh real ( RP ), intent ( out ) :: minSensor real ( RP ), intent ( out ) :: maxSensor ! !        --------------- !        Local variables !        --------------- ! integer :: ielem integer :: ierr minSensor = huge ( 1.0_RP ) / 1 0.0_RP maxSensor = - huge ( 1.0_RP ) / 1 0.0_RP !! !$omp parallel do schedule(static) private(ielem) ! do ielem = 1, mesh % no_of_elements !    minSensor = min(minSensor, mesh % elements(ielem) % storage % sensor) !    maxSensor = max(maxSensor, mesh % elements(ielem) % storage % sensor) ! end do !! !$omp end parallel do !$omp parallel shared(maxSensor, minSensor, mesh) default(private) !$omp do reduction(max:maxSensor) schedule(runtime) DO ielem = 1 , mesh % no_of_elements maxSensor = max ( maxSensor , mesh % elements ( ielem ) % storage % sensor ) END DO !$omp end do !$omp do reduction(min:minSensor) schedule(runtime) DO ielem = 1 , mesh % no_of_elements minSensor = min ( minSensor , mesh % elements ( ielem ) % storage % sensor ) END DO !$omp end do !$omp end parallel #ifdef _HAS_MPI_ call MPI_MinMax ( minSensor , maxSensor ) #endif end subroutine GetSensorRange end module VolumeIntegrals","tags":"","url":"sourcefile/volumeintegrals.f90.html"},{"title":"LoadBalancingMonitor.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module LoadBalancingMonitorClass use SMConstants use HexMeshClass use MonitorDefinitions use MPI_Process_Info #ifdef _HAS_MPI_ use mpi #endif implicit none private public LoadBalancingMonitor_t ! !  *************************************** !  Load balancing monitor class definition !  *************************************** ! type LoadBalancingMonitor_t logical :: active integer :: ID integer :: bufferLine integer :: num_of_vars real ( kind = RP ), allocatable :: values (:,:) character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => LoadBalancingMonitor_Initialization procedure :: Update => LoadBalancingMonitor_Update procedure :: WriteLabel => LoadBalancingMonitor_WriteLabel procedure :: WriteValues => LoadBalancingMonitor_WriteValue procedure :: WriteToFile => LoadBalancingMonitor_WriteToFile procedure :: getLast => LoadBalancingMonitor_GetLast procedure :: destruct => LoadBalancingMonitor_Destruct procedure :: copy => LoadBalancingMonitor_Assign generic :: assignment ( = ) => copy end type LoadBalancingMonitor_t ! !  ======== contains !  ======== ! ! !/////////////////////////////////////////////////////////////////////////// ! !           LOAD BALANCING MONITOR PROCEDURES !           --------------------------------- !/////////////////////////////////////////////////////////////////////////// ! subroutine LoadBalancingMonitor_Initialization ( self , mesh , ID , solution_file , FirstCall ) ! !        ***************************************************************************** !              This subroutine initializes the load balancing monitor. The following !           data is obtained from the case file: !              -> Name: The monitor name (10 characters maximum) !              -> Variable: The variable to be monitorized. !        ***************************************************************************** ! use ParamfileRegions use Utilities , only : toLower implicit none class ( LoadBalancingMonitor_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile integer :: fID ! !        Get monitor ID !        -------------- self % ID = ID ! !        Search for the parameters in the case file !        ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define load balancing monitor \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ) , \"name\" , self % monitorName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"variable\" , self % variable , in_label , \"# end\" ) ! !        Enable the monitor !        ------------------ self % active = . true . self % bufferLine = 1 ! !        Select the variable from the available list, and compute auxiliary variables if needed !        -------------------------------------------------------------------------------------- self % num_of_vars = 1 call toLower ( self % variable ) select case ( trim ( self % variable ) ) case ( \"max dof per partition\" ) case ( \"max dof\" ) case ( \"min dof per partition\" ) case ( \"min dof\" ) case ( \"avg dof per partition\" ) case ( \"avg dof\" ) case ( \"absolute dof unbalancing\" ) case ( \"abs unbalancing\" ) case ( \"relative dof unbalancing\" ) case ( \"rel unbalancing\" ) case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for load balancing monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" load balancing monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * Max DOF per partition or Max DOF\" print * , \"   * Min DOF per partition or Min DOF\" print * , \"   * Avg DOF per partition or Avg DOF\" print * , \"   * Absolute DOF unbalancing or Abs unbalancing\" print * , \"   * Relative DOF unbalancing or Rel unbalancing\" error stop \"error stopped.\" end if end select allocate ( self % values ( self % num_of_vars , BUFFER_SIZE ) ) ! !        Prepare the file in which the monitor is exported !        ------------------------------------------------- write ( self % fileName , '(A,A,A,A)' ) trim ( solution_file ) , \".\" , trim ( self % monitorName ) , \".loadbalancing\" ! !        Create file !        ----------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) ! !        Write the file headers !        ---------------------- write ( fID , '(A20,A  )' ) \"#Monitor name:      \" , trim ( self % monitorName ) write ( fID , '(A20,A  )' ) \"#Selected variable: \" , trim ( self % variable ) write ( fID , * ) write ( fID , '(A10,2X,A24,2X,A24)' ) \"#Iteration\" , \"Time\" , trim ( self % variable ) close ( fID ) end if end subroutine LoadBalancingMonitor_Initialization subroutine LoadBalancingMonitor_Update ( self , mesh , bufferPosition ) ! !        ******************************************************************* !           This subroutine updates the monitor value computing it from !           the mesh. It is stored in the \"bufferPosition\" position of the !           buffer. !        ******************************************************************* ! implicit none class ( LoadBalancingMonitor_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition !        --- local-variables --------------------------------- integer :: maxDOF , minDOF , avgDOF integer :: partitionDOF ( MPI_Process % nProcs ) self % bufferLine = bufferPosition ! !        Compute the volume integral !        --------------------------- select case ( trim ( self % variable ) ) #ifdef _HAS_MPI_ case ( \"max dof per partition\" ) self % values ( 1 , bufferPosition ) = maxval ( CumputePartitionDOF ( mesh )) case ( \"max dof\" ) self % values ( 1 , bufferPosition ) = maxval ( CumputePartitionDOF ( mesh )) case ( \"min dof per partition\" ) self % values ( 1 , bufferPosition ) = minval ( CumputePartitionDOF ( mesh )) case ( \"min dof\" ) self % values ( 1 , bufferPosition ) = minval ( CumputePartitionDOF ( mesh )) case ( \"avg dof per partition\" ) self % values ( 1 , bufferPosition ) = sum ( CumputePartitionDOF ( mesh )) / MPI_Process % nProcs case ( \"avg dof\" ) self % values ( 1 , bufferPosition ) = sum ( CumputePartitionDOF ( mesh )) / MPI_Process % nProcs case ( \"absolute dof unbalancing\" ) partitionDOF = CumputePartitionDOF ( mesh ) maxDOF = maxval ( partitionDOF ) minDOF = minval ( partitionDOF ) self % values ( 1 , bufferPosition ) = maxDOF - minDOF case ( \"abs unbalancing\" ) partitionDOF = CumputePartitionDOF ( mesh ) maxDOF = maxval ( partitionDOF ) minDOF = minval ( partitionDOF ) self % values ( 1 , bufferPosition ) = maxDOF - minDOF case ( \"relative dof unbalancing\" ) partitionDOF = CumputePartitionDOF ( mesh ) maxDOF = maxval ( partitionDOF ) minDOF = minval ( partitionDOF ) avgDOF = sum ( partitionDOF ) / MPI_Process % nProcs self % values ( 1 , bufferPosition ) = 10 0.0_RP * ( maxDOF - minDOF ) / avgDOF case ( \"rel unbalancing\" ) partitionDOF = CumputePartitionDOF ( mesh ) maxDOF = maxval ( partitionDOF ) minDOF = minval ( partitionDOF ) avgDOF = sum ( partitionDOF ) / MPI_Process % nProcs self % values ( 1 , bufferPosition ) = 10 0.0_RP * ( maxDOF - minDOF ) / avgDOF #endif end select end subroutine LoadBalancingMonitor_Update subroutine LoadBalancingMonitor_WriteLabel ( self ) ! !        ************************************************************* !              This subroutine writes the label for the load balancing !           monitor, when invoked from the time integrator Display !           procedure. !        ************************************************************* ! implicit none class ( LoadBalancingMonitor_t ) :: self write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) trim ( self % monitorName ( 1 : MONITOR_LENGTH )) end subroutine LoadBalancingMonitor_WriteLabel ! !        ************************************************************* !        WriteValue: This subroutine writes the monitor value for the time !           integrator Display procedure. !        ************************************************************* subroutine LoadBalancingMonitor_WriteValue ( self , bufferLine ) implicit none !-arguments----------------------------------------------- class ( LoadBalancingMonitor_t ) :: self integer :: bufferLine !-local-variables----------------------------------------- integer :: i !--------------------------------------------------------- do i = 1 , self % num_of_vars write ( STD_OUT , '(1X,A,1X,ES10.3)' , advance = \"no\" ) \"|\" , self % values ( i , bufferLine ) end do end subroutine LoadBalancingMonitor_WriteValue subroutine LoadBalancingMonitor_WriteToFile ( self , iter , t , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( LoadBalancingMonitor_t ) :: self integer :: iter (:) real ( kind = RP ) :: t (:) integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i integer :: fID character ( len = LINE_LENGTH ) :: fmt !        --------------------------------------------------------- if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) write ( fmt , '(A,I0,A)' ) '(I10,2X,ES24.16,' , size ( self % values , 1 ), '(2X,ES24.16))' do i = 1 , no_of_lines write ( fID , fmt ) iter ( i ) , t ( i ) , self % values (:, i ) end do close ( fID ) end if if ( no_of_lines . ne . 0 ) self % values (:, 1 ) = self % values (:, no_of_lines ) end subroutine LoadBalancingMonitor_WriteToFile ! !///////////////////////////////////////////////////////////////////////////////////////////// ! function LoadBalancingMonitor_GetLast ( self ) result ( lastValues ) implicit none class ( LoadBalancingMonitor_t ), intent ( in ) :: self real ( kind = RP ) :: lastValues ( size ( self % values , 1 ) ) lastValues (:) = self % values (:, self % bufferLine ) end function LoadBalancingMonitor_GetLast ! !///////////////////////////////////////////////////////////////////////////////////////////// ! elemental subroutine LoadBalancingMonitor_Destruct ( self ) implicit none class ( LoadBalancingMonitor_t ), intent ( inout ) :: self deallocate ( self % values ) end subroutine LoadBalancingMonitor_Destruct elemental subroutine LoadBalancingMonitor_Assign ( to , from ) implicit none class ( LoadBalancingMonitor_t ), intent ( inout ) :: to type ( LoadBalancingMonitor_t ) , intent ( in ) :: from to % active = from % active to % ID = from % ID safedeallocate ( to % values ) allocate ( to % values ( size ( from % values , 1 ) , size ( from % values , 2 ) ) ) to % values = from % values to % monitorName = from % monitorName to % fileName = from % fileName to % variable = from % variable end subroutine LoadBalancingMonitor_Assign ! !///////////////////////////////////////////////////////////////////////////////////////////// ! !     Additional functions ! !///////////////////////////////////////////////////////////////////////////////////////////// ! function CumputePartitionDOF ( mesh ) result ( partitionDOF ) implicit none class ( HexMesh ) :: mesh integer :: partitionDOF ( MPI_Process % nProcs ) !        ---- local-variables ---------------------------------------------------- integer :: eID , ierr integer :: Nx ( mesh % no_of_elements ), Ny ( mesh % no_of_elements ), Nz ( mesh % no_of_elements ) integer :: local_DOFs !        --------------------------------------------------------------------------- ! !        Get polynomial order in all partitions !        ---------------------------------------- !$omp parallel do schedule(runtime) do eID = 1 , mesh % no_of_elements Nx ( eID ) = mesh % elements ( eID ) % Nxyz ( 1 ) Ny ( eID ) = mesh % elements ( eID ) % Nxyz ( 2 ) Nz ( eID ) = mesh % elements ( eID ) % Nxyz ( 3 ) enddo !$omp end parallel do ! !     -------------------------------------------------------------------------- !     Perform a reduction to know how many DOFs are in each process !     -------------------------------------------------------------------------- local_DOFs = SUM (( Nx (:) + 1 ) * ( Ny (:) + 1 ) * ( Nz (:) + 1 )) if ( MPI_Process % doMPIAction ) then #ifdef _HAS_MPI_ call mpi_allgather ( local_DOFs , 1 , MPI_INT , partitionDOF , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) #endif else partitionDOF ( 1 ) = local_DOFs end if end function CumputePartitionDOF end module LoadBalancingMonitorClass","tags":"","url":"sourcefile/loadbalancingmonitor.f90.html"},{"title":"VolumeMonitor.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module VolumeMonitorClass use SMConstants use HexMeshClass use MonitorDefinitions use PhysicsStorage use MPI_Process_Info implicit none private !~   public VOLUME #if defined(NAVIERSTOKES) !~   public KINETIC_ENERGY, KINETIC_ENERGY_RATE, ENSTROPHY !~   public ENTROPY, ENTROPY_RATE, INTERNAL_ENERGY #elif defined(CAHNHILLIARD) !~   public FREE_ENERGY #endif public VolumeMonitor_t ! !  ******************************* !  Volume monitor class definition !  ******************************* ! type VolumeMonitor_t logical :: active integer :: ID integer :: bufferLine integer :: num_of_vars real ( kind = RP ), allocatable :: values (:,:) character ( len = STR_LEN_MONITORS ) :: monitorName character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: variable contains procedure :: Initialization => VolumeMonitor_Initialization procedure :: Update => VolumeMonitor_Update procedure :: WriteLabel => VolumeMonitor_WriteLabel procedure :: WriteValues => VolumeMonitor_WriteValue procedure :: WriteToFile => VolumeMonitor_WriteToFile procedure :: getLast => VolumeMonitor_GetLast procedure :: destruct => VolumeMonitor_Destruct procedure :: copy => VolumeMonitor_Assign generic :: assignment ( = ) => copy end type VolumeMonitor_t ! !  ======== contains !  ======== ! ! !/////////////////////////////////////////////////////////////////////////// ! !           VOLUME MONITOR PROCEDURES !           ------------------------- !/////////////////////////////////////////////////////////////////////////// ! subroutine VolumeMonitor_Initialization ( self , mesh , ID , solution_file , FirstCall ) ! !        ***************************************************************************** !              This subroutine initializes the volume monitor. The following !           data is obtained from the case file: !              -> Name: The monitor name (10 characters maximum) !              -> Variable: The variable to be monitorized. !        ***************************************************************************** ! use ParamfileRegions use Utilities , only : toLower implicit none class ( VolumeMonitor_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile integer :: fID integer :: pos ! !        Get monitor ID !        -------------- self % ID = ID ! !        Search for the parameters in the case file !        ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define volume monitor \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ) , \"name\" , self % monitorName , in_label , \"# end\" ) call readValueInRegion ( trim ( paramFile ) , \"variable\" , self % variable , in_label , \"# end\" ) ! !        Enable the monitor !        ------------------ self % active = . true . self % bufferLine = 1 ! !        Select the variable from the available list, and compute auxiliary variables if needed !        -------------------------------------------------------------------------------------- self % num_of_vars = 1 call toLower ( self % variable ) #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) select case ( trim ( self % variable ) ) case ( \"kinetic energy\" ) case ( \"kinetic energy rate\" ) case ( \"kinetic energy balance\" ) case ( \"enstrophy\" ) case ( \"entropy\" ) case ( \"entropy rate\" ) case ( \"entropy balance\" ) case ( \"math entropy\" ) case ( \"artificial dissipation\" ) case ( \"internal energy\" ) case ( \"mean velocity\" ) case ( \"velocity\" ) ; self % num_of_vars = 3 case ( \"momentum\" ) ; self % num_of_vars = 3 case ( \"source\" ) ; self % num_of_vars = NCONS case ( \"particles source\" ) ; self % num_of_vars = NCONS case ( \"sensor range\" ) ; self % num_of_vars = 2 case ( \"l2rho\" ) case ( \"l2rhou\" ) case ( \"l2rhoe\" ) case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for volume monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" volume monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * Kinetic energy\" print * , \"   * Kinetic energy rate\" print * , \"   * Kinetic energy balance\" print * , \"   * Enstrophy\" print * , \"   * Entropy\" print * , \"   * Entropy rate\" print * , \"   * Entropy balance\" print * , \"   * Math entropy\" print * , \"   * Artificial dissipation\" print * , \"   * Internal energy\" print * , \"   * Mean velocity\" print * , \"   * Velocity\" print * , \"   * Momentum\" print * , \"   * source\" print * , \"   * particles source\" print * , \"   * sensor range\" error stop \"error stopped.\" end if end select #elif defined(INCNS) select case ( trim ( self % variable ) ) case ( \"mass\" ) case ( \"entropy\" ) case ( \"kinetic energy rate\" ) case ( \"entropy rate\" ) case ( \"source\" ) ; self % num_of_vars = NCONS case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for volume monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" volume monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * Mass\" print * , \"   * Entropy\" print * , \"   * Kinetic energy rate\" print * , \"   * Entropy rate\" print * , \"   * source\" error stop \"error stopped.\" end if end select #elif defined(MULTIPHASE) select case ( trim ( self % variable ) ) case ( \"entropy rate\" ) case ( \"entropy balance\" ) case ( \"phase2-area\" ) case ( \"phase2-xcog\" ) case ( \"phase2-xvel\" ) case ( \"source\" ) ; self % num_of_vars = NCONS case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for volume monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" volume monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * Entropy rate\" print * , \"   * Entropy balance\" print * , \"   * Phase2-Area\" print * , \"   * Phase2-xCoG\" print * , \"   * Phase2-xVel\" print * , \"   * source\" error stop \"error stopped.\" end if end select #elif defined(CAHNHILLIARD) select case ( trim ( self % variable ) ) case ( \"free energy\" ) case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for volume monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" volume monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * Free energy\" error stop \"error stopped.\" end if end select #elif defined(ACOUSTIC) select case ( trim ( self % variable ) ) case ( \"acoustic energy\" ) case ( \"source\" ) ; self % num_of_vars = NCONS case default if ( len_trim ( self % variable ) . eq . 0 ) then print * , \"Variable was not specified for volume monitor \" , self % ID , \".\" else print * , 'Variable \"' , trim ( self % variable ), '\" volume monitor ' , self % ID , ' not implemented yet.' print * , \"Options available are:\" print * , \"   * acoustic energy\" print * , \"   * source\" error stop \"error stopped.\" end if end select #endif allocate ( self % values ( self % num_of_vars , BUFFER_SIZE ) ) ! !        Prepare the file in which the monitor is exported !        ------------------------------------------------- write ( self % fileName , '(A,A,A,A)' ) trim ( solution_file ) , \".\" , trim ( self % monitorName ) , \".volume\" ! !        Create file !        ----------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) ! !        Write the file headers !        ---------------------- write ( fID , '(A20,A  )' ) \"#Monitor name:      \" , trim ( self % monitorName ) write ( fID , '(A20,A  )' ) \"#Selected variable: \" , trim ( self % variable ) write ( fID , * ) select case ( trim ( self % variable ) ) case ( \"velocity\" ) write ( fID , '(A10,2X,A24,3(2X,A24))' ) \"#Iteration\" , \"Time\" , 'mean-u' , 'mean-v' , 'mean-w' case ( \"momentum\" ) write ( fID , '(A10,2X,A24,3(2X,A24))' ) \"#Iteration\" , \"Time\" , 'mean-rhou' , 'mean-rhov' , 'mean-rhow' case ( \"source\" ) write ( fID , '(A10,2X,A24,5(2X,A24))' ) \"#Iteration\" , \"Time\" , 'S1' , 'S2' , 'S3' , 'S4' , 'S5' case ( \"particles source\" ) write ( fID , '(A10,2X,A24,5(2X,A24))' ) \"#Iteration\" , \"Time\" , 'pS1' , 'pS2' , 'pS3' , 'pS4' , 'pS5' case ( \"sensor range\" ) write ( fID , '(A10,2X,A24,2(2X,A24))' ) \"#Iteration\" , \"Time\" , 'min sensor' , 'max sensor' case default write ( fID , '(A10,2X,A24,2X,A24)' ) \"#Iteration\" , \"Time\" , trim ( self % variable ) end select close ( fID ) end if end subroutine VolumeMonitor_Initialization subroutine VolumeMonitor_Update ( self , mesh , bufferPosition ) ! !        ******************************************************************* !           This subroutine updates the monitor value computing it from !           the mesh. It is stored in the \"bufferPosition\" position of the !           buffer. !        ******************************************************************* ! use VolumeIntegrals implicit none class ( VolumeMonitor_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition self % bufferLine = bufferPosition ! !        Compute the volume integral !        --------------------------- select case ( trim ( self % variable ) ) #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) case ( \"kinetic energy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , KINETIC_ENERGY ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"kinetic energy rate\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , KINETIC_ENERGY_RATE ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"kinetic energy balance\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , KINETIC_ENERGY_BALANCE ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"enstrophy\" ) self % values ( 1 , bufferPosition ) = 0.5_RP * ScalarVolumeIntegral ( mesh , ENSTROPHY ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"entropy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"entropy rate\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY_RATE ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"entropy balance\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY_BALANCE ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"math entropy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , MATH_ENTROPY ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"artificial dissipation\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ARTIFICIAL_DISSIPATION ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"internal energy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , INTERNAL_ENERGY ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"mean velocity\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , VELOCITY ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"velocity\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , VELOCITY , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"momentum\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , MOMENTUM , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"source\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , SOURCE , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"particles source\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , PSOURCE , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) case ( \"sensor range\" ) call GetSensorRange ( mesh , self % values ( 1 , bufferPosition ), self % values ( 2 , bufferPosition )) #elif defined(INCNS) case ( \"mass\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , MASS ) case ( \"entropy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY ) case ( \"kinetic energy rate\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , KINETIC_ENERGY_RATE ) case ( \"entropy rate\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY_RATE ) case ( \"source\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , SOURCE , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) #elif defined(MULTIPHASE) case ( \"entropy rate\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY_RATE ) case ( \"entropy balance\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ENTROPY_BALANCE ) case ( \"phase2-xcog\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , PHASE2_XCOG ) case ( \"phase2-xvel\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , PHASE2_XVEL ) case ( \"phase2-area\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , PHASE2_AREA ) case ( \"source\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , SOURCE , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) #elif defined(CAHNHILLIARD) case ( \"free energy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , FREE_ENERGY ) / ScalarVolumeIntegral ( mesh , VOLUME ) #elif defined(ACOUSTIC) case ( \"acoustic energy\" ) self % values ( 1 , bufferPosition ) = ScalarVolumeIntegral ( mesh , ACOUSTIC_ENERGY ) case ( \"source\" ) self % values (:, bufferPosition ) = VectorVolumeIntegral ( mesh , SOURCE , self % num_of_vars ) / ScalarVolumeIntegral ( mesh , VOLUME ) #endif end select end subroutine VolumeMonitor_Update subroutine VolumeMonitor_WriteLabel ( self ) ! !        ************************************************************* !              This subroutine writes the label for the volume !           monitor, when invoked from the time integrator Display !           procedure. !        ************************************************************* ! implicit none class ( VolumeMonitor_t ) :: self select case ( trim ( self % variable ) ) case ( \"velocity\" ) write ( STD_OUT , '(3(3X,A10))' , advance = \"no\" ) 'mean-u' , 'mean-v' , 'mean-w' case ( \"momentum\" ) write ( STD_OUT , '(3(3X,A10))' , advance = \"no\" ) 'mean-rhou' , 'mean-rhov' , 'mean-rhow' case ( \"source\" ) write ( STD_OUT , '(5(3X,A10))' , advance = \"no\" ) 'S1' , 'S2' , 'S3' , 'S4' , 'S5' case ( \"particles source\" ) write ( STD_OUT , '(5(3X,A10))' , advance = \"no\" ) 'pS1' , 'pS2' , 'pS3' , 'pS4' , 'pS5' case ( \"sensor range\" ) write ( STD_OUT , '(2(3X,A10))' , advance = \"no\" ) 'min sensor' , 'max sensor' case default write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) trim ( self % monitorName ( 1 : MONITOR_LENGTH )) end select end subroutine VolumeMonitor_WriteLabel ! !        ************************************************************* !        WriteValue: This subroutine writes the monitor value for the time !           integrator Display procedure. !        ************************************************************* subroutine VolumeMonitor_WriteValue ( self , bufferLine ) implicit none !-arguments----------------------------------------------- class ( VolumeMonitor_t ) :: self integer :: bufferLine !-local-variables----------------------------------------- integer :: i !--------------------------------------------------------- do i = 1 , self % num_of_vars write ( STD_OUT , '(1X,A,1X,ES10.3)' , advance = \"no\" ) \"|\" , self % values ( i , bufferLine ) end do end subroutine VolumeMonitor_WriteValue subroutine VolumeMonitor_WriteToFile ( self , iter , t , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( VolumeMonitor_t ) :: self integer :: iter (:) real ( kind = RP ) :: t (:) integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i integer :: fID character ( len = LINE_LENGTH ) :: fmt if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) write ( fmt , '(A,I0,A)' ) '(I10,2X,ES24.16,' , size ( self % values , 1 ), '(2X,ES24.16))' do i = 1 , no_of_lines write ( fID , fmt ) iter ( i ) , t ( i ) , self % values (:, i ) end do close ( fID ) end if if ( no_of_lines . ne . 0 ) self % values (:, 1 ) = self % values (:, no_of_lines ) end subroutine VolumeMonitor_WriteToFile ! !///////////////////////////////////////////////////////////////////////////////////////////// ! function VolumeMonitor_GetLast ( self ) result ( lastValues ) implicit none class ( VolumeMonitor_t ), intent ( in ) :: self real ( kind = RP ) :: lastValues ( size ( self % values , 1 ) ) lastValues (:) = self % values (:, self % bufferLine ) end function VolumeMonitor_GetLast ! !///////////////////////////////////////////////////////////////////////////////////////////// ! elemental subroutine VolumeMonitor_Destruct ( self ) implicit none class ( VolumeMonitor_t ), intent ( inout ) :: self deallocate ( self % values ) end subroutine VolumeMonitor_Destruct elemental subroutine VolumeMonitor_Assign ( to , from ) implicit none class ( VolumeMonitor_t ), intent ( inout ) :: to type ( VolumeMonitor_t ) , intent ( in ) :: from to % active = from % active to % ID = from % ID safedeallocate ( to % values ) allocate ( to % values ( size ( from % values , 1 ) , size ( from % values , 2 ) ) ) to % values = from % values to % monitorName = from % monitorName to % fileName = from % fileName to % variable = from % variable end subroutine VolumeMonitor_Assign end module VolumeMonitorClass","tags":"","url":"sourcefile/volumemonitor.f90.html"},{"title":"PlaneSampling.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module PlaneSampling use SMConstants use HexMeshClass use MonitorDefinitions use PhysicsStorage use VariableConversion use MPI_Process_Info use FluidData use FileReadingUtilities , only : getRealArrayFromString , GetRealValue , getCharArrayFromString use NodalStorageClass , only : NodalStorage #ifdef _HAS_MPI_ use mpi #endif implicit none private public PlaneSampling_t ! !  ******************************* !  PlaneSamplings class definition !  ******************************* ! type PlaneSampling_t logical , allocatable :: active (:) integer , allocatable :: rank (:) integer :: ID integer :: nVariables integer :: interval integer :: bufferSize integer :: bufferLine integer :: intervalCount integer :: N ( 2 ) integer :: nNodes integer , allocatable :: eID (:) real ( kind = RP ), allocatable :: lxi (:,:) , leta (:,:), lzeta (:,:) real ( kind = RP ), allocatable :: values (:,:,:) real ( kind = RP ), allocatable :: x (:,:) real ( kind = RP ), allocatable :: xi (:,:) logical :: disturbanceData = . false . character ( len = STR_LEN_MONITORS ), allocatable :: fileName (:) character ( len = STR_LEN_MONITORS ) :: planeName character ( len = STR_LEN_MONITORS ) :: fileInput character ( len = STR_LEN_MONITORS ), allocatable :: variable (:) contains procedure :: Initialization => Plane_Initialization procedure :: Update => Plane_Update procedure :: UpdateInterp => Plane_UpdateLagrangeInterp procedure :: WriteToFile => Plane_WriteToFile procedure :: LookInOtherPartitions => Plane_LookInOtherPartitions procedure :: destruct => Plane_Destruct procedure :: copy => Plane_Assign generic :: assignment ( = ) => copy end type PlaneSampling_t contains subroutine Plane_Initialization ( self , mesh , ID , solution_file , FirstCall ) use Headers use ParamfileRegions use MPI_Process_Info use Utilities , only : toLower implicit none class ( PlaneSampling_t ) :: self class ( HexMesh ) :: mesh integer :: ID character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , l , fid , nNodes , inputType , ierr logical :: firstOutDomain real ( kind = RP ) :: point_1 ( NDIM , 1 ), point_2 ( NDIM , 1 ), point_3 ( NDIM , 1 ) real ( kind = RP ), allocatable :: pStart (:,:), pEnd (:,:) real ( kind = RP ) :: x ( NDIM ), xi ( NDIM ) real ( kind = RP ) :: delta ( NDIM , 2 ), invNodes ( 2 ) real ( kind = RP ), allocatable :: deltaArray1 (:,:) character ( len = STR_LEN_MONITORS ) :: in_label character ( len = STR_LEN_MONITORS ) :: fileName character ( len = STR_LEN_MONITORS ) :: paramFile character ( len = STR_LEN_MONITORS ) :: interval character ( len = STR_LEN_MONITORS ) :: point1_char , point2_char , point3_char character ( len = STR_LEN_MONITORS ) :: N12 , N23 , inputType_char character ( len = STR_LEN_MONITORS ) :: variables character ( len = STR_LEN_MONITORS ) :: fileFormat character ( len = STR_LEN_MONITORS ) :: writeInterval character ( len = STR_LEN_MONITORS ) :: distData firstOutDomain = . FALSE . if ( FirstCall ) then ! !           Get monitor ID, assign zero to bufferLine and intervalCount !           -------------- self % ID = ID self % bufferLine = 0 self % intervalCount = 0 ! !           Search for the parameters in the case file !           ------------------------------------------ write ( in_label , '(A,I0)' ) \"#define plane sampling \" , self % ID call get_command_argument ( 1 , paramFile ) call readValueInRegion ( trim ( paramFile ), \"name\" , self % planeName , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"variables\" , variables , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"node input type\" , inputType_char , in_label , \"#end\" ) if ( len ( trim ( inputType_char )) > 0 ) then inputType = GetRealValue ( inputType_char ) else inputType = 0 end if if ( inputType . ne . 0 ) then call readValueInRegion ( trim ( paramFile ), \"input file\" , self % fileInput , in_label , \"#end\" ) else call readValueInRegion ( trim ( paramFile ), \"point 1 [x,y,z]\" , point1_char , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"point 2 [x,y,z]\" , point2_char , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"point 3 [x,y,z]\" , point3_char , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"n12\" , N12 , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"n23\" , N23 , in_label , \"#end\" ) end if call readValueInRegion ( trim ( paramFile ), \"sampling interval\" , interval , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"write interval\" , writeInterval , in_label , \"#end\" ) call readValueInRegion ( trim ( paramFile ), \"data type\" , distData , in_label , \"#end\" ) ! !           Get the variables, points, N discretization, and interval !           ---------------------------------------------- call getCharArrayFromString ( variables , STR_LEN_MONITORS , self % variable ) self % nVariables = size ( self % variable ) if ( inputType . eq . 0 ) then point_1 (:, 1 ) = getRealArrayFromString ( point1_char ) point_2 (:, 1 ) = getRealArrayFromString ( point2_char ) point_3 (:, 1 ) = getRealArrayFromString ( point3_char ) self % N ( 1 ) = GetRealValue ( N12 ) self % N ( 2 ) = GetRealValue ( N23 ) else !               Open file input for nodes open ( newunit = fid , file = trim ( self % fileInput ), status = \"old\" , action = \"read\" , iostat = ierr ) if ( ierr /= 0 ) then write ( * , * ) \"ERROR-opening input file for plane sampling: \" , trim ( self % fileInput ) stop end if read ( fid , * , iostat = ierr ) self % N ( 1 ), self % N ( 2 ) end if self % interval = GetRealValue ( interval ) interval = TRIM ( ADJUSTL ( interval )) writeInterval = TRIM ( ADJUSTL ( writeInterval )) ! !           Failsafe if the number of node is less than 2 !           --------------------------------------------- IF (( self % N ( 1 ). LT . 2 )) THEN self % N ( 1 ) = 2 END IF IF (( self % N ( 2 ). LT . 2 )) THEN self % N ( 2 ) = 2 END IF self % nNodes = self % N ( 1 ) * self % N ( 2 ) nNodes = self % nNodes ! !           Get the max. number of timestep in the buffer file before being written !           ----------------------------------------------------------------------- IF ( LEN ( TRIM ( writeInterval )) . EQ . 0 ) THEN self % bufferSize = 1 ; ELSE self % bufferSize = GetRealValue ( writeInterval ) ! !               Failsafe to prevent too many data being written at one time !               ----------------------------------------------------------- IF ( nNodes * self % bufferSize . GT . 500000 ) THEN self % bufferSize = 1 ; END IF END IF ! !           Allocate Variables !           ------------------ ALLOCATE ( self % x ( NDIM , nNodes ), self % xi ( NDIM , nNodes ), self % active ( nNodes ) & , self % eID ( nNodes ), self % rank ( nNodes ), self % fileName ( self % nVariables ) & , self % values ( nNodes + 1 , self % bufferSize , self % nVariables ), deltaArray1 ( NDIM , self % N ( 1 )) & , pStart ( NDIM , self % N ( 1 ))) ! !           Allocate Lagrange interpolants - Assumed identical polynomial for all elements !           ----------------------------------------------------------------------------- ALLOCATE ( self % lxi ( 0 : mesh % elements ( 1 ) % Nxyz ( 1 ), 1 : nNodes ), & self % leta ( 0 : mesh % elements ( 1 ) % Nxyz ( 2 ), 1 : nNodes ), & self % lzeta ( 0 : mesh % elements ( 1 ) % Nxyz ( 3 ), 1 : nNodes )) ! !           Nodes spacing !           ------------- invNodes ( 1 ) = 1.0_RP / ( self % N ( 1 ) - 1 ) invNodes ( 2 ) = 1.0_RP / ( self % N ( 2 ) - 1 ) if ( inputType . eq . 0 ) then delta ( 1 , 1 ) = ( point_2 ( 1 , 1 ) - point_1 ( 1 , 1 )) * invNodes ( 1 ) delta ( 2 , 1 ) = ( point_2 ( 2 , 1 ) - point_1 ( 2 , 1 )) * invNodes ( 1 ) delta ( 3 , 1 ) = ( point_2 ( 3 , 1 ) - point_1 ( 3 , 1 )) * invNodes ( 1 ) delta ( 1 , 2 ) = ( point_3 ( 1 , 1 ) - point_2 ( 1 , 1 )) * invNodes ( 2 ) delta ( 2 , 2 ) = ( point_3 ( 2 , 1 ) - point_2 ( 2 , 1 )) * invNodes ( 2 ) delta ( 3 , 2 ) = ( point_3 ( 3 , 1 ) - point_2 ( 3 , 1 )) * invNodes ( 2 ) ! !           Create spacing Array for Nodes in direction 1 !           --------------------------------------------- DO l = 1 , self % N ( 1 ) deltaArray1 ( 1 , l ) = ( delta ( 1 , 1 )) * ( l - 1 ) deltaArray1 ( 2 , l ) = ( delta ( 2 , 1 )) * ( l - 1 ) deltaArray1 ( 3 , l ) = ( delta ( 3 , 1 )) * ( l - 1 ) END DO ! !           Get Nodes location of the plane !           ------------------------------- DO l = 1 , self % N ( 2 ) DO k = 1 , self % N ( 1 ) DO j = 1 , 3 pStart ( j , k ) = ( point_1 ( j , 1 ) + delta ( j , 2 ) * ( l - 1 )) self % x ( j ,( l - 1 ) * self % N ( 1 ) + k ) = pStart ( j , k ) + deltaArray1 ( j , k ) END DO END DO END DO else ALLOCATE ( pEnd ( NDIM , self % N ( 1 ))) ! !           Read first points location from input file !           ---------------------------------- DO l = 1 , self % N ( 1 ) read ( fid , * , iostat = ierr ) pStart ( 1 , l ), pStart ( 2 , l ), pStart ( 3 , l ) if ( ierr /= 0 ) exit END DO ! !           Read last points location from input file !           ---------------------------------- DO l = 1 , self % N ( 1 ) read ( fid , * , iostat = ierr ) pEnd ( 1 , l ), pEnd ( 2 , l ), pEnd ( 3 , l ) if ( ierr /= 0 ) exit END DO close ( fid ) ! !           Create spacing Array for Nodes in sweep direction !           ------------------------------------------------- DO l = 1 , self % N ( 1 ) deltaArray1 ( 1 , l ) = ( pEnd ( 1 , l ) - pStart ( 1 , l )) * invNodes ( 2 ) deltaArray1 ( 2 , l ) = ( pEnd ( 2 , l ) - pStart ( 2 , l )) * invNodes ( 2 ) deltaArray1 ( 3 , l ) = ( pEnd ( 3 , l ) - pStart ( 3 , l )) * invNodes ( 2 ) END DO ! !           Get Nodes location of the plane !           ------------------------------- DO l = 1 , self % N ( 2 ) DO j = 1 , NDIM DO k = 1 , self % N ( 1 ) self % x ( j ,( l - 1 ) * self % N ( 1 ) + k ) = pStart ( j , k ) + deltaArray1 ( j , k ) * ( l - 1 ) END DO END DO END DO DEALLOCATE ( pEnd ) end if DEALLOCATE ( deltaArray1 , pStart ) ! !           Find node location in the element ID !           ------------------------------------ DO i = 1 , self % nNodes x ( 1 ) = self % x ( 1 , i ) x ( 2 ) = self % x ( 2 , i ) x ( 3 ) = self % x ( 3 , i ) ! !               Find the requested point in the mesh !               ------------------------------------ self % active ( i ) = mesh % FindPointWithCoords ( x , self % eID ( i ), xi ) self % xi ( 1 , i ) = xi ( 1 ) self % xi ( 2 , i ) = xi ( 2 ) self % xi ( 3 , i ) = xi ( 3 ) ! !               Check whether the Plane is located in other partition !               ----------------------------------------------------- call self % LookInOtherPartitions ( i ) ! !               Disable the nodes if the point is not found !               ------------------------------------------- IF ( . not . self % active ( i ) ) then IF ( . not . firstOutDomain ) then IF ( MPI_Process % isRoot ) then firstOutDomain = . TRUE . END IF END IF END IF ! !               Get the Lagrange interpolants !               ----------------------------- if ( ( MPI_Process % rank . ne . self % rank ( i )). OR .( . not . self % active ( i ) ) ) then self % lxi (:, i ) = 0.0_RP self % leta (:, i ) = 0.0_RP self % lzeta (:, i ) = 0.0_RP ELSE associate ( e => mesh % elements ( self % eID ( i ))) associate ( spAxi => NodalStorage ( e % Nxyz ( 1 )), & spAeta => NodalStorage ( e % Nxyz ( 2 )), & spAzeta => NodalStorage ( e % Nxyz ( 3 )) ) self % lxi (:, i ) = spAxi % lj ( self % xi ( 1 , i )) self % leta (:, i ) = spAeta % lj ( self % xi ( 2 , i )) self % lzeta (:, i ) = spAzeta % lj ( self % xi ( 3 , i )) end associate end associate END IF END DO end if ! !        Check Variables, Create Files, and Write Header Files !        ----------------------------------------------------- do i = 1 , self % nVariables ! !           Prepare the file in which the Plane is exported !           ----------------------------------------------- write ( self % fileName ( i ) , '(A,A,A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( self % planeName ) , \"_\" , trim ( self % variable ( i )) & , \"_plane_\" , self % ID , \".sampling\" ! !           Check the variable !           ------------------ call tolower ( self % variable ( i )) select case ( trim ( self % variable ( i )) ) #ifdef NAVIERSTOKES case ( \"density\" ) case ( \"pressure\" ) case ( \"ptotal\" ) case ( \"velocity\" ) case ( \"viscosity\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case ( \"mach\" ) case ( \"k\" ) case ( \"omegax\" ) case ( \"omegay\" ) case ( \"omegaz\" ) case ( \"q1\" ) case ( \"q2\" ) case ( \"q3\" ) case ( \"q4\" ) case ( \"q5\" ) case default if ( MPI_Process % isRoot ) then print * , 'Plane variable \"' , trim ( self % variable ( i )), '\" not implemented.' print * , \"Options available are:\" print * , \"   * density\" print * , \"   * pressure\" print * , \"   * velocity\" print * , \"   * viscosity\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" print * , \"   * Mach\" print * , \"   * K\" print * , \"   * q1\" print * , \"   * q2\" print * , \"   * q3\" print * , \"   * q4\" print * , \"   * q5\" end if #endif #ifdef INCNS case default print * , \"Planes are not implemented for the incompressible NSE\" #endif #ifdef MULTIPHASE case ( \"density\" ) case ( \"pressure\" ) case ( \"static-pressure\" ) case ( \"concentration\" ) case ( \"velocity\" ) case ( \"u\" ) case ( \"v\" ) case ( \"w\" ) case ( \"omegax\" ) case ( \"omegay\" ) case ( \"omegaz\" ) case ( \"q1\" ) case ( \"q2\" ) case ( \"q3\" ) case ( \"q4\" ) case ( \"q5\" ) case default if ( MPI_Process % isRoot ) then print * , 'Plane variable \"' , trim ( self % variable ( i )), '\" not implemented.' print * , \"Options available are:\" print * , \"   * density\" print * , \"   * pressure\" print * , \"   * static-pressure\" print * , \"   * velocity\" print * , \"   * concentration\" print * , \"   * u\" print * , \"   * v\" print * , \"   * w\" print * , \"   * omegax\" print * , \"   * omegay\" print * , \"   * omegaz\" print * , \"   * q1\" print * , \"   * q2\" print * , \"   * q3\" print * , \"   * q4\" print * , \"   * q5\" end if #endif end select if ( . not . MPI_Process % isRoot ) return ! !        Create file !        ----------- if ( FirstCall ) then if ( MPI_Process % isRoot ) then open ( newunit = fID , file = trim ( self % fileName ( i )) , action = \"write\" , access = \"stream\" , status = \"replace\" , position = 'append' ) ! !           Write the file headers !           ---------------------- write ( fID ) self % ID write ( fID ) self % N ( 1 ) write ( fID ) self % N ( 2 ) write ( fID ) self % nNodes write ( fID ) self % interval #if defined(NAVIERSTOKES) && (!(INCNS)) write ( fID ) refValues % rho write ( fID ) refValues % V write ( fID ) refValues % p write ( fID ) refValues % T write ( fID ) refValues % mu write ( fID ) refValues % AoATheta write ( fID ) refValues % AoAPhi #elif defined(MULTIPHASE) write ( fID ) refValues % rho write ( fID ) refValues % V write ( fID ) refValues % p write ( fID ) thermodynamics % rho ( 2 ) write ( fID ) thermodynamics % mu ( 1 ) write ( fID ) thermodynamics % mu ( 2 ) write ( fID ) refValues % g0 #endif write ( fID ) transpose ( self % x ) close ( fID ) end if end if end do ! !           File Format !           ----------------------------------------------- write ( fileFormat , '(A,A,A,A,I0,A)' ) trim ( solution_file ) , \"_\" , trim ( self % planeName ) , \"_'variable'_plane_\" , self % ID , \".sampling\" ! !        Write Information !        ----------------------------------------------- write ( STD_OUT , '(/)' ) call SubSection_Header ( \"Plane Samplings\" ) write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"Plane ID: \" , self % ID write ( STD_OUT , '(30X,A,A27,A128)' ) \"->\" , \"Variables: \" , variables if ( inputType . eq . 0 ) then write ( STD_OUT , '(30X,A,A27,A36)' ) \"->\" , \"Input Type: \" , \"Specified 3 points location\" write ( STD_OUT , '(30X,A,A27,A,F7.2,A,F7.2,A,F7.2,A)' ) \"->\" , \"Point x1 [m]: \" , \"[\" , & point_1 ( 1 , 1 ), \", \" , point_1 ( 2 , 1 ), \", \" , point_1 ( 3 , 1 ), \"]\" write ( STD_OUT , '(30X,A,A27,A,F7.2,A,F7.2,A,F7.2,A)' ) \"->\" , \"Point x2 [m]: \" , \"[\" , & point_2 ( 1 , 1 ), \", \" , point_2 ( 2 , 1 ), \", \" , point_2 ( 3 , 1 ), \"]\" write ( STD_OUT , '(30X,A,A27,A,F7.2,A,F7.2,A,F7.2,A)' ) \"->\" , \"Point x3 [m]: \" , \"[\" , & point_3 ( 1 , 1 ), \", \" , point_3 ( 2 , 1 ), \", \" , point_3 ( 3 , 1 ), \"]\" else write ( STD_OUT , '(30X,A,A27,A27)' ) \"->\" , \"Input Type: \" , \"Specified Input File\" write ( STD_OUT , '(30X,A,A27,A27)' ) \"->\" , \"Input File: \" , self % fileInput write ( STD_OUT , '(30X,A,A27,A,F7.2,A,F7.2,A,F7.2,A)' ) \"->\" , \"First Point [m]: \" , \"[\" , & self % x ( 1 , 1 ), \", \" , self % x ( 2 , 1 ), \", \" , self % x ( 3 , 1 ), \"]\" write ( STD_OUT , '(30X,A,A27,A,F7.2,A,F7.2,A,F7.2,A)' ) \"->\" , \"Last Point [m]: \" , \"[\" , & self % x ( 1 , self % nNodes ), \", \" , self % x ( 2 , self % nNodes ), \", \" , self % x ( 3 , self % nNodes ), \"]\" end if write ( STD_OUT , '(30X,A,A27,A,I4,A,I4,A)' ) \"->\" , \"Nodes [N12,N23]: \" , \"[\" , & self % N ( 1 ), \", \" , self % N ( 2 ), \"]\" write ( STD_OUT , '(30X,A,A27,I4)' ) \"->\" , \"Samplings Interval: \" , self % interval write ( STD_OUT , '(30X,A,A27,A128)' ) \"->\" , \"Filename: \" , fileFormat if ( firstOutDomain ) then write ( STD_OUT , '(30X,A,A27,A61)' ) \"->\" , \"Note: \" , \"Node/Nodes are located out of domain. A NaN will be assigned\" end if end subroutine Plane_Initialization ! !     Update Lagrange Interpolants After pAdaptation !     ----------------------------------------------------- subroutine Plane_UpdateLagrangeInterp ( self , mesh ) use Physics use MPI_Process_Info use , intrinsic :: ieee_arithmetic , only : IEEE_Value , IEEE_QUIET_NAN implicit none class ( PlaneSampling_t ) :: self class ( HexMesh ) :: mesh ! !        --------------- !        Local variables !        --------------- ! integer :: i ! !           Find node location in the element ID !           ------------------------------------ DO i = 1 , self % nNodes ! !               Get the Lagrange interpolants !               ----------------------------- if ( ( MPI_Process % rank . ne . self % rank ( i )). OR .( . not . self % active ( i ) ) ) then self % lxi (:, i ) = 0.0_RP self % leta (:, i ) = 0.0_RP self % lzeta (:, i ) = 0.0_RP ELSE associate ( e => mesh % elements ( self % eID ( i ))) associate ( spAxi => NodalStorage ( e % Nxyz ( 1 )), & spAeta => NodalStorage ( e % Nxyz ( 2 )), & spAzeta => NodalStorage ( e % Nxyz ( 3 )) ) self % lxi (:, i ) = spAxi % lj ( self % xi ( 1 , i )) self % leta (:, i ) = spAeta % lj ( self % xi ( 2 , i )) self % lzeta (:, i ) = spAzeta % lj ( self % xi ( 3 , i )) end associate end associate END IF END DO end subroutine Plane_UpdateLagrangeInterp subroutine Plane_Update ( self , mesh , bufferPosition , t ) use Physics use MPI_Process_Info use , intrinsic :: ieee_arithmetic , only : IEEE_Value , IEEE_QUIET_NAN implicit none class ( PlaneSampling_t ) :: self class ( HexMesh ) :: mesh integer :: bufferPosition real ( kind = RP ) :: t ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , k , l , m , ierr real ( kind = RP ) :: value , kappa real ( kind = RP ) :: c , sqrtRho real ( kind = RP ) :: NaN real ( kind = RP ) :: Sym , Asym real ( kind = RP ) :: invRhoBase , invRhoF real ( kind = RP ), allocatable :: var (:,:,:) if ( self % intervalCount . EQ . 0 ) then self % bufferLine = self % bufferLine + 1 DO m = 1 , self % nVariables self % values ( 1 , bufferPosition , m ) = t DO l = 1 , self % nNodes ! !               Assign NaN if the node located outside of domain !               ------------------------------------------------ IF ( . not . self % active ( l ) ) THEN self % values ( l , bufferPosition , m ) = IEEE_VALUE ( NaN , IEEE_QUIET_NAN ) ELSE if ( MPI_Process % rank . eq . self % rank ( l ) ) then ! !                   Update the Node !                   ---------------- associate ( e => mesh % elements ( self % eID ( l )) ) allocate ( var ( 0 : e % Nxyz ( 1 ), 0 : e % Nxyz ( 2 ), 0 : e % Nxyz ( 3 ) )) associate ( Q => e % storage % Q , S => e % storage ) #ifdef NAVIERSTOKES select case ( trim ( self % variable ( m ))) case ( \"density\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Pressure ( Q (:, i , j , k )) end do ; end do ; end do case ( \"viscosity\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) call get_laminar_mu_kappa ( Q (:, i , j , k ), var ( i , j , k ), kappa ) end do ; end do ; end do case ( \"ptotal\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k )) / POW2 ( Q ( IRHO , i , j , k )) ! Vabs**2 var ( i , j , k ) = var ( i , j , k ) / ( thermodynamics % gamma * ( thermodynamics % gamma - 1.0_RP ) * ( Q ( IRHOE , i , j , k ) / Q ( IRHO , i , j , k ) - 0.5_RP * var ( i , j , k )) ) ! Mach &#94;2 var ( i , j , k ) = Pressure ( Q (:, i , j , k )) * ( 1.0_RP + 0.5_RP * ( thermodynamics % gamma - 1.0_RP ) * var ( i , j , k )) ** ( thermodynamics % gamma / ( thermodynamics % gamma - 1.0_RP )) end do ; end do ; end do case ( \"velocity\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = sqrt ( POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k ))) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"omegax\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = ( 1 / Q ( IRHO , i , j , k ) * S % U_y ( IRHOW , i , j , k ) - Q ( IRHOW , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_y ( IRHO , i , j , k )) & - ( 1 / Q ( IRHO , i , j , k ) * S % U_z ( IRHOV , i , j , k ) - Q ( IRHOV , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_z ( IRHO , i , j , k )) end do ; end do ; end do case ( \"omegay\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = ( 1 / Q ( IRHO , i , j , k ) * S % U_z ( IRHOU , i , j , k ) - Q ( IRHOU , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_z ( IRHO , i , j , k )) & - ( 1 / Q ( IRHO , i , j , k ) * S % U_x ( IRHOW , i , j , k ) - Q ( IRHOW , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_x ( IRHO , i , j , k )) end do ; end do ; end do case ( \"omegaz\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = ( 1 / Q ( IRHO , i , j , k ) * S % U_x ( IRHOV , i , j , k ) - Q ( IRHOV , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_x ( IRHO , i , j , k )) & - ( 1 / Q ( IRHO , i , j , k ) * S % U_y ( IRHOU , i , j , k ) - Q ( IRHOU , i , j , k ) / ( Q ( IRHO , i , j , k ) ** 2 ) * S % U_y ( IRHO , i , j , k )) end do ; end do ; end do case ( \"u\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOU , i , j , k ) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"v\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOV , i , j , k ) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"w\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOW , i , j , k ) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"mach\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k )) / POW2 ( Q ( IRHO , i , j , k )) ! Vabs**2 var ( i , j , k ) = sqrt ( var ( i , j , k ) / ( thermodynamics % gamma * ( thermodynamics % gamma - 1.0_RP ) * ( Q ( IRHOE , i , j , k ) / Q ( IRHO , i , j , k ) - 0.5_RP * var ( i , j , k )) ) ) end do ; end do ; end do case ( \"k\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = 0.5_RP * ( POW2 ( Q ( IRHOU , i , j , k )) + POW2 ( Q ( IRHOV , i , j , k )) + POW2 ( Q ( IRHOW , i , j , k ))) / Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"q1\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHO , i , j , k ) end do ; end do ; end do case ( \"q2\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOU , i , j , k ) end do ; end do ; end do case ( \"q3\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOV , i , j , k ) end do ; end do ; end do case ( \"q4\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOW , i , j , k ) end do ; end do ; end do case ( \"q5\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IRHOE , i , j , k ) end do ; end do ; end do end select #endif #ifdef MULTIPHASE select case ( trim ( self % variable ( m ))) case ( \"static-pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMP , i , j , k ) + Q ( IMC , i , j , k ) * e % storage % mu ( 1 , i , j , k ) - 1 2.0_RP * multiphase % sigma * multiphase % invEps * ( POW2 ( Q ( IMC , i , j , k ) * ( 1.0_RP - Q ( IMC , i , j , k )))) & - 0.25_RP * 3.0_RP * multiphase % sigma * multiphase % eps * ( POW2 ( e % storage % c_x ( 1 , i , j , k )) + POW2 ( e % storage % c_y ( 1 , i , j , k )) + POW2 ( e % storage % c_z ( 1 , i , j , k ))) end do ; end do ; end do case ( \"concentration\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) end do ; end do ; end do case ( \"density\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) var ( i , j , k ) = c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 ) end do ; end do ; end do case ( \"pressure\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( 5 , i , j , k ) end do ; end do ; end do case ( \"velocity\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = sqrt ( POW2 ( Q ( 2 , i , j , k )) + POW2 ( Q ( 3 , i , j , k )) + POW2 ( Q ( 4 , i , j , k ))) / sqrtRho end do ; end do ; end do case ( \"omegax\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = ( 1 / sqrtRho * S % U_y ( IMSQRHOW , i , j , k ) - Q ( IMSQRHOW , i , j , k ) / ( sqrtRho ** 2 ) * S % U_y ( IMC , i , j , k )) & - ( 1 / sqrtRho * S % U_z ( IMSQRHOV , i , j , k ) - Q ( IMSQRHOV , i , j , k ) / ( sqrtRho ** 2 ) * S % U_z ( IMC , i , j , k )) end do ; end do ; end do case ( \"omegay\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = ( 1 / sqrtRho * S % U_z ( IMSQRHOU , i , j , k ) - Q ( IMSQRHOU , i , j , k ) / ( sqrtRho ** 2 ) * S % U_z ( IMC , i , j , k )) & - ( 1 / sqrtRho * S % U_x ( IMSQRHOW , i , j , k ) - Q ( IMSQRHOW , i , j , k ) / ( sqrtRho ** 2 ) * S % U_x ( IMC , i , j , k )) end do ; end do ; end do case ( \"omegaz\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = ( 1 / sqrtRho * S % U_x ( IMSQRHOV , i , j , k ) - Q ( IMSQRHOV , i , j , k ) / ( sqrtRho ** 2 ) * S % U_x ( IMC , i , j , k )) & - ( 1 / sqrtRho * S % U_y ( IMSQRHOU , i , j , k ) - Q ( IMSQRHOU , i , j , k ) / ( sqrtRho ** 2 ) * S % U_y ( IMC , i , j , k )) end do ; end do ; end do case ( \"u\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = Q ( IMSQRHOU , i , j , k ) / sqrtRho end do ; end do ; end do case ( \"v\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = Q ( IMSQRHOV , i , j , k ) / sqrtRho end do ; end do ; end do case ( \"w\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) c = min ( max ( Q ( 1 , i , j , k ), 0.0_RP ), 1.0_RP ) sqrtRho = sqrt ( c * dimensionless % rho ( 1 ) + ( 1.0_RP - c ) * dimensionless % rho ( 2 )) var ( i , j , k ) = Q ( IMSQRHOW , i , j , k ) / sqrtRho end do ; end do ; end do case ( \"q1\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMC , i , j , k ) end do ; end do ; end do case ( \"q2\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMSQRHOU , i , j , k ) end do ; end do ; end do case ( \"q3\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMSQRHOV , i , j , k ) end do ; end do ; end do case ( \"q4\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMSQRHOW , i , j , k ) end do ; end do ; end do case ( \"q5\" ) do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) var ( i , j , k ) = Q ( IMP , i , j , k ) end do ; end do ; end do end select #endif value = 0.0_RP do k = 0 , e % Nxyz ( 3 ) ; do j = 0 , e % Nxyz ( 2 ) ; do i = 0 , e % Nxyz ( 1 ) value = value + var ( i , j , k ) * self % lxi ( i , l ) * self % leta ( j , l ) * self % lzeta ( k , l ) end do ; end do ; end do self % values ( l + 1 , bufferPosition , m ) = value end associate deallocate ( var ) end associate #ifdef _HAS_MPI_ if ( MPI_Process % doMPIAction ) then !                   Share the result with the rest of the processes !                   ----------------------------------------------- call mpi_bcast ( value , 1 , MPI_DOUBLE , self % rank ( l ), MPI_COMM_WORLD , ierr ) end if #endif else !                   Receive the result from the rank that contains the Plane !                   -------------------------------------------------------- #ifdef _HAS_MPI_ if ( MPI_Process % doMPIAction ) then call mpi_bcast ( self % values ( l + 1 , bufferPosition , m ), 1 , MPI_DOUBLE , self % rank ( l ), MPI_COMM_WORLD , ierr ) end if #endif end if END IF END DO END DO end if self % intervalCount = self % intervalCount + 1 if ( self % intervalCount . EQ . self % interval ) then self % intervalCount = 0 end if end subroutine Plane_Update subroutine Plane_WriteToFile ( self , no_of_lines ) ! !        ************************************************************* !              This subroutine writes the buffer to the file. !        ************************************************************* ! implicit none class ( PlaneSampling_t ) :: self integer :: no_of_lines ! !        --------------- !        Local variables !        --------------- ! integer :: i , j , ierr integer :: fID if ( MPI_Process % isRoot ) then DO j = 1 , self % nVariables open ( newunit = fID , file = trim ( self % fileName ( j ) ) , action = \"write\" , access = \"stream\" , status = \"old\" , position = 'append' ) do i = 1 , no_of_lines write ( fID ) self % values (:, i , j ) end do close ( fID ) END DO end if if ( no_of_lines . ne . 0 ) self % values (:, 1 ,:) = self % values (:, no_of_lines ,:) self % bufferLine = 0 end subroutine Plane_WriteToFile subroutine Plane_LookInOtherPartitions ( self , i ) use MPI_Process_Info implicit none class ( PlaneSampling_t ) :: self integer , intent ( in ) :: i integer :: allActives ( MPI_Process % nProcs ) integer :: active , ierr if ( MPI_Process % doMPIAction ) then #ifdef _HAS_MPI_ ! !           Cast the logicals onto integers !           ------------------------------- if ( self % active ( i ) ) then active = 1 else active = 0 end if allActives = 0 ! !           Gather all data from all processes !           ---------------------------------- call mpi_allgather ( active , 1 , MPI_INT , allActives , 1 , MPI_INT , MPI_COMM_WORLD , ierr ) ! !           Check if any of them found the Plane !           ------------------------------------ if ( any ( allActives . eq . 1 ) ) then ! !              Assign the domain of the partition that contains the Plane !              ---------------------------------------------------------- self % active ( i ) = . true . self % rank ( i ) = maxloc ( allActives , dim = 1 ) - 1 else ! !              Disable the Plane !              ----------------- self % active ( i ) = . false . self % rank ( i ) = - 1 self % eID ( i ) = 1 end if #endif else ! !           Without MPI select the rank 0 as default !           ---------------------------------------- self % rank ( i ) = 0 end if end subroutine Plane_LookInOtherPartitions elemental subroutine Plane_Destruct ( self ) implicit none class ( PlaneSampling_t ), intent ( inout ) :: self safedeallocate ( self % values ) safedeallocate ( self % lxi ) safedeallocate ( self % leta ) safedeallocate ( self % lzeta ) safedeallocate ( self % active ) safedeallocate ( self % rank ) safedeallocate ( self % eID ) safedeallocate ( self % x ) safedeallocate ( self % xi ) safedeallocate ( self % fileName ) safedeallocate ( self % variable ) end subroutine Plane_Destruct elemental subroutine Plane_Assign ( to , from ) implicit none class ( PlaneSampling_t ), intent ( inout ) :: to type ( PlaneSampling_t ) , intent ( in ) :: from safedeallocate ( to % active ) allocate ( to % active ( size ( from % active ) ) ) to % active = from % active safedeallocate ( to % rank ) allocate ( to % rank ( size ( from % rank ) ) ) to % rank = from % rank to % ID = from % ID to % nVariables = from % nVariables to % interval = from % interval to % bufferSize = from % bufferSize to % bufferLine = from % bufferLine to % intervalCount = from % intervalCount to % N = from % N to % nNodes = from % nNodes to % disturbanceData = from % disturbanceData safedeallocate ( to % eID ) allocate ( to % eID ( size ( from % eID ) ) ) to % eID = from % eID safedeallocate ( to % lxi ) allocate ( to % lxi ( size ( from % lxi , 1 ), size ( from % lxi , 2 ) ) ) to % lxi = from % lxi safedeallocate ( to % leta ) allocate ( to % leta ( size ( from % leta , 1 ), size ( from % leta , 2 ) ) ) to % leta = from % leta safedeallocate ( to % lzeta ) allocate ( to % lzeta ( size ( from % lzeta , 1 ), size ( from % lzeta , 2 ) ) ) to % lzeta = from % lzeta safedeallocate ( to % values ) allocate ( to % values ( size ( from % values , 1 ), size ( from % values , 2 ), size ( from % values , 3 ) ) ) to % values = from % values safedeallocate ( to % x ) allocate ( to % x ( size ( from % x , 1 ), size ( from % x , 2 ) ) ) to % x = from % x safedeallocate ( to % xi ) allocate ( to % xi ( size ( from % xi , 1 ), size ( from % xi , 2 ) ) ) to % xi = from % xi safedeallocate ( to % fileName ) allocate ( to % fileName ( size ( from % fileName ) ) ) to % fileName = from % fileName to % planeName = from % planeName safedeallocate ( to % variable ) allocate ( to % variable ( size ( from % variable ) ) ) to % variable = from % variable end subroutine Plane_Assign end module PlaneSampling","tags":"","url":"sourcefile/planesampling.f90.html"},{"title":"FWHDefinitions.f90 – HORSES3D","text":"Source Code Module FWHDefinitions ! use SMConstants Implicit None private public OB_BUFFER_SIZE_DEFAULT , STR_LEN_OBSERVER , OBS_LENGTH public OB_BUFFER_SIZE public rho0 , P0 , c0 , U0 , M0 , fwGamma2 public getMeanStreamValues real ( kind = RP ) :: rho0 , P0 , c0 , fwGamma2 real ( kind = RP ), dimension ( NDIM ) :: U0 , M0 integer , parameter :: OB_BUFFER_SIZE_DEFAULT = 200 integer :: OB_BUFFER_SIZE = OB_BUFFER_SIZE_DEFAULT integer , parameter :: STR_LEN_OBSERVER = 128 integer , parameter :: OBS_LENGTH = 10 contains Subroutine getMeanStreamValues () use fluiddata ! local variables real ( kind = RP ) :: theta , phi , U0Magnitud theta = refvalues % AOAtheta * ( pi / 18 0.0_RP ) phi = refvalues % AOAphi * ( pi / 18 0.0_RP ) ! set 1 by default ! TODO use values of boundary conditions (inflow if exists or outflow, or set this defaults if not exists) U0Magnitud = 1.0_RP rho0 = 1.0_RP U0 ( 1 ) = U0Magnitud * cos ( theta ) * cos ( phi ) U0 ( 2 ) = U0Magnitud * sin ( theta ) * cos ( phi ) U0 ( 3 ) = U0Magnitud * sin ( phi ) M0 = U0 * dimensionless % Mach c0 = U0Magnitud / dimensionless % Mach fwGamma2 = 1.0_RP / ( 1.0_RP - dimensionless % Mach ** 2 ) ! default initial condition and outflow BC for energy without external pressure ! TODO include external pressure P0 = 1.0_RP / ( dimensionless % gammaM2 ) ! rhoe0 = P0 / thermodynamics%gammaMinus1 + 0.5_RP*rho0*(U0Magnitud**2) End Subroutine getMeanStreamValues End Module FWHDefinitions","tags":"","url":"sourcefile/fwhdefinitions.f90.html"},{"title":"ResidualsMonitor.f90 – HORSES3D","text":"Source Code #include \"Includes.h\" module ResidualsMonitorClass use SMConstants use PhysicsStorage use HexMeshClass use MonitorDefinitions use MPI_Process_Info implicit none private public Residuals_t ! !  ************************** !  Residuals class definition !  ************************** ! type Residuals_t logical :: active real ( kind = RP ), allocatable :: values (:,:) real ( kind = RP ), allocatable :: CPUtime (:) character ( len = STR_LEN_MONITORS ) :: fileName contains procedure :: Initialization => Residuals_Initialization procedure :: Update => Residuals_Update procedure :: WriteLabel => Residuals_WriteLabel procedure :: WriteValues => Residuals_WriteValue procedure :: WriteToFile => Residuals_WriteToFile procedure :: destruct => Residuals_Destruct procedure :: copy => Residuals_Assign generic :: assignment ( = ) => copy end type Residuals_t ! !  ======== contains !  ======== ! !////////////////////////////////////////////////////////////////////////////////////////////////// ! !           RESIDUALS ROUTINES !           ------------------ !////////////////////////////////////////////////////////////////////////////////////////////////// ! subroutine Residuals_Initialization ( self , solution_file , FirstCall ) ! !        ******************************************************************* !              This subroutine initializes the residuals structure !        ******************************************************************* ! implicit none class ( Residuals_t ) :: self character ( len =* ) :: solution_file logical , intent ( in ) :: FirstCall ! !        --------------- !        Local variables !        --------------- ! character ( len = STR_LEN_MONITORS ) :: fileName integer :: fID integer :: pos ! !        Enable the monitor !        ------------------ self % active = . true . allocate ( self % values ( NCONS , 1 : BUFFER_SIZE ) , self % CPUtime ( BUFFER_SIZE ) ) ! !        Get monitor file name !        --------------------- write ( self % fileName , '(A,A)' ) trim ( solution_file ) , \".residuals\" ! !        Create file to write the residuals !        ---------------------------------- if ( FirstCall ) then open ( newunit = fID , file = trim ( self % fileName ) , status = \"unknown\" , action = \"write\" ) write ( fID , ' ( A                                      ) ' ) \"#Residuals file\" #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) write ( fID , ' ( A10,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24 ) ' ) \"#Iteration\" , \"Time\" , & \"Total elapsed Time (s)\" , \"Solver elapsed Time (s)\" , \"continuity\" , \"x-momentum\" , \"y-momentum\" , \"z-momentum\" , \"energy\" , \"Max-Residual\" #elif defined(SPALARTALMARAS) write ( fID , ' ( A10,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24 ) ' ) \"#Iteration\" , \"Time\" , & \"Total elapsed Time (s)\" , \"Solver elapsed Time (s)\" , \"continuity\" , \"x-momentum\" , \"y-momentum\" , \"z-momentum\" , \"energy\" , \" Turbulence Param\" , \"Max-Residual\" #elif defined(INCNS) write ( fID , ' ( A10,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24 ) ' ) \"#Iteration\" , \"Time\" , & \"Elapsed Time (s)\" , \"dens-transp\" , \"x-momentum\" , \"y-momentum\" , \"z-momentum\" , \"div-v\" , \"Max-Residual\" #elif defined(MULTIPHASE) write ( fID , ' ( A10,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24 ) ' ) \"#Iteration\" , \"Time\" , & \"Elapsed Time (s)\" , \"concentration\" , \"x-momentum\" , \"y-momentum\" , \"z-momentum\" , \"div-v\" , \"Max-Residual\" #elif defined(CAHNHILLIARD) write ( fID , ' ( A10,2X,A24,2X,A24) ' ) \"#Iteration\" , \"Time\" , \"concentration\" #elif defined(ACOUSTIC) write ( fID , ' ( A10,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24,2X,A24 ) ' ) \"#Iteration\" , \"Time\" , & \"Elapsed Time (s)\" , \"density\" , \"x-velocity\" , \"y-velocity\" , \"z-velocity\" , \"pressure\" , \"Max-Residual\" #endif ! !        Close file !        ---------- close ( fID ) end if end subroutine Residuals_Initialization subroutine Residuals_Update ( self , mesh , maxResiduals , bufferPosition ) ! !        ********************************************************* !              This subroutine updates the residuals values from !           those computed in the Monitor procedure !        ********************************************************* ! implicit none class ( Residuals_t ) :: self class ( HexMesh ), intent ( in ) :: mesh real ( kind = RP ) :: maxResiduals ( NCONS ) integer :: bufferPosition ! !        Update buffer values !        -------------------- self % values ( 1 : NCONS , bufferPosition ) = maxResiduals end subroutine Residuals_Update subroutine Residuals_WriteLabel ( self ) ! !        ************************************************************ !              This subroutine displays the residuals labels for the !           time integrator Display procedure. !        ************************************************************ ! implicit none class ( Residuals_t ) :: self #if defined(NAVIERSTOKES) && (!(SPALARTALMARAS)) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"continuity\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"x-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"y-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"z-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"energy\" #elif defined(SPALARTALMARAS) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"continuity\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"x-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"y-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"z-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"energy\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"turbulence parameter\" #elif defined(INCNS) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"dens-transp\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"x-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"y-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"z-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"div-v\" #elif defined(MULTIPHASE) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"concentration\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"x-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"y-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"z-momentum\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"div-v\" #elif defined(CAHNHILLIARD) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"concentration\" #elif defined(ACOUSTIC) write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"density\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"x-velocity\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"y-velocity\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"z-velocity\" write ( STD_OUT , '(3X,A10)' , advance = \"no\" ) \"pressure\" #endif end subroutine Residuals_WriteLabel subroutine Residuals_WriteValue ( self , bufferLine ) ! !        *************************************************************** !              This subroutine displays the residuals values for the !           time integrator Display procedure !        *************************************************************** ! implicit none class ( Residuals_t ) :: self integer :: bufferLine !        --------------------------------------------------------- integer :: eq do eq = 1 , NCONS write ( STD_OUT , '(1X,A,1X,ES10.3)' , advance = \"no\" ) \"|\" , self % values ( eq , bufferLine ) end do end subroutine Residuals_WriteValue subroutine Residuals_WriteToFile ( self , iter , t , TotalSimuTime , SolverSimuTime , no_of_lines ) ! !        ********************************************************************* !              This subroutine exports the results to the monitor file. !           Just \"no_of_lines\" buffer lines are written. !        ********************************************************************* ! implicit none class ( Residuals_t ) :: self integer :: iter (:) real ( kind = RP ) :: t (:) real ( kind = RP ) :: TotalSimuTime (:) real ( kind = RP ) :: SolverSimuTime (:) integer :: no_of_lines !        ------------------------------------------- integer :: i integer :: fID #ifdef _HPC_MODE return #endif if ( MPI_Process % isRoot ) then ! !           Open file !           --------- open ( newunit = fID , file = trim ( self % fileName ) , action = \"write\" , access = \"append\" , status = \"old\" ) ! !           Write values !           ------------ do i = 1 , no_of_lines write ( fID , '(I10,3(2X,ES24.16))' , advance = \"no\" ) iter ( i ), t ( i ), TotalSimuTime ( i ), SolverSimuTime ( i ) write ( fID , 111 ) self % values ( 1 : NCONS , i ), maxval ( self % values ( 1 : NCONS , i )) end do ! !           Close file !           ---------- close ( fID ) end if if ( no_of_lines . ne . 0 ) then self % values ( 1 : NCONS , 1 ) = self % values ( 1 : NCONS , no_of_lines ) end if #if defined(FLOW) 111 format ( 6 ( 2 X , ES24 . 16 )) #elif (!defined(NAVIERSTOKES) && defined(CAHNHILLIARD)) 111 format ( 2 ( 2 X , ES24 . 16 )) #endif end subroutine Residuals_WriteToFile pure subroutine Residuals_Destruct ( self ) implicit none class ( Residuals_t ), intent ( inout ) :: self safedeallocate ( self % values ) safedeallocate ( self % CPUtime ) self % fileName = \"\" self % active = . FALSE . end subroutine Residuals_Destruct elemental subroutine Residuals_Assign ( to , from ) implicit none class ( Residuals_t ), intent ( inout ) :: to type ( Residuals_t ) , intent ( in ) :: from to % active = from % active safedeallocate ( to % values ) allocate ( to % values ( size ( from % values , 1 ) , size ( from % values , 2 ) ) ) to % values = from % values safedeallocate ( to % CPUtime ) allocate ( to % CPUtime ( size ( from % CPUtime ) ) ) to % CPUtime = from % CPUtime to % fileName = from % fileName end subroutine Residuals_Assign end module ResidualsMonitorClass","tags":"","url":"sourcefile/residualsmonitor.f90.html"},{"title":"Documentation – HORSES3D","text":"Welcome to HORSES3D This is the front page for HORSES3D user documentation including, file structure, theory and tutorials.","tags":"","url":"page/index.html"},{"title":"User Manual – HORSES3D","text":"Details for compiling the code Clone the git repository or copy the source code into a desired folder. Go to the folder Solver. Run configure script. $ ./configure Install using the Makefile: $ make all <<Oprions>> with the desired options (bold are default): MODE=DEBUG/HPC/ RELEASE COMPILER=ifort/ gfortran COMM=PARALLEL/ SEQUENTIAL ENABLE_THREADS=NO/ YES WITH_PETSC=YES/ NO WITH_METIS=YES/ NO WITH_HDF5=YES/ NO WITH_MKL=YES/ NO For example: $ make all COMPILER = ifort COMM = PARALLEL The MODE=DEBUG/HPC/RELEASE flag enables various compiler flags for different levels of code optimization. Furthermore, MODE=HPC disables residual file writing to improve performance. The ENABLE_THREADS=YES flag enables shared memory simulations using OpenMP. The COM=PARALLEL flag enables distributed memory simulations using MPI. The WITH_METIS=YES flag activates METIS linking. To compile the code linking it with METIS (that is an option for creating the mesh partitions of MPI runs), it is needed that before compilation and running, an environment variable called METIS_DIR is found. This variable must contain the path to the METIS installation folder (it must have been compiled with the same compiler as HORSES3D). The WITH_HDF5=YES flag activates HDF5 linking. To compile the code linking it with HDF5 (necessary for reading HOPR meshes), it is needed that before compilation and running, an environment variable called HDF5_DIR is found. This variable must contain the path to the HDF5 installation folder (it must have been compiled with the same compiler as HORSES3D). In addition, the lib folder must be added to the environment variable LD_LIBRARY_PATH. The WITH_PETSC=YES flag activates PETSC linking. To compile the code linking it with PETSC, it is needed that before compilation and running, an environment variable called PETSC_DIR is found. This variable must contain the path to the PETSC installation folder. If you use environment modules , it is advised to use the HORSES3D module file: $ export MODULEPATH = $HORSES_DIR /utils/modulefile: $MODULEPATH where \\$HORSES\\_DIR is the installation directory. It is advised to run the make clean or make allclean command if some options of the compilation routine need to be changed and it has been compiled before.","tags":"","url":"page/user_manual/index.html"},{"title":"Input and Output Files – HORSES3D","text":"Input files Output files Input files Control file (*.control) Mesh file (*.mesh / *.h5 / *.msh) Polynomial order file (*.omesh) Problem File (ProblemFile.f90) Notes on the GMSH format (*.msh) and general workflow using GMSH. Curved geometry supported up to polynomial order 5. Curved geometry should be generated using the following options: tools -> options -> mesh -> general -> element order . HORSES3D can read mesh format 4.1 and 2.2 (legacy format). The solution to most of the problems mesh reading is to load it in GMSH and export to format 2.2 to have a clean ASCII file. Output files Solution file (*.hsol) Horses mesh file (*.hmesh) Boundary information (*.bmesh) Partition file (*.pmesh) Polynomial order file (*.omesh) Monitor files (*.volume / *.surface / *.residuals) Note Refrain from using tabs","tags":"","url":"page/user_manual/input-and-output-files.html"},{"title":"Running a Simulation – HORSES3D","text":"Control file (*.control) - Overview Boundary conditions Restarting a Case Control file (*.control) - Overview The control file is the main file for running a simulation. A list of all the mandatory keywords for running a simulation and some basic optional keywords is presented in the table below. The specific keywords are listed in the other chapters. Keyword Description Default value solution file name CHARACTER : Path and name of the output file. The name of this file is used for naming other output files. Mandatory keyword simulation type CHARACTER : Specifies if HORSES3D must perform a 'steady-state' or a 'time-accurate' simulation. 'steady-state' time integration CHARACTER : Can be 'implicit', 'explicit', or 'FAS'. The latter uses the Full Algebraic Storage (FAS) multigrid scheme, which can have implicit or explicit smoothers. 'explicit' polynomial order INTEGER : Polynomial order to be assigned uniformly to all the elements of the mesh. If the keyword polynomial order file is specified, the value of this keyword is overridden. --* polynomial order i polynomial order j polynomial order k INTEGER : Polynomial order in the i, j, or k component for all the elements in the domain. If used, the three directions must be declared explicitly, unless you are using a polynomial order file. If the keyword polynomial order file is specified, the value of this keyword is overridden. --* polynomial order file CHARACTER : Path to a file containing the polynomial order of each element in the domain. --* restart LOGICAL : If .TRUE., initial conditions of simulation will be read from restart file specified using the keyword restart file name . Mandatory keyword cfl REAL : A constant related with the convective Courant-Friedrichs-Lewy (CFL) condition that the program will use to compute the time step size. --** dcfl REAL : A constant related with the diffusive Courant-Friedrichs-Lewy (DCFL) condition that the program will use to compute the time step size. --** dt REAL : Constant time step size. --** final time REAL : This keyword is mandatory for time-accurate solvers. -- mesh file name CHARACTER : Name of the mesh file. The currently supported formats are .mesh (SpecMesh file format) and .h5 (HOPR hdf5 file format). Mandatory keyword mesh inner curves LOGICAL : Specifies if the mesh reader must suppose that the inner surfaces (faces connecting the elements of the mesh) are curved. This input variable only affects the hdf5 mesh reader. .TRUE. number of time steps INTEGER : Maximum number of time steps that the program will compute. Mandatory keyword output interval INTEGER : In steady-state, this keyword indicates the interval of time steps to display the residuals on screen. In time-accurate simulations, this keyword indicates how often a 3D output file must be stored. Mandatory keyword convergence tolerance REAL : Residual convergence tolerance for steady-state cases. Mandatory keyword partitioning CHARACTER : Specifies the method for partitioning the mesh in MPI simulations. Options are: 'metis' (the code must have been linked to METIS at compilation time, or 'SFC' (to use a space-filling curve method, no special compilation is needed for this option). 'metis' partitioning with weights LOGICAL : Specifies if the method for partitioning the mesh in MPI simulations takes the local polynomial order as weights. Necessary for local polynomial refinement. .TRUE. manufactured solution CHARACTER : Must have the value '2D' or '3D'. When this keyword is used, the program will add source terms for the conservative variables taken into account an exact analytic solution for each primitive variable j ( , , , , $p$) of the form: . Where are constants defined in the file ManufacturedSolutions.f90 . Proper initial and boundary conditions must be imposed (see the test case). The mesh must be a unit cube. -- * One of these keywords must be specified. * For Euler simulations, the user must specify either the CFL number or the time-step size. For Navier-Stokes simulations, the user must specify the CFL and DCFL numbers or* the time-step size. Boundary conditions The boundary conditions are specified as blocks in the control file. The block starts with the keywords #define' and ends with #end'. Inside the block, the options are specified as a pair of keywords and values, just like the normal body of the rest of the file. Each boundary condition can be individually defined, or if multiple boundaries are set with the same definition, it could be done in the same block (with the name separated by a double underscore `$_$' sign). The name of each boundary must match with the one specified in the mesh file. The block in general can be seen below: #define boundary myBoundary1__myBoundary2__myBoundary3 type        = typeValue\n    parameter 1 = value_1\n    parameter 2 = value_2 # end The table below shows the values for the type keyword, and the possible values for the parameters depend on the boundary condition. | Keyword | Description | Default value | |---------|-------------|---------------| | type | * CHARACTER * : Type of boundary condition to be applied . Options are : Inflow , Outflow , NoSlipWall , FreeSlipWall , Periodic , User - defined . | N / A | By default, NoSlipWall is adiabatic. Isothermal wall can be activated with the following block: #define boundary myBoundary1__myBoundary2__myBoundary3 type = NoSlipWall\n    wall type (adiabatic/isothermal) = isothermal\n    wall temperature = 2000.0d0  !Wall temperature in K # end It is also possible to set a moving wall with the keyword wall velocity = value . For periodic boundary conditions, the second boundary that must be used as a complement must be specified by the keyword coupled boundary . These two boundaries must have the same node position in all directions but one. For mesh files generated by commercial software where this strict rule is not imposed, a comparison based on the minimum edge size of the face element can be used by a boolean parameter in the normal body of the control file (not in the block body), with the keyword periodic relative tolerance . Restarting a Case Keyword Description Default value restart LOGICAL : If .TRUE., initial conditions of simulation will be read from restart file specified using the keyword restart file name . Mandatory keyword restart file name CHARACTER : Name of the restart file to be written and, if keyword restart = .TRUE., also name of the restart file to be read for starting the simulation. Mandatory keyword restart polorder INTEGER : Uniform polynomial order of the solution to restart from. This keyword is only needed when the restart solution is of a different order than the current case. same as case's restart nodetype CHARACTER : Node type of the solution to restart from (Gauss or Gauss-Lobatto). This keyword is only needed when the restart node type is different than the current case. same as case's restart polorder file CHARACTER : File containing the polynomial orders of the solution to restart from. This keyword is only needed when the restart solution is of a different order than the current case. same as case's get discretization error of CHARACTER : Path to solution file. This can be used to estimate the discretization error of a solution when restarting from a higher-order solution. -- NS load from NSSA LOGICAL : Used only for NS simulations that are restarted from RANS SA. .FALSE.","tags":"","url":"page/user_manual/running-a-simulation.html"},{"title":"Spatial Discretization – HORSES3D","text":"HORSES3D uses a high-order discontinuous Galerkin Spectral Element (DGSEM) method. As part of the numerical method, several options of volume and surface discretization options can be selected. Some options are only available in certain solvers. Keyword Description Default value Discretization nodes CHARACTER : Node type to use in the solution. Options are: - Gauss - Gauss-Lobatto 'Gauss' Inviscid discretization CHARACTER : DG discretization of inviscid fluxes. Options are: - Standard - Split-Form 'Standard' Averaging CHARACTER : Type of averaging function to use in numerical fluxes and split-forms (if in use). Options are: - Standard - Morinishi - Ducros - Kennedy-Gruber - Pirozzoli - Entropy conserving - Chandrasekar - Skew-symmetric 1 (only for Incompressible Navier–Stokes) - Skew-symmetric 2 (only for Incompressible Navier–Stokes) -- Viscous discretization CHARACTER : Method for viscous fluxes. Options are: - BR1 - BR2 - IP 'BR2' Riemann solver CHARACTER : Riemann solver for inviscid fluxes. Options are: - Central - Roe (Only for compressible Navier–Stokes) - Standard Roe (Only for compressible Navier–Stokes) - Roe-Pike (Only for compressible Navier–Stokes) - Low dissipation Roe (Only for compressible Navier–Stokes) - Lax-Friedrichs (Only for compressible and Incompressible Navier–Stokes) - ES Lax-Friedrichs (Only for compressible Navier–Stokes, not including RANS) - u-diss (Only for compressible Navier–Stokes, not including RANS) - Rusanov (Only for compressible Navier–Stokes) - Matrix dissipation (Only for compressible Navier–Stokes) - Viscous NS (Only for compressible Navier–Stokes, not including RANS) - Exact (Only for Incompressible Navier-Stokes, and Multiphase) Mandatory keyword","tags":"","url":"page/user_manual/spatial-discretization.html"},{"title":"Physics related keywords – HORSES3D","text":"Compressible flow Shock capturing Spectral vanishing viscosity Acoustic Incompressible navier-Stokes Multiphase Particles Complementary Modes Wall functions Tripping Compressible flow Keyword Description Default value Mach number REAL : Mandatory keyword Reynolds number REAL : Mandatory keyword Prandtl number REAL : 0.72 Turbulent Prandtl number REAL : Equal to Prandtl AOA theta REAL : Angle of attack (degrees), based on the spherical coordinates polar angle ( ) definition 0.0 AOA phi REAL : Angle of attack (degrees), based on the spherical coordinates azimuthal angle ( ) definition 0.0 LES model CHARACTER (*): Options are: Vreman, Wale, Smagorinsky, None None Wall model CHARACTER : linear Shock capturing The shock-capturing module helps stabilize cases with discontinuous solutions, and may also improve the results of under-resolved turbulent cases. It is built on top of a Sensors module that detects problematic flow regions, classifying them according to the value of the sensor, , mapped into the interval , The values of and depend on the sensor thresholds and . At the moment, flow regions where are considered smooth and no stabilization algorithm can be imposed there. In the central region of the sensor, with , the methods shown in the next table can be used and even scaled with the sensor value, so that their intensity increases in elements with more instabilities. Finally, the higher part of the sensor range can implement a different method from the table; however, the intensity is set to the maximum this time. All the methods implemented introduce artificial dissipation into the equations, which can be filtered with an SVV kernel to reduce the negative impact on the accuracy of the solution. Its intensity is controlled with the parameters (similar to the viscosity of the Navier-Stokes equations) and (scaling of the density-regularization term of the Guermond-Popov flux), which can be set as constants or coupled to the value of the sensor or to a Smagorinsky formulation. Keyword Description Default value Enable shock-capturing LOGICAL : Switch on/off the shock-capturing stabilization .FALSE. Shock sensor CHARACTER : Type of sensor to be used to detect discontinuous regions Options are: Zeros: always return 0 Ones: always return 1 Integral: integral of the sensor variable inside each element Integral with sqrt: square root of the Integral sensor Modal: based on the relative weight of the higher order modes Truncation error: estimate the truncation error of the approximation Aliasing error: estimate the aliasing error of the approximation GMM: clustering sensor based on the divergence of the velocity and the gradient of the pressure Integral Shock first method CHARACTER : Method to be used in the middle region of the sensor ( ). Options are: None: Do not apply any smoothing Non-filtered: Apply the selected viscous flux without SVV filtering SVV: Apply an entropy-stable, SVV-filtered viscous flux None Shock second method CHARACTER : Method to be used in the top-most region of the sensor ( ). Options are: None: Do not apply any smoothing Non-filtered: Apply the selected viscous flux without SVV filtering SVV: Apply an entropy-stable, SVV-filtered viscous flux None Shock viscous flux 1 CHARACTER : Viscous flux to be applied in the elements where . Options are: Physical Guermond-Popov (only with entropy variables gradients) -- Shock viscous flux 2 CHARACTER : Viscous flux to be applied in the elements where . Options are: Physical Guermond-Popov (only with entropy variables gradients) -- Shock update strategy CHARACTER : Method to compute the variable parameter of the specified shock-capturing approach in the middle region of the sensor. Options are: Constant Sensor Smagorinsky: only for non-filtered and SVV Constant Shock mu 1 REAL/CHARACTER( )*: Viscosity parameter , or in the case of LES coupling 0.0 Shock alpha 1 REAL : Viscosity parameter 0.0 Shock mu 2 REAL : Viscosity parameter Shock alpha 2 REAL : Viscosity parameter Shock alpha/mu REAL : Ratio between and . It can be specified instead of itself to make it dependent on the corresponding values of , and it is compulsory when using LES coupling -- SVV filter cutoff REAL/CHARACTER( )*: Cutoff of the filter kernel, . If \"automatic\", its value is adjusted automatically \"automatic\" SVV filter shape CHARACTER( )*: Options are: Power Sharp Exponential Power SVV filter type CHARACTER( )*: Options are: Low-pass High-pass High-pass Sensor variable CHARACTER( )*: Variable used by the sensor to detect shocks. Options are: rho rhou rhov rhow u v w p rhop grad rho div v rhop Sensor lower limit REAL : Lower threshold of the central sensor region, Mandatory keyword (except GMM) Sensor higher limit REAL : Upper threshold of the central sensor region, Sensor TE min N INTEGER : Minimum polynomial order of the coarse mesh used for the truncation error estimation 1 Sensor TE delta N Polynomial order difference between the solution mesh and its coarser representation 1 Sensor TE derivative CHARACTER : Whether the face terms must be considered in the estimation of the truncation error or not. Options are: Non-isolated Isolated Isolated Sensor number of clusters INTEGER : Maximum number of clusters to use with the GMM sensor 2 Sensor min. steps INTEGER : Minimum number of time steps that an element will remain detected. The last positive value will be used if the sensor \"undetects\" an element too early 1 Spectral vanishing viscosity The introduction of an SVV-filtered artificial flux helps dissipate high-frequency oscillations. The baseline viscous flux can be chosen as the Navier-Stokes viscous flux or the flux developed by Guermond and Popov. In any case, this flux is expressed in a modal base where it is filtered by any of the following three filter kernels: power: , sharp: if , elsewhere, exponential: if , elsewhere. The extension to three dimensions allows the introduction of two types of kernels based on the one-dimensional ones: high-pass: , low-pass: , being the low-pass one more dissipative and, thus, more suited to supersonic cases. The high-pass filter, on the other hand, works better as part of the SVV-LES framework for turbulent cases. The cutoff parameter can be set as \"automatic\", which uses a sensor to differentiate troubled elements from smooth regions. The stabilisation strategy then depends on the region: smooth regions: , , , shocks: , , . In addition to this, the viscosity can be set to \"Smagorinsky\" to use the implemented SVV-LES approach. In this case, the viscosity is computed following a Smagorinsky formulation with and the viscosity parameters do not depend on the region anymore, Acoustic The Ffowcs Williams and Hawkings (FWH) acoustic analogy is implemented as a complement to the compressible NS solver. It can run both during the execution of the NS (in-time) or as at a post-process step. The version implemented includes both the solid and permeable surface variations, but both of them for a static body subjected to a constant external flow, i.e. a wind tunnel case scenario. The specifications for the FWH are divided in two parts: the general definitions (including the surfaces) and the observers definitions. The former is detailed in the table below, while the latter are defined in a block section, similar to the monitors (see monitors ): #define acoustic observer 1 name     = SomeName\n   position = [0.d0, 0.d0, 0.d0] #end # end To run the in-time computation, the observers must be defined in the control file. Beware that adding an additional observer will require to run the simulation again. To use the post-process computation, the solution on the surface must be saved at a regular time. Beware that it will need more storage. To run the post-process calculation the horses.tools binary is used, with a control file similar to the one use for the NS simulation (without monitors), and adding the keywords ''tool type'' and ''acoustic files pattern'', as explained in the table below: Keyword Description Default value acoustic analogy CHARACTER( )*: This is the main keyword for activating the acoustic analogy. The only options is: ''FWH''. -- acoustic analogy permeable LOGICAL : Defines if uses a permeable or solid approach. .FALSE. acoustic solid surface CHARACTER( )*: Array containing the name of each boundary to be used as a surface for integration. In the form: '[bc1,bc2,bc3]'. Mandatory for using the solid surface variant. -- acoustic surface file CHARACTER( )*: Path to a fictitious surface that will be used for integration. It must be tailor-made for the mesh. Mandatory for using the permeable surface variant. -- observers flush interval INTEGER : Iteration interval to flush the observers information to the files. 100 acoustic solution save LOGICAL : Defines whether it saves the NS solution on the surface. Mandatory for post-process computation. .FALSE. acoustic save timestep REAL : Controls the time or iteration at which the FWH will be calculated (and saved if specified). If the key is missing it will be done at each timestep. -- acoustic files pattern CHARACTER( )*: Pattern to the path of all the saved solutions on the surface (To be used in horses.tools for the post-process calculation). -- tool type CHARACTER( )*: Necessary for post-process calculation. Defines the type of post-process of horses.tools. For the FWH analogy the value must be ''fwh post'' -- Incompressible navier-Stokes Among the various incompressible Navier-Stokes models, HORSES3D uses an artificial compressibility \nformulation, which converts the elliptic problem into a hyperbolic system of equations, at the expense of a non divergence–free \nvelocity field. However, it allows one to avoid constructing an approximation that satisfies the inf–sup condition. \nThis methodology is well suited for use as a fluid flow engine for interface–tracking multiphase flow models, as it allows the \ndensity to vary spatially. The artificial compressibility system of equations is: The factor is computed as . This solver is run with the binary horses3d.ins. Keyword Description Default value reference velocity (m/s) REAL : Reference value for velocity -- number of fluids (1/2) INTEGER : Number of fluids present in the simulation 1 maximum density (kg/m&#94;3) REAL : Maximum value used in the limiter of the density Huge(1.0) minimum density (kg/m&#94;3) REAL : Minimum value used in the limiter of the density -Huge(1.0) artificial compressibility factor REAL : Artificial compressibility factor -- gravity acceleration (m/s&#94;2) REAL : Value of gravity acceleration -- gravity direction REAL : Array containing direction of gravity. Eg. -- The incompressible Navier Stokes solver has two modes: with 1 fluid and with 2 fluids. The required keywords are listed below. Table 1: Keywords for incompressible Navier-Stokes solver. Mode with 1 fluid Keyword Description Default value density (kg/m&#94;3) REAL : Density of the fluid -- viscosity (pa.s) REAL : Viscosity of the fluid -- Table 2: Keywords for incompressible Navier-Stokes solver. Mode with 2 fluids Keyword Description Default value fluid 1 density (kg/m&#94;3) REAL : Density of the fluid 1 -- fluid 1 viscosity (pa.s) REAL : Viscosity of the fluid 1 -- fluid 2 density (kg/m&#94;3) REAL : Density of the fluid 2 -- fluid 2 viscosity (pa.s) REAL : Viscosity of the fluid 2 -- Multiphase The multiphase flow solver implemented in HORSES3D is constructed by a combination of the diffuse interface model of Cahn–Hilliard\nwith the incompressible Navier–Stokes equations with variable density and artificial compressibility. \nThis model is entropy stable and guarantees phase conservation with an accurate representation of surface tension effects. \nThe modified entropy-stable version approximates: where is the phase field parameter, is the mobility, is the chemical potential, is the viscosity and is the artificial speed of sound. The factor is computed as .\nMobility is computed from the control file parameters chemical characteristic time , interface width and interface tension with the formula . The term can be implicity integrated to reduce the stiffnes of the problem with the keyword time integration = IMEX. This is only recomended if the value of is very high so that the time step of the explicit scheme is very small. This solver is run with the binary horses3d.mu. Keyword Description Default value fluid 1 density (kg/m&#94;3) REAL : Density of fluid 1 -- fluid 1 viscosity (pa.s) REAL : Viscosity of fluid 1 -- fluid 2 density (kg/m&#94;3) REAL : Density of fluid 2 -- fluid 2 viscosity (pa.s) REAL : Viscosity of fluid 2 -- reference velocity (m/s) REAL : Reference value for velocity -- maximum density (kg/m&#94;3) REAL : Maximum value used in the limiter of the density Huge(1.0) minimum density (kg/m&#94;3) REAL : Minimum value used in the limiter of the density -Huge(1.0) artificial compressibility factor REAL : Artificial compressibility factor -- gravity acceleration (m/s&#94;2) REAL : Value of gravity acceleration -- gravity direction REAL : Array containing direction of gravity. Eg. -- velocity direction REAL : Array containing direction of velocity used for the outflow BC. Eg. -- chemical characteristic time (s) REAL : controls the speed of the phase separation -- interface width (m) REAL : controls the interface width between the phases -- interface tension (N/m) REAL : controls the interface tension between the phases -- Particles Horses3d includes a two-way coupled Lagrangian solver.\nParticles are tracked along their trajectories, according to the simplified particle equation of motion, where only contributions from Stokes drag and gravity are retained, where and are the \\emph{ith} components of velocity and position of the particle, respectively. Furthermore, accounts for the continuous velocity of the fluid at the position of the particle.  We consider spherical Stokesian particles, so their mass and aerodynamic response time are and , respectively, being the particle density and the particle diameter. Each particle is considered to be subject to a radiative heat flux . The carrier phase is transparent to radiation, whereas the incident radiative flux on each particle is completely absorbed. Because we focus on relatively small volume fractions, the fluid-particle medium is considered to be optically thin. Under these hypotheses, the direction of the radiation is inconsequential, and each particle receives the same radiative heat flux, and its temperature is governed by where is the specific heat of the particle, which is assumed to be constant with respect to temperature. is the particle temperature and is the convective heat transfer coefficient, which for a Stokesian particle can be calculated from the Nusselt number . In practical simulations, integrating the trajectory of every particle is too expensive. Therefore, particles are agglomerated into parcels, each of them accounting for many particles with the same physical properties, position, velocity, and temperature. The evolution of the parcels is tracked with the same set of equations presented for the particles. The two-way coupling means that fluid flow is modified because of the presence of particles. Therefore, the Navier-Stokes equations are enriched with the following source terms: where is the Dirac delta function, is the number of parcels, is the number of particles per parcel and , , are the velocity, spatial coordinates, and temperature of the parcel \\emph{nth}.\nThe dimensionless form of the Navier Stokes equations can be seen in the appendix at the end of this document. Particles are solved in a box domain inside the flow domain. The box is defined with the keywords minimum box'' and maximum box''. The boundary conditions for the particles are defined with the keyword ``bc box''. Possible options are inflow/outflow, periodic and wall (with perfect rebound). Keyword Description Default value lagrangian particles LOGICAL : If .true. activates particles .false. stokes number REAL : Stokes number which for Stokesian particles is -- Gamma REAL : Ratio between specific heat of particles and fluid -- phi_m REAL : Ratio between total mass of particles and fluid -- Radiation source REAL : Non-dimensional radiation source intensity -- Froude number REAL : Froude number -- high order particles source term LOGICAL : Source term with high order Dirac delta or averaged in the whole element .false. number of particles INTEGER : Total number of parcels in the simulation -- particles per parcel REAL : particles per parcel -- Gravity direction INTEGER : Array with direction of gravity. Only required if Fr number is specified. [0,0,-1] -- particles file CHARACTER(*) : Path to file with initial position of the particles. -- vel and temp from file LOGICAL : If .true. Initial velocity and temperature of particles read from file. -- injection LOGICAL : If .true. injection of particles through a face of the box. -- particles injection INTEGER : Array with a vector indicating the direction of the injection. Eg., [0,1,0] -- particles per step INTEGER : Number of particles injected per time step. -- particles iter period INTEGER : Iteration period for particles injection. Set to 1 to inject particles every time step. -- particles injection velocity REAL : Array with particles injection non-dimensional velocity. Eg., [0.d0,1.d0,0.d0] -- particles injection temperature REAL : Particles injection non-dimensional temperature -- minimum box REAL : Array with minimum x,y,z coordinates of box with particles. Eg., [0.d0,0.d0,0.d0] -- maximum box REAL : Array with maximum x,y,z coordinates of box with particles. Eg., [4.d-2,1.6d-1,4.d-2] -- bc box INTEGER : Array with boundary conditions for particles box in the form [yz,xz,xy]. -- Warning Lagrangian particles are only implemented for the compressible Navier Stokes Lagrangian particles do not support MPI Complementary Modes Wall functions The wall function overwrites the viscous flux on the specified boundaries based on an specific law using a Newman condition. It must be used as a complement of no slip boundary condition. The table below shows the parameters that can be set in the control file. The frictional velocity is calculated using the instantaneous values of the first node (either Gauss or Gauss-Lobatto) of the element neighbour of the face element (at the opposite side of the boundary face). Currently is only supported for the compressible Navier-Stokes solver. The standard wall function uses the Reichardt law, solving the algebraic non-linear equation using the newton method to obtain the frictional velocity. The ABL function uses the logarithmic atmospheric boundary layer law, using the aerodynamic roughness; the frictional velocity is without using any numerical method. Keyword Description Default value Wall Function CHARACTER(*) : This is the main keyword for activating the wall function. Identifies the wall law to be used. Options are: - Standard: uses the Reichardt law. - ABL: uses the atmospheric boundary layer law. -- Wall Function Boundaries CHARACTER(*) : Array containing the name of each boundary to be used. In the form: '[bc1,bc2,bc3]'. Mandatory for using the wall function. -- Wall Function kappa REAL : von Karman constant 0.38 Wall Function C REAL : Log law 'C' constant 4.1 Wall Function Seed REAL : Initial value for the newton method 1.0 Wall Function Damp REAL : Initial value damp for the newton method 1.0 Wall Function Tolerance REAL : Tolerance for the newton method Wall Function max iter INTEGER : Maximum number of iterations for the newton method 100 Wall Roughness REAL : Aerodynamic roughness for the ABL wall function. Mandatory value for the ABL law. -- Wall Plane Displacement REAL : Plane displacement due to roughness for the ABL wall function 0.0 Wall Function Use Average LOGICAL : Use the time average of the velocity in the wall function, each time step the time average is recalculated. .FALSE. Tripping A numerical source term is added to the momentum equations to replicate the effect of a tripping mechanism used commonly in explerimental tests. The forcing is described via the product of two independent functions: one that depends streamwise and vertical directions (space only) and the other one describing the spanwise direction and time (space and time).\nIt can be used for the compressible NS, both LES and RANS.\nThe keywords for the trip options are: Keyword Description Default value use trip LOGICAL : This is the main keyword for activating the trip .FALSE. trip time scale REAL : Time interval between the change of the time dependent part of the trip. Mandatory trip number of modes INTEGER : Number of Fourier modes in the spanwise direction of the trip. Mandatory trip z points INTEGER : Number of points to create the Fourier Transformation of the spanwise direction, it must be greater than the number of modes and should be ideally equal to the number of discretization points of the mesh in the same direction. Mandatory trip attenuation REAL ARRAY(2) : Length scale of the gaussian attenuation of the trip, the first position is the streamwise direction and the second is the wall-normal direction. Mandatory trip zone CHARACTER(*) ARRAY(:) : Boundary condition name that constrains at least one surface where the trip center is located. It can be either one or two boundary conditions, the latter used to generate a trip in two different positions (i.e. pressure and suction sides of an airfoil). Mandatory trip center REAL : Position of the origin of the trip in the streamwise direction. Mandatory trip center 2 REAL : Position of the origin of the second trip, if used, in the streamwise direction. -- trip amplitude REAL : Maximum time varying amplitude of the trip. 1.0 trip amplitude steady REAL : Maximum steady amplitude of the trip. 0.0 random seed 1 INTEGER : Number used to initialize the random number generator of the trip. It can vary in different simulations but must remain constant for a restart. 930187532 random seed 2 INTEGER : Number used to initialize the random number generator of the trip. It can vary in different simulations but must remain constant for a restart. 597734650","tags":"","url":"page/user_manual/physics-related-keyword.html"},{"title":"Implicit Solvers with Newton Linearization – HORSES3D","text":"General Keywords Keywords for the BDF Methods Keywords for the Resenbrock-Type Implicit Runge-Kutta Methods Jacobian Specifications General Keywords The keywords for the implicit solvers are listed in the table below: Keyword Description Default value time integration CHARACTER : This is the main keyword for activating the implicit solvers. The value of it should be set to 'implicit' for the BDF solvers and to 'rosenbrock' for Rosenbrock schemes. 'explicit' 'explicit' linear solver CHARACTER : Specifies the linear solver that has to be used. Options are: - 'petsc': PETSc library Krylov-Subspace methods. Available in serial, but use with care (PETSc is not thread-safe, so OpenMP is not recommended). Only available in parallel (MPI) for preallocated Jacobians (see next section). - 'pardiso': Intel MKL PARDISO. Only available in serial or with OpenMP. - 'matrix-free gmres': A matrix-free version of the GMRES algorithm. Can be used without preconditioner or with a recursive GMRES preconditioner using 'preconditioner=GMRES'. Available in serial and parallel (OpenMP+MPI) - 'smooth': Traditional iterative methods. One can select either 'smoother=WeightedJacobi' or 'smoother=BlockJacobi'. - 'matrix-free smooth': A matrix-free version of the previous solver. Only available with 'smoother=BlockJacobi'. 'petsc' Keywords for the BDF Methods The BDF methods implemented in HORSES3D use a Newton's method Keyword Description Default value bdf order INTEGER : If present, the solver uses a BDF solver of the specified order. BDF1 - BDF5 are available, and BDF2 - BDF5 require constant time steps. 1 jacobian by convergence LOGICAL : When .TRUE., the Jacobian is only computed when the convergence falls beneath a threshold (hard-coded). This improves performance. .FALSE. compute jacobian every INTEGER : Forces the Jacobian to be computed in an interval of iterations that is specified. Inf print newton info LOGICAL : If .TRUE., the information of the Newton iterations will be displayed. '.FALSE.' implicit adaptive dt LOGICAL : Specifies if the time-step should be computed according to the convergence behavior of the Newton iterative method and the linear solver. .FALSE. newton tolerance REAL : Specifies the tolerance for the Newton's method. for time-accurate simulations, or for steady-state simulations, where is the keyword newton factor newton max iter INTEGER : Maximum number of Newton iterations for BDF solver. 30 linsolver max iter INTEGER : Maximum number of iterations to be taken by the linear solver. This keyword only affects iterative linear solvers. 500 newton factor REAL : In simulations that are not time-accurate, the tolerance of the Newton's method is a function of the residual: , where is the specified value. linsolver tol factor REAL : The linear solver tolerance is a function of the absolute error of the Newton's method:  (tol=| e_{\\infty} *a&#94;i), where is the absolute error of the Newton's method, is the Newton iteration number, and is the specified value. newton first norm REAL : Specifies an assumed infinity norm of the absolute error of the Newton's method at the iteration of the time step . This can change the behavior of the first Newton iterative method because of the dependency of the linear system tolerance on the absolute error of the Newton's method (see keyword linsolver tol factor ). Keywords for the Resenbrock-Type Implicit Runge-Kutta Methods Keyword Description Default value rosenbrock scheme CHARACTER : Rosenbrock scheme to be used. Currently, only the RO6-6 is implemented. -- Jacobian Specifications The Jacobian must be defined using a block of the form: #define Jacobian type = 2\n   print info = .TRUE.\n   preallocate = .TRUE. #end Keyword Description Default value type INTEGER : Specifies the type of Jacobian matrix to be computed. Options are: 1. Numerical Jacobian: Uses a coloring algorithm and a finite difference method to compute the DG Jacobian matrix (only available with shared memory parallelization). 2. Analytical Jacobian: Available with shared (OpenMP) or distributed (MPI) memory parallelization for advective and/or diffusive nonlinear conservation laws, BUT only for the standard DGSEM (no split-form). Mandatory Keyword print info LOGICAL : Specifies the verbosity of the Jacobian subroutines .TRUE. preallocate LOGICAL : Specifies if the Jacobian must be allocated in preprocessing (.TRUE. - only available for advective/diffusive nonlinear conservation laws) or every time it is computed (.FALSE.) .FALSE.","tags":"","url":"page/user_manual/implicit-solvers-with-newton-linearization.html"},{"title":"Explicit Solvers – HORSES3D","text":"Explicit time integration schemes available in HORSES3D .\nThe main keywords to use it are shown in the table below Keyword Description Default value time integration CHARACTER : This is the main keyword to activate the multigrid solvers. The value of it should be set to 'FAS' for the Full Approximation Scheme (FAS) nonlinear multigrid  solvers and to 'AnisFAS' for anisotropic FAS schemes. 'explicit' simulation type CHARACTER : Specifies if HORSES3D must perform a ’steady-state’ or a ’time-accurate’. If 'time-accurate' the solver switches to BDF integration and uses FAS as a pseudo problem solver. Compatible only with 'FAS'. 'steady-state' explicit method CHARACTER : Select desired Runge-Kutta solver. Options are: 'Euler', 'RK3', 'RK5', 'RKOpt', 'SSPRK33', 'SSPRK43, and 'Mixed RK' RK3 rk order INTEGER : Order of Runge-Kutta method optimized for steady-state solver ('RKOpt'). Possible orders are from 2 to 7. 2 limit timestep LOGICAL : Activate the positivity limiter of Zhang and Shu (only for SSPRK methods). .false. limiter minimum REAL : Minimum value of density and pressure allowed by the limiter. 1e-13","tags":"","url":"page/user_manual/explicit-solvers.html"},{"title":"Nonlinear p-Multigrid solver (FAS) – HORSES3D","text":"The code has an implementation of the Full Approximation Scheme (FAS) nonlinear -multigrid method. The main keywords to use it are shown in the table below: Keyword Description Default value time integration CHARACTER : This is the main keyword to activate the multigrid solvers. The value of it should be set to 'FAS' for the Full Approximation Scheme (FAS) nonlinear multigrid  solvers and to 'AnisFAS' for anisotropic FAS schemes. 'explicit' simulation type CHARACTER : Specifies if HORSES3D must perform a ’steady-state’ or a ’time-accurate’. If 'time-accurate' the solver switches to BDF integration (the exact method can be set using 'bdf order' option) and uses FAS as a local steady-state problem solver. Compatible only with 'FAS'. 'steady-state' multigrid levels INTEGER : Number of multigrid levels for the computations. Mandatory keyword delta n INTEGER : Interval of reduction of polynomial order for creating coarser multigrid levels. 1 multigrid output LOGICAL : If .TRUE., the residuals at the different multigrid levels will be displayed. .FALSE. mg sweeps INTEGER : Number of smoothing sweeps to be taken. 1* mg sweeps pre INTEGER : Number of pre-smoothing sweeps to be taken. 1* mg sweeps post INTEGER : Number of post-smoothing sweeps to be taken. 1* mg sweeps coarsest INTEGER : Number of pre- and post-smoothing sweeps to be taken on the coarsest multigrid level. Average between pre-sweeps and post-sweeps mg sweeps exact INTEGER(:) : Alternative to 'mg sweeps'. Defines exact number of pre- and post- smoothing sweeps to be taken on each level. Index of the array indicates the MG level for the sweeps to be performed, e.g. [1,4] performs 1 pre-sweep and 1 post-sweep on level 1 and 4 pre-\\/post-sweeps on level 2. 1* mg sweeps pre exact INTEGER(:) : Alternative to 'mg sweeps pre'. Defines exact number of pre-smoothing sweeps to be taken on each level. Index of the array indicates the MG level for the sweeps to be performed, e.g. [1,4] performs 1 pre-sweep on level 1 and 4 pre-sweeps on level 2. 1* mg sweeps post exact INTEGER(:) : Alternative to 'mg sweeps post'. Defines exact number of post-smoothing sweeps to be taken on each level. Index of the array indicates the MG level for the sweeps to be performed, e.g. [1,4] performs 1 post-sweep on level 1 and 4 post-sweeps on level 2. 1* mg smoother CHARACTER : The smoothing technique to be used. The keywords and possible explicit smoothers are the same as the 'explicit method' in the explicit solvers section. For the semi-implicit residual relaxation use 'BIRK5'. RK3 fasfmg residual REAL : When this keyword is used, the code uses a full multigrid (FMG) method to obtain an initial condition for the simulation. The initial condition has the specified residual. -- fasfmg save solutions LOGICAL : Save the solutions that are obtained at the different FMG levels. Only usable when fasfmg residual is used. .FALSE. postsmooth option CHARACTER : When this keyword is used, the code performs extra post-smoothing sweeps, so that the final residual after completing the post-smoothing is lower than the residual achieved by the pre-smoothing. The options are:  - 'f-cycle': Do the extra post-smoothing with an FMG cycle.  - 'smooth': Do normal smoothing. -- smooth fine REAL : Extra pre-smoothing is performed on a multigrid level of order , until a residual is obtained (( \\tilde{R}&#94;{P}|_{\\infty} < \\eta max mg sweeps INTEGER : Maximum number of smoothing sweeps to be performed. This only makes sense if one uses the keywords postsmooth option and/or smooth fine. 10000 mg initialization LOGICAL : Sets the initial explicit residual smoothing with RK3 and local time stepping. .FALSE. initial residual REAL : Threshold for the ( {\\tilde{R}&#94;{P}}|_{\\infty}) after which solver switches from the 'mg initialization' settings to user specified. initial cfl REAL : CFL and DCFL number for initial residual smoothing. 0.1 * The user must specify mg sweeps pre and mg sweeps post , or mg sweeps","tags":"","url":"page/user_manual/a-nonlinear-p-multigrid-FAS.html"},{"title":"p-adaptation-methods – HORSES3D","text":"Truncation Error p-Adaptation Reinforcement Learning p-Adaptation Multiple truncation error estimations The p-adaptation methods are used when the p-adaptation region is specified in the control file. There are two different types of p-adaptation algorithms: A Truncation Error (TE) algorithm and a Reinforcement Learning (RL) algorithm. Keyword Description Default value adaptation type CHARACTER : Can be either \"TE\" or \"RL\". TE Nmax INTEGER(3) : Maximum polynomial order in each direction for the p-adaptation algorithm (limited to 6 for RL adaptation type). Mandatory keyword Nmin INTEGER(3) : Minimum polynomial order in each direction for the p-adaptation algorithm. [1,1,1] conforming boundaries CHARACTER (*): Specifies the boundaries of the geometry that must be forced to be conforming after the p-adaptation process. -- order across faces CHARACTER : Mathematical expression to specify the maximum polynomial order jump across faces. Currently, only and are supported. mode CHARACTER : p-Adaptation mode. Can be static , time or iteration . Static p-adaptation is performed once at the beginning of a simulation for steady or unsteady simulations. static interval INTEGER/REAL : In dynamic p-adaptation cases, this keyword specifies the iteration (integer) or time (real) interval for p-adaptation. huge number restart files LOGICAL : If .TRUE., the program writes restart files before and after the p-adaptation. .FALSE. adjust nz LOGICAL : If .TRUE., the order across faces is adjusted in the directions xi, eta, and zeta of the face (being zeta the normal direction). If .FALSE., the order is only adjusted in the xi and eta directions. .FALSE. Truncation Error p-Adaptation This algorithm can perform a p-adaptation to decrease the truncation error below a threshold. #define p-adaptation adaptation type       = TE\n   Truncation error type = isolated\n   truncation error      = 1.d-2\n   Nmax                  = [10,10,10]\n   Nmin                  = [2 ,2 ,2 ]\n   Conforming boundaries = [InnerCylinder,sphere]\n   order across faces    = N*2/3\n   increasing            = .FALSE.\n   write error files     = .FALSE.\n   adjust nz             = .FALSE.\n   mode                  = time\n   interval              = 1.d0\n   restart files         = .TRUE.\n   max N decrease        = 1\n   padapted mg sweeps pre      = 10\n   padapted mg sweeps post     = 12\n   padapted mg sweeps coarsest = 20 #end Keyword Description Default value truncation error type CHARACTER : Can be either \"isolated\" or \"non-isolated\". isolated truncation error REAL : Target truncation error for the p-adaptation algorithm. Mandatory keyword coarse truncation error REAL : Truncation error used for coarsening. same as truncation error increasing LOGICAL : If .TRUE. the multi-stage FMG adaptation algorithm is used. .FALSE. write error files LOGICAL : If .TRUE., the program writes a file per element containing the directional tau-estimations. The files are stored in the folder ./ TauEstimation /. When the simulation has several adaptation stages, the new information is just appended. .FALSE. max N decrease INTEGER : Maximum decrease in the polynomial order in every p-adaptation procedure. post smoothing residual REAL : Specifies the maximum allowable deviation of after the p-adaptation procedure. -- post smoothing method CHARACTER : Either RK3 or FAS. RK3, if the last keyword is activated estimation files CHARACTER : Name of the folder that contains the error estimations obtained with the multi tau-estimation (see the section below ). -- estimation files number INTEGER(2) : First and last estimation stages to be used for p-adaptation. Mandatory if last keyword is used. padapted MULTIPLE : Specifies control file keywords that should be replaced after the adaptation procedure. Currently, only 'mg sweeps', 'mg sweeps pre', 'mg sweeps post', and 'mg sweeps coarsest' are supported. -- Reinforcement Learning p-Adaptation This algorithm can perform a p-adaptation based on a trained RL agent. #define p-adaptation adaptation type       = RL\n   agent file            = policy_padaptation/p_adaptation_policy\n   tolerance             = 1d-2\n   Nmax                  = [6, 6, 2]\n   Nmin                  = [2, 2, 2]\n   Conforming boundaries = [cylinder]\n   restart files         = .FALSE.\n   mode                  = iteration\n   interval              = 10\n   threshold             = 2.0 #end Keyword Description Default value agent file CHARACTER : Relative path to the binary file that provides the policy of the RL agent. Mandatory keyword tolerance REAL : Tolerance for the RL agent. The smaller the tolerance, the wider the adapted region. 0.01 threshold REAL : The mesh will be adapted only if the percentage of the elements that require adaptation (in relation to the total number of elements) is above the threshold. 0.0 Multiple truncation error estimations When using Truncation Error based adaptation, a static p-adaptation procedure can be driven by a set of error estimations, which have to be performed beforehand in a simulation with the following block: #define multi tau-estimation truncation error type = isolated\n   interval              = 10\n   folder                = MultiTau #end","tags":"","url":"page/user_manual/a-p-adaptation-methods.html"},{"title":"Immersed Boundary Method – HORSES3D","text":"The immersed boundary is activated during the simulation if the following lines are specified in the control file: #define IBM name                           = myIBM\n   active                         = .true.\n   penalization                   = 1.0d-6\n   semi implicit                  = .false.\n   number of objects              = 5 \n   number of interpolation points = 15\n   band region                    = .true.\n   band region coefficient        = 1.3\n   compute distance               = .true.\n   clip axis                      =  1\n   aab                            = .false.\n   describe                       = .true.\n   plot obb                       = .false.\n   plot kdtree                    = .false.\n   plot mask                      = .true.\n   plot band points               = .false. #end A folder called 'IBM' must be created. Keyword Description Default value name CHARACTER : Name assigned to immersed boundary method job. active LOGICAL : When .TRUE., the immersed boundary method is active. .FALSE. penalization REAL : Specifies the value of the penalization term, \\eta. semi implicit LOGICAL : The source term is treated in a semi-implicit manner. .FALSE. number of objects INTEGER : Specifies the maximum number of objects inside a leaf of the KD-tree. 5 number of interpolation points INTEGER : Number of points used for the interpolation of the variables' values on the surface. It's needed for the computation of the forces. 15 band region LOGICAL : If it's true, the band region is computed, otherwise it is not. .FALSE. band region coefficient INTEGER : A region -times the oriented bounding box is created (where is the band region coefficient): all the points inside this region belong to the band region. 1.5 compute distance LOGICAL : If it's true, the distance between the points in the band region and the STL file is computed, otherwise it is not. If the distance is not required, turn it off since it is an expansive operation. .FALSE. clip axis INTEGER : It's the axis along which the STL is cut. It is only needed if the forces are computed so that the integration of the variables is performed only on the portion of the STL surface lying inside the mesh. 1 corresponds to x-axis, 2 with y-axis, and 3 with z-axis. 0 aab LOGICAL : The Axis Aligned Box is computed instead of the Oriented Bounding box. It is recommended when 'clip axis' 0. .FALSE. describe LOGICAL : The immersed boundary parameters are printed on the screen. .FALSE. plot obb LOGICAL : The oriented-bounding box is plotted. .FALSE. plot kdtree LOGICAL : The kd-tree is plotted. .FALSE. plot mask LOGICAL : The degrees of freedom belonging to the mask are plotted. .FALSE. plot band points LOGICAL : The band region's points are plotted. .FALSE. STL file Immersed boundary requires, along with the mesh, a STL file. It must be put in the MESH folder with the mesh. The STL file name must be in lowercase character. In some programs, like AutoCAD, a STL file has always positive coordinates: the mesh should be built according to this consideration.\nIn the case of 2D simulations, the STL can be automatically cut by horses3D through the addition of the line clip axis (described in the previous section) so that only the STL portions inside the mesh are considered. Keyword Description Default value number of stl = INTEGER : Number of stl files. 1 stl file name = CHARACTER : The name of the STL file, without extension; it has to be inside the folder \"MESH\". Mandatory keyword stl file nameN = CHARACTER : The name of the -STL file (where N starts from 2), without extension; for the first STL just use \"stl file name\". It has to be inside the folder \"MESH\". none Computing forces In order to compute the forces on a body, the monitor should be defined as usual but the \"Marker=\" has to be equal to the name of the stl file on which the user wants to compute the forces. Given a STL file called \"stlname\", the monitor should be: #define surface monitor 1 marker = stlname\n   .\n   .\n   . #end The result of this operation is a .tec file inside the RESULTS folder. This file contains a scalar or a vector data projected on the body surface. Moving bodies If one or more of the stl files move, then the following lines must be added: #define stl motion 1 stl name         = mySTL\n   type             = rotation \n   angular velocity = 134.5d0\n   motion axis      = 2 #end \\end{lstlisting} Keyword Description Default value stl name CHARACTER : Name of the moving stl; it has to be equal to the name of one of the stl files. Mandatory keyword type CHARACTER : Type of motion, it can be ROTATION or LINEAR. Mandatory keyword angular velocity REAL : Specifies the angular velocity. It must be in [Rad]/[s]. Mandatory keyword for rotation type velocity REAL : Specifies the translation velocity. It must be in [m]/[s]. Mandatory keyword for linear type motion axis REAL : Specifies the axis along which the rotation/translation occurs. Mandatory keyword","tags":"","url":"page/user_manual/b-immersed-boundary-method.html"},{"title":"Monitors – HORSES3D","text":"Residual Monitors Statistics Monitor Probes Surface Monitors Volume monitors Load Balancing Monitors The monitors are specified individually as blocks in the control file.\nThe only general keyword that can be specified is explained in the table below: Keyword Description Default value monitors flush interval INTEGER : Iteration interval to flush the monitor information to the monitor files. 100 Residual Monitors Statistics Monitor #define statistics initial time      = 1.d0\n   initial iteration = 10\n   sampling interval = 10\n   dump interval     = 20 @start #end By default, the statistic monitor will average following variables: u v w uu vv ww uv uw vw A keyword preceded by @ is used in real-time to signalize the solver what it must do with the statistics computation: @start @pause @stop @reset @dump After reading the keyword, the solver performs the desired action and marks it with a star, e.g. @start*. Note Real-time keywords may not work in parallel MPI computations. It depends on how the system is configured. Probes #define probe 1 name     = SomeName\n   variable = SomeVariable\n   position = [0.d0, 0.d0, 0.d0] #end Keyword Description Default value name CHARACTER : Name of the monitor. Mandatory Keyword variable CHARACTER : Variable to be monitored. Implemented options are: pressure, velocity, u, v, w, mach, k. Mandatory Keyword position REAL(3) : Coordinates of the point to be monitored. Mandatory Keyword Surface Monitors #define surface monitor 1 name              = SomeName\n   marker            = NameOfBoundary\n   variable          = SomeVariable\n   reference surface = 1.d0\n   direction         = [1.d0, 0.d0, 0.d0] #end Keyword Description Default value name CHARACTER : Name of the monitor. Mandatory Keyword marker CHARACTER : Name of the boundary where a variable will be monitored. Mandatory Keyword variable CHARACTER : Variable to be monitored. Implemented options are: mass-flow, flow, pressure-force, viscous-force, force, lift, drag, pressure-average. Mandatory Keyword reference surface REAL : Reference surface [area] for the monitor. Needed for \"lift\" and \"drag\" computations. -- direction REAL(3) : Direction in which the force is going to be measured. Needed for \"pressure-force\", \"viscous-force\" and \"force\". Can be specified for \"lift\" (default [0.d0,1.d0,0.d0]) and \"drag\" (default [1.d0,0.d0,0.d0]). -- Volume monitors Volume monitors compute the average of a quantity in the whole domain. They can be scalars(s) or vectors(v). #define volume monitor 1 name     = SomeName\n   variable = SomeVariable #end Keyword Description Default value name CHARACTER : Name of the monitor. Mandatory Keyword variable CHARACTER : Variable to be monitored. The variable can be scalar (s) or vectorial (v). Implemented options are: kinetic energy (s), kinetic energy rate (s), enstrophy (s), entropy (s), entropy rate (s), mean velocity (s), velocity (v), momentum (v), source (v). Mandatory Keyword Load Balancing Monitors Load balancing monitors compute the DOF in each partition of the mesh to check the unbalance. #define load balancing monitor 1 name     = SomeName\n   variable = SomeVariable #end Keyword Description Default value name CHARACTER : Name of the monitor. Mandatory Keyword variable CHARACTER : Variable to be monitored. Implemented options are: max dof per partition, min dof per partition, avg dof per partition, absolute dof unbalancing, relative dof unbalancing. Mandatory Keyword The variable absolute dof unbalancing is computed as follows: The variable relative dof unbalancing is computed as follows:","tags":"","url":"page/user_manual/monitors.html"},{"title":"Advanced User Setup – HORSES3D","text":"Advanced users can have additional control over a simulation without having to modify the source code and recompile the code. To do that, the user can provide a set of routines that are called in different stages of the simulation via the Problem file ( ProblemFile.f90 ). A description of the routines of the Problem File can be found in the following section. Routines of the Problem File: ProblemFile.f90 UserDefinedStartup: Called before any other routines UserDefinedFinalSetup: Called after the mesh is read in to allow mesh related initializations or memory allocations. UserDefinedInitialCondition: called to set the initial condition for the flow. By default it sets an uniform initial condition, but the user can change it. UserDefinedState1, UserDefinedNeumann: Used to define an user-defined boundary condition. UserDefinedPeriodicOperation: Called before every time-step to allow periodic operations to be performed. UserDefinedSourceTermNS: Called to apply source terms to the equation. UserDefinedFinalize: Called after the solution computed to allow, for example error tests to be performed. UserDefinedTermination: Called at the the end of the main driver after everything else is done. Compiling the Problem File The Problem File file must be compiled using a specific Makefile that links it with the libraries of the code. If you are using the horses/dev environment module, you can get templates of the Problemfile.f90 and Makefile with the following commands: $ horses-get-makefile $ horses-get-problemfile Otherwise, search the test cases for examples.\\ To run a simulation using user-defined operations, create a folder called SETUP on the path were the simulation is going to be run. Then, store the modified ProblemFile.f90 and the Makefile in SETUP, and compile using: $ make <<Options>> where again the options are (bold are default): MODE=DEBUG/HPC/ RELEASE COMPILER=ifort/ gfortran COMM=PARALLEL/ SEQUENTIAL ENABLE_THREADS=NO/ YES","tags":"","url":"page/user_manual/s-advanced-user-setup.html"},{"title":"Postprocessing – HORSES3D","text":"Visualization with Tecplot Format: horses2plt Solution Files (*.hsol) Statistics Files (*.stats.hsol) Extract geometry Merge statistics tool Mapping result to different mesh Generate OpenFOAM mesh Generate HORSES3D solution file from OpenFOAM result For postprocessing the Simulation Results Visualization with Tecplot Format: horses2plt HORSES3D provides a script for converting the native binary solution files ( .hsol) into tecplot ASCII format ( .tec), which can be visualized in Pareview or Tecplot. It can also export the solution to the more recent VTKHDF format; however, note that this feature does not export boundary information or mesh files. Usage: $ horses2plt SolutionFile.hsol MeshFile.hmesh <<Options>> The options comprise following flags: Flag Description Default value --output-order= INTEGER : Output order nodes. The solution is interpolated into the desired number of points. Not Present --output-basis= CHARACTER : Either Homogeneous (for equispaced nodes, or Gauss .) Gauss --output-mode= CHARACTER : Either multizone or FE . The option multizone generates a Tecplot zone for each element. The option FE generates only one Tecplot zone for the fluid and one for each boundary (if --boundary-file is defined). Each subcell is mapped as a linear finite element. This format is faster to read by Paraview and Tecplot. multizone --output-variables= CHARACTER : Output variables separated by commas. A complete description can be found in Section 2. Q --dimensionless Specifies that the output quantities must be dimensionless. Not Present --partition-file= CHARACTER : Specifies the path to the partition file (*.pmesh) to export the MPI ranks of the simulation. Not Present --boundary-file= CHARACTER : Specifies the path to the boundary mesh file (*.bmesh) to export the surfaces as additional zones of the Tecplot file. Not Present --output-type= CHARACTER : Specifies the type of output file: tecplot or vtkhdf . tecplot Homogeneous when --output-order is specified Additionally, depending on the type of solution file, the user can specify additional options. Solution Files (*.hsol) For standard solution files, the user can specify which variables they want to be exported to the Tecplot file with the flag * -{}-output-variables= .\nThe options are: Q (default) \\rho u v w p T Mach s Vabs V Ht rhou rhov rhow rhoe c Nxi Neta Nzeta Nav N Ax\\_Xi Ax\\_Eta Ax\\_Zeta ThreeAxes Axes mpi\\_rank eID gradV u\\_x v\\_x w\\_x u\\_y v\\_y w\\_y u\\_z v\\_z w\\_z c\\_x c\\_y c\\_z \\omega \\omega\\_x \\omega\\_y \\omega\\_z \\omega\\_abs Qcrit Statistics Files (*.stats.hsol) Statistics files can generate the standard variables as well as the following variables (being the components of the Reynolds Stress tensor): umean vmean wmean S_{xx} S_{yy} S_{zz} S_{xy} S_{xz} S_{yz} Extract geometry Under construction. Merge statistics tool Tool to merge several statistics files. The usage is the following: $ horses.mergeStats *.hsol --initial-iteration = INTEGER --file-name = CHARACTER Some remarks: Only usable with statistics files that are obtained with the \"reset interval\" keyword and/or with individual consecutive simulations. Only constant time-stepping is supported. If the hsol files have the gradients, the following flag must be used $ --has-gradients Dynamic p-adaptation is currently not supported. Mapping result to different mesh HORSES3D addons, horsesConverter , has a capability to map result into different mesh file, with both have a consistent geometry. This is done by performing interpolation with the polynomial inside each element for each node point of the new mesh. The type of node quadrature will follow the quadrature defined in the .hmesh file with selected polynomial order in the control file. A control input file is required and must has name horsesConverter.convert . The template of control input file will be generated by default when executing ./horsesConverter in a directory without the control file. Error message is given when at least one node point of the new mesh is not within any element of the old mesh. After completion, a new result file is generated and named Result_interpolation.hsol . The required keywords in the control file are described in the table below. Command to execute: $ ./horsesConverter Keyword Description Default value Task meshInterpolation Mesh Filename 1 Location of the origin mesh (*.hmesh) Boundary Filename 1 Location of the origin boundary mesh (*.bmesh) Result 1 Location of the solution file with origin mesh (*.hsol) Mesh Filename 2 Location of the target mesh (*.hmesh) Boundary Filename 2 Location of the target boundary mesh (*.bmesh) Polynomial Order Polynomial order of the target mesh (1, 1, 1) Generate OpenFOAM mesh Another functionality of horsesConverter addons is to convert the mesh files, (*.hmesh) and (*.bmesh), into OpenFOAM format, the polyMesh folder. Each element is discretised into cells distributed as Gauss-Lobatto nodes. The number of division of each element, ( , , and ), is required in the control file, see previous section . After completion, a folder named foamFiles is generated. OpenFOAM mesh files, i.e. points , faces , owner , neighbour , and boundary , are located within foamFiles/constant/polyMesh . The required keywords in the control file are described in the table below Command to execute: $ ./horsesConverter Keyword Description Default value Task horsesMesh2OF Mesh Filename 1 Location of the origin mesh (*.hmesh) Boundary Filename 1 Location of the origin boundary mesh (*.bmesh) Polynomial Order Number of division of each element ( , , and ) (1, 1, 1) NOTE: Before running the mesh in the OpenFOAM environment, the type of boundaries inside the boundary file needs to be adjusted according to the actual type ( patch , wall , and symmetry ). Generate HORSES3D solution file from OpenFOAM result HORSES3D provides a capability to convert OpenFOAM result into HORSES3D solution file (*.hsol). The mesh of the OpenFOAM result must be generated by converting HORSES3D mesh files, see the previous section . Beforehand, the OpenFOAM result must be converted into VTK format(*.vtk). This not only allows the result to be in the single file but also converts cell data into point data. In the OpenFOAM environment, the command for this conversion: $ foamToVTK - fields \"(U p T rho)\" - ascii - latestTime The necessary file (.vtk) required for the control file input is inside VTK folder, see previous section for the control file template. The HORSES3D solution file is named Result\\_OF.hsol . The required keywords in the control file are described in the table below. Command to execute: $ ./horsesConverter Keyword Description Default value Task OF2Horses Mesh Filename 1 Location of the origin mesh (*.hmesh) Boundary Filename 1 Location of the origin boundary mesh (*.bmesh) Polynomial Order Polynomial order of the solution file (.hsol) (1, 1, 1) VTK file Location of VTK file (.vtk) Reynolds Number Reynolds Number/m of the solution -- =1.0m Mach Number Mach Number of the solution Reference pressure (Pa) Reference Pressure 101325 Reference temperature (K) Reference Temperature 288.889","tags":"","url":"page/user_manual/s-postprocessing.html"},{"title":"Appendix – HORSES3D","text":"Non-dimensional Navier Stokes equations Non-dimensional particle equations Non-dimensional Navier Stokes equations To illustrate the roles of various terms in the governing equations, we present here the non-dimensionalized governing compressible Navier Stokes equations with particles. We define the non-dimensional variables as: where the subscript denotes a reference value. Under these scalings, the Navier Stokes equations become: Where is the Reynolds number, is the Froude number, , is the Stokes number which for Stokesian particles is , the Prandtl number (which is assumed constant and equal to 0.72) , the Nusselt number (for Stokesian particles) and  the Mach number . Non-dimensional particle equations The non-dimensional set of equations for the particles reads: where and is the ratio of the particle specific heat capacity to the fluid isochoric specific heat capacity.","tags":"","url":"page/user_manual/t-appendix.html"}]}